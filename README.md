# displayList
















   

 


   
#### Class displayView


- [basicCamera](README.md#displayView_basicCamera)
- [basicData](README.md#displayView_basicData)
- [guid](README.md#displayView_guid)
- [initSvgScene](README.md#displayView_initSvgScene)



   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


   
      
            
#### Class later


- [add](README.md#later_add)
- [after](README.md#later_after)
- [asap](README.md#later_asap)
- [every](README.md#later_every)
- [once](README.md#later_once)
- [onFrame](README.md#later_onFrame)
- [polyfill](README.md#later_polyfill)
- [removeFrameFn](README.md#later_removeFrameFn)



   


   



      
    
      
            
#### Class Matrix3D


- [blend](README.md#Matrix3D_blend)
- [blendScale](README.md#Matrix3D_blendScale)
- [copyFrom](README.md#Matrix3D_copyFrom)
- [createCopy](README.md#Matrix3D_createCopy)
- [createIdentity](README.md#Matrix3D_createIdentity)
- [createThreeMatrix](README.md#Matrix3D_createThreeMatrix)
- [createTransformCopy](README.md#Matrix3D_createTransformCopy)
- [det](README.md#Matrix3D_det)
- [exactInverse](README.md#Matrix3D_exactInverse)
- [getCSSMatrix3D](README.md#Matrix3D_getCSSMatrix3D)
- [getRotation2D](README.md#Matrix3D_getRotation2D)
- [getSVGTransform](README.md#Matrix3D_getSVGTransform)
- [intersectPlane](README.md#Matrix3D_intersectPlane)
- [inverse](README.md#Matrix3D_inverse)
- [isValidMatrix](README.md#Matrix3D_isValidMatrix)
- [log](README.md#Matrix3D_log)
- [matMul](README.md#Matrix3D_matMul)
- [normalize](README.md#Matrix3D_normalize)
- [normalizeVector3D](README.md#Matrix3D_normalizeVector3D)
- [projectVector](README.md#Matrix3D_projectVector)
- [rotate](README.md#Matrix3D_rotate)
- [scale](README.md#Matrix3D_scale)
- [screenProjection](README.md#Matrix3D_screenProjection)
- [setDomContext](README.md#Matrix3D_setDomContext)
- [systemHas3D](README.md#Matrix3D_systemHas3D)
- [translate](README.md#Matrix3D_translate)
- [updateFromParams](README.md#Matrix3D_updateFromParams)



   
    
##### trait matrixFn

- [m00](README.md#matrixFn_m00)
- [m01](README.md#matrixFn_m01)
- [m02](README.md#matrixFn_m02)
- [m03](README.md#matrixFn_m03)
- [m10](README.md#matrixFn_m10)
- [m11](README.md#matrixFn_m11)
- [m12](README.md#matrixFn_m12)
- [m13](README.md#matrixFn_m13)
- [m20](README.md#matrixFn_m20)
- [m21](README.md#matrixFn_m21)
- [m22](README.md#matrixFn_m22)
- [m23](README.md#matrixFn_m23)
- [m30](README.md#matrixFn_m30)
- [m31](README.md#matrixFn_m31)
- [m32](README.md#matrixFn_m32)
- [m33](README.md#matrixFn_m33)


    
    


   
      
    



      
    
      
            
#### Class drawLine


- [adjustDivSize](README.md#drawLine_adjustDivSize)
- [adjustStyleProps](README.md#drawLine_adjustStyleProps)
- [attr](README.md#drawLine_attr)
- [getElem](README.md#drawLine_getElem)
- [hide](README.md#drawLine_hide)
- [length](README.md#drawLine_length)
- [moveTo](README.md#drawLine_moveTo)
- [show](README.md#drawLine_show)



   


   



      
    
      
            
#### Class surface


- [frameClear](README.md#surface_frameClear)
- [getDom](README.md#surface_getDom)
- [getHeight](README.md#surface_getHeight)
- [getWidth](README.md#surface_getWidth)
- [guid](README.md#surface_guid)
- [id](README.md#surface_id)
- [registerRenderer](README.md#surface_registerRenderer)
- [removeObject](README.md#surface_removeObject)
- [render](README.md#surface_render)
- [restartObject](README.md#surface_restartObject)
- [standardHandleRenderers](README.md#surface_standardHandleRenderers)
- [startObject](README.md#surface_startObject)
- [svgGroupHandles](README.md#surface_svgGroupHandles)
- [svgHandleRenderers](README.md#surface_svgHandleRenderers)
- [svgHandles](README.md#surface_svgHandles)



   
    
##### trait _dataTrait

- [guid](README.md#_dataTrait_guid)
- [isArray](README.md#_dataTrait_isArray)
- [isFunction](README.md#_dataTrait_isFunction)
- [isObject](README.md#_dataTrait_isObject)


    
    


   
      
    



      
    
      
            
#### Class drawIconbox


- [adjustDivSize](README.md#drawIconbox_adjustDivSize)
- [adjustStyleProps](README.md#drawIconbox_adjustStyleProps)
- [attr](README.md#drawIconbox_attr)
- [draggable](README.md#drawIconbox_draggable)
- [getElem](README.md#drawIconbox_getElem)
- [hide](README.md#drawIconbox_hide)
- [length](README.md#drawIconbox_length)
- [moveTo](README.md#drawIconbox_moveTo)
- [show](README.md#drawIconbox_show)



   


   



      
    
      
            
#### Class jsVectors


- [add](README.md#jsVectors_add)
- [angleBetween](README.md#jsVectors_angleBetween)
- [calc_cat](README.md#jsVectors_calc_cat)
- [crossProd](README.md#jsVectors_crossProd)
- [diff](README.md#jsVectors_diff)
- [dist](README.md#jsVectors_dist)
- [dotProd](README.md#jsVectors_dotProd)
- [getBarCoeffs](README.md#jsVectors_getBarCoeffs)
- [initProjection](README.md#jsVectors_initProjection)
- [length](README.md#jsVectors_length)
- [linesIntersect](README.md#jsVectors_linesIntersect)
- [mirrorVector](README.md#jsVectors_mirrorVector)
- [normalize](README.md#jsVectors_normalize)
- [opposeVector](README.md#jsVectors_opposeVector)
- [pointInTriangle](README.md#jsVectors_pointInTriangle)
- [pointInTriangleBc](README.md#jsVectors_pointInTriangleBc)
- [project](README.md#jsVectors_project)
- [rotate](README.md#jsVectors_rotate)
- [rotateAround](README.md#jsVectors_rotateAround)
- [sub](README.md#jsVectors_sub)
- [tangentNormal](README.md#jsVectors_tangentNormal)
- [triangleArea](README.md#jsVectors_triangleArea)
- [triangleInTriangle](README.md#jsVectors_triangleInTriangle)
- [unProject](README.md#jsVectors_unProject)



   


   



      
    
      
            
#### Class surfaceDom2D


- [frameClear](README.md#surfaceDom2D_frameClear)
- [getDom](README.md#surfaceDom2D_getDom)



   


   



      
    
      
            
#### Class display


- [changeCamera](README.md#display_changeCamera)
- [getCamera](README.md#display_getCamera)
- [getSurface](README.md#display_getSurface)
- [id](README.md#display_id)
- [refreshObject](README.md#display_refreshObject)
- [render](README.md#display_render)
- [renderTree](README.md#display_renderTree)



   
    
##### trait _dataTrait

- [guid](README.md#_dataTrait_guid)
- [isArray](README.md#_dataTrait_isArray)
- [isFunction](README.md#_dataTrait_isFunction)
- [isObject](README.md#_dataTrait_isObject)


    
    


   
      
    



      
    
      
            
#### Class surfaceDom3D





   


   



      
    
      
            
#### Class surfaceDomCanvas


- [canvasRender](README.md#surfaceDomCanvas_canvasRender)
- [frameClear](README.md#surfaceDomCanvas_frameClear)
- [getContext](README.md#surfaceDomCanvas_getContext)
- [renderTree](README.md#surfaceDomCanvas_renderTree)



   


   



      
    
      
            
#### Class surfaceDomSVG


- [getHoverLayer](README.md#surfaceDomSVG_getHoverLayer)
- [getSvg](README.md#surfaceDomSVG_getSvg)



   


   



      
    
      
            
#### Class surfaceDomPixi


- [frameClear](README.md#surfaceDomPixi_frameClear)
- [frameFinish](README.md#surfaceDomPixi_frameFinish)
- [getStage](README.md#surfaceDomPixi_getStage)



   


   



      
    
      
            
#### Class drawBox


- [adjustDivSize](README.md#drawBox_adjustDivSize)
- [adjustStyleProps](README.md#drawBox_adjustStyleProps)
- [attr](README.md#drawBox_attr)
- [draggable](README.md#drawBox_draggable)
- [getElem](README.md#drawBox_getElem)
- [hide](README.md#drawBox_hide)
- [length](README.md#drawBox_length)
- [moveTo](README.md#drawBox_moveTo)
- [show](README.md#drawBox_show)



   


   



      
    
      
            
#### Class pathTools


- [childenToContextBezier](README.md#pathTools_childenToContextBezier)
- [childrenToSvgBezier](README.md#pathTools_childrenToSvgBezier)



   


   



      
    
      
            
#### Class rendererPackageSVG


- [initSvg](README.md#rendererPackageSVG_initSvg)



   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


   
      
            
#### Class drawLine





   


   



      
    
      
            
#### Class svgPageRenderer


- [end](README.md#svgPageRenderer_end)
- [refresh](README.md#svgPageRenderer_refresh)
- [start](README.md#svgPageRenderer_start)



   


   



      
    
      
            
#### Class svgRectRenderer


- [end](README.md#svgRectRenderer_end)
- [refresh](README.md#svgRectRenderer_refresh)
- [start](README.md#svgRectRenderer_start)



   


   



      
    
      
            
#### Class svgCircleRenderer


- [end](README.md#svgCircleRenderer_end)
- [refresh](README.md#svgCircleRenderer_refresh)
- [start](README.md#svgCircleRenderer_start)



   


   



      
    
      
            
#### Class svgTextRenderer


- [end](README.md#svgTextRenderer_end)
- [refresh](README.md#svgTextRenderer_refresh)
- [start](README.md#svgTextRenderer_start)



   


   



      
    
      
            
#### Class svgPathRenderer


- [end](README.md#svgPathRenderer_end)
- [refresh](README.md#svgPathRenderer_refresh)
- [start](README.md#svgPathRenderer_start)



   


   



      
    
      
            
#### Class svgBezierObjectRenderer


- [end](README.md#svgBezierObjectRenderer_end)
- [refresh](README.md#svgBezierObjectRenderer_refresh)
- [start](README.md#svgBezierObjectRenderer_start)



   


   



      
    
      
            
#### Class svgBezierHandleRenderer


- [end](README.md#svgBezierHandleRenderer_end)
- [refresh](README.md#svgBezierHandleRenderer_refresh)
- [start](README.md#svgBezierHandleRenderer_start)



   


   



      
    
      
            
#### Class svgBezierPointRenderer


- [end](README.md#svgBezierPointRenderer_end)
- [refresh](README.md#svgBezierPointRenderer_refresh)
- [start](README.md#svgBezierPointRenderer_start)



   


   



      
    
      
            
#### Class svgImageRenderer


- [end](README.md#svgImageRenderer_end)
- [refresh](README.md#svgImageRenderer_refresh)
- [start](README.md#svgImageRenderer_start)



   


   



      
    



      
    
      
            
#### Class surfaceDomSVGLayer


- [getHoverLayer](README.md#surfaceDomSVGLayer_getHoverLayer)
- [getSvg](README.md#surfaceDomSVGLayer_getSvg)



   


   



      
    
      
            
#### Class svgPathParser


- [drawPath](README.md#svgPathParser_drawPath)
- [findDimensions](README.md#svgPathParser_findDimensions)
- [fitPathInto](README.md#svgPathParser_fitPathInto)
- [forCmds](README.md#svgPathParser_forCmds)
- [fromBezierArray](README.md#svgPathParser_fromBezierArray)
- [getCommands](README.md#svgPathParser_getCommands)
- [getPath](README.md#svgPathParser_getPath)
- [getSegmentCount](README.md#svgPathParser_getSegmentCount)
- [getSubPaths](README.md#svgPathParser_getSubPaths)
- [initCmd](README.md#svgPathParser_initCmd)
- [inverse](README.md#svgPathParser_inverse)
- [makePathAbsolute](README.md#svgPathParser_makePathAbsolute)
- [normalize](README.md#svgPathParser_normalize)
- [originals](README.md#svgPathParser_originals)
- [parse](README.md#svgPathParser_parse)
- [path](README.md#svgPathParser_path)
- [pathFunction](README.md#svgPathParser_pathFunction)
- [popCommand](README.md#svgPathParser_popCommand)
- [relativePosition](README.md#svgPathParser_relativePosition)
- [replacePartWith](README.md#svgPathParser_replacePartWith)
- [saveToOriginals](README.md#svgPathParser_saveToOriginals)
- [scaleFactor](README.md#svgPathParser_scaleFactor)
- [svgString](README.md#svgPathParser_svgString)
- [toBezierArray](README.md#svgPathParser_toBezierArray)
- [toQuaternionPath](README.md#svgPathParser_toQuaternionPath)
- [transformPoints](README.md#svgPathParser_transformPoints)



   
    
    
    
    
    
    
    
    


   
      
            
#### Class jsVectors


- [add](README.md#jsVectors_add)
- [angleBetween](README.md#jsVectors_angleBetween)
- [calc_cat](README.md#jsVectors_calc_cat)
- [crossProd](README.md#jsVectors_crossProd)
- [diff](README.md#jsVectors_diff)
- [dist](README.md#jsVectors_dist)
- [dotProd](README.md#jsVectors_dotProd)
- [getBarCoeffs](README.md#jsVectors_getBarCoeffs)
- [initProjection](README.md#jsVectors_initProjection)
- [length](README.md#jsVectors_length)
- [linesIntersect](README.md#jsVectors_linesIntersect)
- [mirrorVector](README.md#jsVectors_mirrorVector)
- [normalize](README.md#jsVectors_normalize)
- [opposeVector](README.md#jsVectors_opposeVector)
- [pointInTriangle](README.md#jsVectors_pointInTriangle)
- [pointInTriangleBc](README.md#jsVectors_pointInTriangleBc)
- [project](README.md#jsVectors_project)
- [rotate](README.md#jsVectors_rotate)
- [rotateAround](README.md#jsVectors_rotateAround)
- [sub](README.md#jsVectors_sub)
- [tangentNormal](README.md#jsVectors_tangentNormal)
- [triangleArea](README.md#jsVectors_triangleArea)
- [triangleInTriangle](README.md#jsVectors_triangleInTriangle)
- [unProject](README.md#jsVectors_unProject)



   


   



      
    
      
            
#### Class quaternion


- [copy](README.md#quaternion_copy)
- [inverse](README.md#quaternion_inverse)
- [multiply](README.md#quaternion_multiply)
- [normalizeVector3D](README.md#quaternion_normalizeVector3D)
- [projectVector](README.md#quaternion_projectVector)
- [rotate](README.md#quaternion_rotate)
- [setFromAxisRotation](README.md#quaternion_setFromAxisRotation)



   
    
    


   
      
            
#### Class jsVectors


- [add](README.md#jsVectors_add)
- [angleBetween](README.md#jsVectors_angleBetween)
- [calc_cat](README.md#jsVectors_calc_cat)
- [crossProd](README.md#jsVectors_crossProd)
- [diff](README.md#jsVectors_diff)
- [dist](README.md#jsVectors_dist)
- [dotProd](README.md#jsVectors_dotProd)
- [getBarCoeffs](README.md#jsVectors_getBarCoeffs)
- [initProjection](README.md#jsVectors_initProjection)
- [length](README.md#jsVectors_length)
- [linesIntersect](README.md#jsVectors_linesIntersect)
- [mirrorVector](README.md#jsVectors_mirrorVector)
- [normalize](README.md#jsVectors_normalize)
- [opposeVector](README.md#jsVectors_opposeVector)
- [pointInTriangle](README.md#jsVectors_pointInTriangle)
- [pointInTriangleBc](README.md#jsVectors_pointInTriangleBc)
- [project](README.md#jsVectors_project)
- [rotate](README.md#jsVectors_rotate)
- [rotateAround](README.md#jsVectors_rotateAround)
- [sub](README.md#jsVectors_sub)
- [tangentNormal](README.md#jsVectors_tangentNormal)
- [triangleArea](README.md#jsVectors_triangleArea)
- [triangleInTriangle](README.md#jsVectors_triangleInTriangle)
- [unProject](README.md#jsVectors_unProject)



   


   



      
    



      
    
      
            
#### Class jsBezierCurve


- [derivate](README.md#jsBezierCurve_derivate)
- [distanceOf](README.md#jsBezierCurve_distanceOf)
- [findClosestT](README.md#jsBezierCurve_findClosestT)
- [fitListTo](README.md#jsBezierCurve_fitListTo)
- [fromLine](README.md#jsBezierCurve_fromLine)
- [fromPoints](README.md#jsBezierCurve_fromPoints)
- [fromQuadCurve](README.md#jsBezierCurve_fromQuadCurve)
- [initCoeffs](README.md#jsBezierCurve_initCoeffs)
- [inverseProject](README.md#jsBezierCurve_inverseProject)
- [mirrorControls](README.md#jsBezierCurve_mirrorControls)
- [normal](README.md#jsBezierCurve_normal)
- [point_x](README.md#jsBezierCurve_point_x)
- [point_y](README.md#jsBezierCurve_point_y)
- [points](README.md#jsBezierCurve_points)
- [projectPoint](README.md#jsBezierCurve_projectPoint)
- [setControls](README.md#jsBezierCurve_setControls)
- [split](README.md#jsBezierCurve_split)
- [splitCoeff](README.md#jsBezierCurve_splitCoeff)
- [step](README.md#jsBezierCurve_step)
- [tangent](README.md#jsBezierCurve_tangent)
- [x](README.md#jsBezierCurve_x)
- [y](README.md#jsBezierCurve_y)
- [z](README.md#jsBezierCurve_z)



   


   



      
    
      
            
#### Class pathIterator


- [bezierSplit](README.md#pathIterator_bezierSplit)
- [endPoint](README.md#pathIterator_endPoint)
- [partToSvgPath](README.md#pathIterator_partToSvgPath)
- [pathFunction](README.md#pathIterator_pathFunction)
- [quadToCubic](README.md#pathIterator_quadToCubic)
- [toSvgCubicPath](README.md#pathIterator_toSvgCubicPath)
- [toSvgPath](README.md#pathIterator_toSvgPath)



   
    
    


   
      
            
#### Class jsVectors


- [add](README.md#jsVectors_add)
- [angleBetween](README.md#jsVectors_angleBetween)
- [calc_cat](README.md#jsVectors_calc_cat)
- [crossProd](README.md#jsVectors_crossProd)
- [diff](README.md#jsVectors_diff)
- [dist](README.md#jsVectors_dist)
- [dotProd](README.md#jsVectors_dotProd)
- [getBarCoeffs](README.md#jsVectors_getBarCoeffs)
- [initProjection](README.md#jsVectors_initProjection)
- [length](README.md#jsVectors_length)
- [linesIntersect](README.md#jsVectors_linesIntersect)
- [mirrorVector](README.md#jsVectors_mirrorVector)
- [normalize](README.md#jsVectors_normalize)
- [opposeVector](README.md#jsVectors_opposeVector)
- [pointInTriangle](README.md#jsVectors_pointInTriangle)
- [pointInTriangleBc](README.md#jsVectors_pointInTriangleBc)
- [project](README.md#jsVectors_project)
- [rotate](README.md#jsVectors_rotate)
- [rotateAround](README.md#jsVectors_rotateAround)
- [sub](README.md#jsVectors_sub)
- [tangentNormal](README.md#jsVectors_tangentNormal)
- [triangleArea](README.md#jsVectors_triangleArea)
- [triangleInTriangle](README.md#jsVectors_triangleInTriangle)
- [unProject](README.md#jsVectors_unProject)



   


   



      
    



      
    



      
    
      
            
#### Class jsBezierCurve


- [derivate](README.md#jsBezierCurve_derivate)
- [distanceOf](README.md#jsBezierCurve_distanceOf)
- [findClosestT](README.md#jsBezierCurve_findClosestT)
- [fitListTo](README.md#jsBezierCurve_fitListTo)
- [fromLine](README.md#jsBezierCurve_fromLine)
- [fromPoints](README.md#jsBezierCurve_fromPoints)
- [fromQuadCurve](README.md#jsBezierCurve_fromQuadCurve)
- [initCoeffs](README.md#jsBezierCurve_initCoeffs)
- [inverseProject](README.md#jsBezierCurve_inverseProject)
- [mirrorControls](README.md#jsBezierCurve_mirrorControls)
- [normal](README.md#jsBezierCurve_normal)
- [point_x](README.md#jsBezierCurve_point_x)
- [point_y](README.md#jsBezierCurve_point_y)
- [points](README.md#jsBezierCurve_points)
- [projectPoint](README.md#jsBezierCurve_projectPoint)
- [setControls](README.md#jsBezierCurve_setControls)
- [split](README.md#jsBezierCurve_split)
- [splitCoeff](README.md#jsBezierCurve_splitCoeff)
- [step](README.md#jsBezierCurve_step)
- [tangent](README.md#jsBezierCurve_tangent)
- [x](README.md#jsBezierCurve_x)
- [y](README.md#jsBezierCurve_y)
- [z](README.md#jsBezierCurve_z)



   


   



      
    
      
            
#### Class displayItem


- [_callCamera](README.md#displayItem__callCamera)
- [_callRender](README.md#displayItem__callRender)
- [_classFactory](README.md#displayItem__classFactory)
- [_find](README.md#displayItem__find)
- [_getTransfromFromModel](README.md#displayItem__getTransfromFromModel)
- [_onFrame](README.md#displayItem__onFrame)
- [_prepareCameras](README.md#displayItem__prepareCameras)
- [activeItemsBB](README.md#displayItem_activeItemsBB)
- [addActiveItem](README.md#displayItem_addActiveItem)
- [addCamera](README.md#displayItem_addCamera)
- [addToDisplay](README.md#displayItem_addToDisplay)
- [addToGroup](README.md#displayItem_addToGroup)
- [addToRenderList](README.md#displayItem_addToRenderList)
- [applyLocalTransform](README.md#displayItem_applyLocalTransform)
- [applyTransforms](README.md#displayItem_applyTransforms)
- [areHandlesVisible](README.md#displayItem_areHandlesVisible)
- [askToRemove](README.md#displayItem_askToRemove)
- [callRender](README.md#displayItem_callRender)
- [changeRenderClass](README.md#displayItem_changeRenderClass)
- [clearActiveItems](README.md#displayItem_clearActiveItems)
- [delegateEvent](README.md#displayItem_delegateEvent)
- [domMVC](README.md#displayItem_domMVC)
- [draggableFor](README.md#displayItem_draggableFor)
- [findAndRegisterCameras](README.md#displayItem_findAndRegisterCameras)
- [findCameras](README.md#displayItem_findCameras)
- [findDelegatedEventhandler](README.md#displayItem_findDelegatedEventhandler)
- [forActiveItems](README.md#displayItem_forActiveItems)
- [forDisplays](README.md#displayItem_forDisplays)
- [getActiveCamera](README.md#displayItem_getActiveCamera)
- [getCamera](README.md#displayItem_getCamera)
- [getDOMOffset](README.md#displayItem_getDOMOffset)
- [getLocalTransform](README.md#displayItem_getLocalTransform)
- [getRenderData](README.md#displayItem_getRenderData)
- [getRenderFn](README.md#displayItem_getRenderFn)
- [getRenderMatrix](README.md#displayItem_getRenderMatrix)
- [getRootNode](README.md#displayItem_getRootNode)
- [getRotationMatrix](README.md#displayItem_getRotationMatrix)
- [getScaleMatrix](README.md#displayItem_getScaleMatrix)
- [getSvgParser](README.md#displayItem_getSvgParser)
- [getTransformMatrix](README.md#displayItem_getTransformMatrix)
- [getViewMatrix](README.md#displayItem_getViewMatrix)
- [getX](README.md#displayItem_getX)
- [getY](README.md#displayItem_getY)
- [groupResizeHandler](README.md#displayItem_groupResizeHandler)
- [groupRotationHandler](README.md#displayItem_groupRotationHandler)
- [handleRotationCenter](README.md#displayItem_handleRotationCenter)
- [hideHandles](README.md#displayItem_hideHandles)
- [isDelegatingEvents](README.md#displayItem_isDelegatingEvents)
- [listenDragEventsFor](README.md#displayItem_listenDragEventsFor)
- [localId](README.md#displayItem_localId)
- [lockMovement](README.md#displayItem_lockMovement)
- [matchDomPosition](README.md#displayItem_matchDomPosition)
- [moveRotationCenterTo](README.md#displayItem_moveRotationCenterTo)
- [moveRotationCenterToSCoords](README.md#displayItem_moveRotationCenterToSCoords)
- [onActiveChange](README.md#displayItem_onActiveChange)
- [projectDimensionPoints](README.md#displayItem_projectDimensionPoints)
- [projectToCamera](README.md#displayItem_projectToCamera)
- [registerCameraFn](README.md#displayItem_registerCameraFn)
- [registerDisplay](README.md#displayItem_registerDisplay)
- [registerRenderFn](README.md#displayItem_registerRenderFn)
- [removeActiveItem](README.md#displayItem_removeActiveItem)
- [removeFromDisplay](README.md#displayItem_removeFromDisplay)
- [render](README.md#displayItem_render)
- [renderDisplayList](README.md#displayItem_renderDisplayList)
- [renderHandles](README.md#displayItem_renderHandles)
- [resizeableFor](README.md#displayItem_resizeableFor)
- [resizeableHeightFor](README.md#displayItem_resizeableHeightFor)
- [resizeableWidthFor](README.md#displayItem_resizeableWidthFor)
- [rotatableFor](README.md#displayItem_rotatableFor)
- [rotate](README.md#displayItem_rotate)
- [rotate2D](README.md#displayItem_rotate2D)
- [saveTransformUpdates](README.md#displayItem_saveTransformUpdates)
- [scale](README.md#displayItem_scale)
- [screenToItemCoords](README.md#displayItem_screenToItemCoords)
- [serialize](README.md#displayItem_serialize)
- [setClassHandleRenderers](README.md#displayItem_setClassHandleRenderers)
- [setDebugView](README.md#displayItem_setDebugView)
- [setGroupDelegate](README.md#displayItem_setGroupDelegate)
- [setHandleRenderFns](README.md#displayItem_setHandleRenderFns)
- [setPosition](README.md#displayItem_setPosition)
- [setRenderData](README.md#displayItem_setRenderData)
- [setRenderFn](README.md#displayItem_setRenderFn)
- [setRenderScope](README.md#displayItem_setRenderScope)
- [setRootNode](README.md#displayItem_setRootNode)
- [showHandles](README.md#displayItem_showHandles)
- [startRootTransform](README.md#displayItem_startRootTransform)
- [translate](README.md#displayItem_translate)
- [ungroupItem](README.md#displayItem_ungroupItem)



   
    
##### trait _dataTrait

- [guid](README.md#_dataTrait_guid)
- [isArray](README.md#_dataTrait_isArray)
- [isFunction](README.md#_dataTrait_isFunction)
- [isObject](README.md#_dataTrait_isObject)


    
    
    
##### trait listTrait

- [displayParent](README.md#listTrait_displayParent)
- [firstChild](README.md#listTrait_firstChild)
- [forChildren](README.md#listTrait_forChildren)
- [next](README.md#listTrait_next)
- [prev](README.md#listTrait_prev)


    
    
    
##### trait objectHelpers

- [createBox](README.md#objectHelpers_createBox)
- [createEmptyBook](README.md#objectHelpers_createEmptyBook)
- [createObject](README.md#objectHelpers_createObject)


    
    
    
##### trait properties

- [align](README.md#properties_align)
- [alpha](README.md#properties_alpha)
- [autoFit](README.md#properties_autoFit)
- [bgcolor](README.md#properties_bgcolor)
- [fitToPage](README.md#properties_fitToPage)
- [fontFamily](README.md#properties_fontFamily)
- [fontSize](README.md#properties_fontSize)
- [h](README.md#properties_h)
- [hasOwn](README.md#properties_hasOwn)
- [model](README.md#properties_model)
- [parent](README.md#properties_parent)
- [rad](README.md#properties_rad)
- [renderClass](README.md#properties_renderClass)
- [ri](README.md#properties_ri)
- [rj](README.md#properties_rj)
- [scaleFactor](README.md#properties_scaleFactor)
- [shadowBlur](README.md#properties_shadowBlur)
- [shadowColor](README.md#properties_shadowColor)
- [svgPath](README.md#properties_svgPath)
- [text](README.md#properties_text)
- [theList](README.md#properties_theList)
- [txtAlign](README.md#properties_txtAlign)
- [w](README.md#properties_w)
- [x](README.md#properties_x)
- [y](README.md#properties_y)


    
    
    
##### trait events

- [on](README.md#_on)
- [trigger](README.md#_trigger)


    
    


   
      
    
      
    
      
    
      
    
      
    



      
    





   
# Class displayView


The class has following internal singleton variables:
        
        
### <a name="displayView_basicCamera"></a>displayView::basicCamera(t)


```javascript
var camera1 = _data({
          "data": {
            "type": "displayItem",
            "isCamera": 1,
            "renderClass": "camera",
            "displayWidth": 800,
            "displayHeight": 1000,
            "x": 0,
            "y": 0,
            "w": 77,
            "h": 77,
            "scaleFactor": 1,
            "ri": 0,
            "rj": 0,
            "items": {
              "data": [],
              "__id": this.guid()
            }
          },
          "__id": this.guid()
        });

console.log("initializing the data -part here now...");

return camera1;
```

### <a name="displayView_basicData"></a>displayView::basicData(t)


```javascript
return {
  "data": {
    "type": "displayItem",
    "renderClass": "book",
    "w": 1000,
    "h": 1000,
    "ri": 0,
    "rj": 0,
    "items": {
      "data": [
        {
          "data": {
            "type": "displayItem",
            "renderClass": "page",
            "w": 1000,
            "h": 1000,
            "ri": 0,
            "rj": 0,
            "items": {
              "data": [],
              "__id": this.guid()
            },
            "rmatrix": {
              "data": {
                "m00": 1,
                "m01": 0,
                "m02": 0,
                "m10": 0,
                "m11": 1,
                "m12": 0,
                "m20": 0,
                "m21": 0,
                "m22": 1
              },
              "__id": this.guid()
            }
          },
          "__id": this.guid()
        }
      ],
      "__id": this.guid()
    },
    "rmatrix": {
      "data": {
        "m00": 1,
        "m01": 0,
        "m02": 0,
        "m10": 0,
        "m11": 1,
        "m12": 0,
        "m20": 0,
        "m21": 0,
        "m22": 1
      },
      "__id": this.guid()
    }
  },
  "__id": this.guid()
};
```

### <a name="displayView_guid"></a>displayView::guid(t)


```javascript
return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
```

### displayView::constructor( main )

```javascript

```
        
### <a name="displayView_initSvgScene"></a>displayView::initSvgScene(container, options)


```javascript

console.log("initSvgScene called ");
options = options || {};

var c = container.div();
c.attr({
    style : "position:relative;"
});
var intoDom = c.div();
intoDom.attr({
    style : "position:absolute;left:0px;top:0px;"
});

if(options.width) {
    container.width(options.width);
}
if(options.height) {
    container.height(options.height);
}

// var myClass = _data().createSubClass( "type", "displayItem",  displayItem_prototype );
var mySurface = surfaceDomSVG( intoDom._dom, options.width || 300, options.height || 300);

var sceneData;

if(options.data) {
    sceneData = options.data;
} else {
    sceneData = _data( this.basicData() );
    if(!options.noDemo) sceneData.items.item(0).createObject( "circle" ).bgcolor("#ff77ee").alpha(0.8);
}

var camera1 = this.basicCamera(),
    initPromise = _promise(),
    myDisplay,
    uiDisplay,
    result = {
        display : myDisplay,
        uiDisplay : uiDisplay,
        surface : mySurface,
        camera : camera1,
        data : sceneData,
        initDone : initPromise        
    };

camera1.then( function() {

    if(!options.noRenderers) {
        var rPacket = rendererPackageSVG();
        rPacket.initSvg( mySurface );
    }
    
    if(options.cameraRoot) {
        camera1.setRootNode( options.cameraRoot );
    } else {
        camera1.setRootNode( sceneData.items.item(0) );
    }
    if(options.cameraPos) {
        camera1.setPosition( options.cameraPos );
    }
    
    if(options.cameraScale) {
        camera1.scale( options.cameraScale );
    }
    
    camera1.applyTransforms();
    result.display = display( camera1, mySurface );
    myDisplay = result.display;
    
    if(options.handles) {

        // surface for the hover handles..
        var hoverSurface = surfaceDomSVGLayer( mySurface.getHoverLayer(), options.width || 300, options.height || 300);
        hoverSurface.svgHandles("box");
        hoverSurface.svgHandles("circle");
        hoverSurface.svgHandles("text");
        hoverSurface.svgHandles("svgpath");    
        
        if(options.handleClasses) {
            options.handleClasses.forEach( function(hcName) {
                hoverSurface.svgHandles(hcName); 
            });
        }

        result.uiDisplay = uiDisplay = display( camera1, hoverSurface );
    }
    initPromise.resolve(true);
});


return result;
```



   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


   
      
            
# Class later


The class has following internal singleton variables:
        
* _initDone
        
* _callers
        
* _oneTimers
        
* _everies
        
* _framers
        
* _localCnt
        
        
### <a name="later_add"></a>later::add(fn, thisObj, args)


```javascript
if(thisObj || args) {
   var tArgs;
   if( Object.prototype.toString.call( args ) === '[object Array]' ) {
       tArgs = args;
   } else {
       tArgs = Array.prototype.slice.call(arguments, 2);
       if(!tArgs) tArgs = [];
   }
   _callers.push([thisObj, fn, tArgs]);   
} else {
    _callers.push(fn);
}
```

### <a name="later_after"></a>later::after(seconds, fn, name)


```javascript

if(!name) {
    name = "aft7491_"+(_localCnt++);
}

_everies[name] = {
    step : Math.floor(seconds * 1000),
    fn : fn,
    nextTime : 0,
    remove : true
};
```

### <a name="later_asap"></a>later::asap(fn)


```javascript
this.add(fn);

```

### <a name="later_every"></a>later::every(seconds, fn, name)


```javascript

if(!name) {
    name = "t7491_"+(_localCnt++);
}

_everies[name] = {
    step : Math.floor(seconds * 1000),
    fn : fn,
    nextTime : 0
};
```

### later::constructor( interval, fn )

```javascript
if(!_initDone) {

   _localCnt=1;
   this.polyfill();
 
   var frame, cancelFrame;
   if(typeof(window) != "undefined") {
       var frame = window['requestAnimationFrame'], 
           cancelFrame= window['cancelRequestAnimationFrame'];
       ['', 'ms', 'moz', 'webkit', 'o'].forEach( function(x) { 
           if(!frame) {
            frame = window[x+'RequestAnimationFrame'];
            cancelFrame = window[x+'CancelAnimationFrame'] 
                                       || window[x+'CancelRequestAnimationFrame'];
           }
        });
   }
 
    if (!frame)
        frame= function(cb) {
            return setTimeout(cb, 16);
        };
 
    if (!cancelFrame)
        cancelFrame = function(id) {
            clearTimeout(id);
        };    
        
    _callers = [];
    _oneTimers = {};
    _everies = {};
    _framers = [];
    var lastMs = 0;
    
    var _callQueQue = function() {
       var ms = (new Date()).getTime();
       var fn;
       while(fn=_callers.shift()) {
          if(Object.prototype.toString.call( fn ) === '[object Array]' ) {
              fn[1].apply(fn[0], fn[2]);
          } else {
              fn();
          }
           
       }
       
       for(var i=0; i<_framers.length;i++) {
           var fFn = _framers[i];
           fFn();
       }
       
       for(var n in _oneTimers) {
           if(_oneTimers.hasOwnProperty(n)) {
               var v = _oneTimers[n];
               v[0](v[1]);
               delete _oneTimers[n];
           }
       }
       
       for(var n in _everies) {
           if(_everies.hasOwnProperty(n)) {
               var v = _everies[n];
               if(v.nextTime < ms) {
                   if(v.remove) {
                       if(v.nextTime > 0) {
                          v.fn(); 
                          delete _everies[n];
                       } else {
                          v.nextTime = ms + v.step; 
                       }
                   } else {
                       v.fn();
                       v.nextTime = ms + v.step;
                   }
               }
               if(v.until) {
                   if(v.until < ms) {
                       delete _everies[n];
                   }
               }
           }
       }       
       
       frame(_callQueQue);
       lastMs = ms;
    };
    _callQueQue();
    _initDone = true;
}
```
        
### <a name="later_once"></a>later::once(key, fn, value)


```javascript
// _oneTimers

_oneTimers[key] = [fn,value];
```

### <a name="later_onFrame"></a>later::onFrame(fn)


```javascript

_framers.push(fn);
```

### <a name="later_polyfill"></a>later::polyfill(t)


```javascript
// --- let's not ---
```

### <a name="later_removeFrameFn"></a>later::removeFrameFn(fn)


```javascript

var i = _framers.indexOf(fn);
if(i>=0) {
    if(fn._onRemove) {
        fn._onRemove();
    }
    _framers.splice(i,1);
    return true;
} else {
    return false;
}
```



   


   



      
    
      
            
# Class Matrix3D


The class has following internal singleton variables:
        
* _initDone
        
* _m3dSupport
        
        
### <a name="Matrix3D_blend"></a>Matrix3D::blend(t)


```javascript

if(this._scaleBlenders) {
    var t = this._scaleBlendFn();
    var m0 = this._scaleBlenders[0];
    var m1 = this._scaleBlenders[1];
    
    if(typeof(t)=="undefined") return;
    
    this.m00( m0.m00()*(1-t) + m1.m00()*t);
    this.m11( m0.m11()*(1-t) + m1.m11()*t);
    this.m22( m0.m22()*(1-t) + m1.m22()*t);
    
}
```

### <a name="Matrix3D_blendScale"></a>Matrix3D::blendScale(mList, blendFn)


```javascript

this._scaleBlenders = mList;
this._scaleBlendFn = blendFn;



```

### <a name="Matrix3D_copyFrom"></a>Matrix3D::copyFrom(matrix)


```javascript
var mm = matrix._data;

this._data.m00 = mm.m00;
this._data.m01 = mm.m01;
this._data.m02 = mm.m02;
this._data.m03 = mm.m03;

this._data.m10 = mm.m10;
this._data.m11 = mm.m11;
this._data.m12 = mm.m12;
this._data.m13 = mm.m13;

this._data.m20 = mm.m20;
this._data.m21 = mm.m21;
this._data.m22 = mm.m22;
this._data.m23 = mm.m23;

this._data.m30 = mm.m30;
this._data.m31 = mm.m31;
this._data.m32 = mm.m32;
this._data.m33 = mm.m33;
```

### <a name="Matrix3D_createCopy"></a>Matrix3D::createCopy(t)


```javascript
var newM = this.createIdentity();
newM.updateFromParams( 
        this.m00(),
        this.m01(),
        this.m02(),
        this.m03(),
        
        this.m10(),
        this.m11(),
        this.m12(),
        this.m13(),
        
        this.m20(),
        this.m21(),
        this.m22(),
        this.m23(),
        
        this.m30(),
        this.m31(),
        this.m32(),
        this.m33()
    );
    
return newM;
```

### <a name="Matrix3D_createIdentity"></a>Matrix3D::createIdentity(t)


```javascript
return Matrix3D();
```

### <a name="Matrix3D_createThreeMatrix"></a>Matrix3D::createThreeMatrix(t)


```javascript
var m = new THREE.Matrix4();
m.set(  this.m00(),
        this.m10(),
        this.m20(),
        this.m30(),
        this.m01(),
        this.m11(),
        this.m21(),
        this.m31(),
        this.m02(),
        this.m12(),
        this.m22(),
        this.m32(),
        this.m03(),
        this.m13(),
        this.m23(),
        this.m33());
return m;
```

### <a name="Matrix3D_createTransformCopy"></a>Matrix3D::createTransformCopy(t)


```javascript

var newM = Matrix3D();

newM.m30( this.m30() );
newM.m31( this.m31() );
newM.m32( this.m32() );

return newM;
```

### <a name="Matrix3D_det"></a>Matrix3D::det(t)


```javascript
var m00 = this.m00(), m01 = this.m01(), m02 = this.m02(), m03 = this.m03(),
    m10 = this.m10(), m11 = this.m11(), m12 = this.m12(), m13 = this.m13(),
    m20 = this.m20(), m21 = this.m21(), m22 = this.m22(), m23 = this.m23(),
    m30 = this.m30(), m31 = this.m31(), m32 = this.m32(), m33 = this.m33();
    
    var a0 = m00 * m11 - m10 * m01;
    var a1 = m00 * m21 - m20 * m01;
    var a2 = m00 * m31 - m30 * m01;
    var a3 = m10 * m21 - m20 * m11;
    var a4 = m10 * m31 - m30 * m11;
    var a5 = m20 * m31 - m30 * m21;
    var b0 = m02 * m13 - m12 * m03;
    var b1 = m02 * m23 - m22 * m03;
    var b2 = m02 * m33 - m32 * m03;
    var b3 = m12 * m23 - m22 * m13;
    var b4 = m12 * m33 - m32 * m13;
    var b5 = m22 * m33 - m32 * m23;
 
 return   a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
```

### <a name="Matrix3D_exactInverse"></a>Matrix3D::exactInverse(t)


```javascript

    var m00 = this.m00(), m01 = this.m01(), m02 = this.m02(), m03 = this.m03(),
        m10 = this.m10(), m11 = this.m11(), m12 = this.m12(), m13 = this.m13(),
        m20 = this.m20(), m21 = this.m21(), m22 = this.m22(), m23 = this.m23(),
        m30 = this.m30(), m31 = this.m31(), m32 = this.m32(), m33 = this.m33();

    var a0 = m00 * m11 - m10 * m01;
    var a1 = m00 * m21 - m20 * m01;
    var a2 = m00 * m31 - m30 * m01;
    var a3 = m10 * m21 - m20 * m11;
    var a4 = m10 * m31 - m30 * m11;
    var a5 = m20 * m31 - m30 * m21;
    var b0 = m02 * m13 - m12 * m03;
    var b1 = m02 * m23 - m22 * m03;
    var b2 = m02 * m33 - m32 * m03;
    var b3 = m12 * m23 - m22 * m13;
    var b4 = m12 * m33 - m32 * m13;
    var b5 = m22 * m33 - m32 * m23;
 
    var divider =  (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);
    
    if(divider==0) return;
    
    var invDet = 1 / divider;

    this.m00( (m11 * b5 - m21 * b4 + m31 * b3) * invDet );
    this.m01( (-m01 * b5 + m21 * b2 - m31 * b1) * invDet );
    this.m02( (m01 * b4 - m11 * b2 + m31 * b0) * invDet );
    this.m03( (-m01 * b3 + m11 * b1 - m21 * b0) * invDet );
 
    this.m10( (-m10 * b5 + m20 * b4 - m30 * b3) * invDet );
    this.m11( (m00 * b5 - m20 * b2 + m30 * b1) * invDet );
    this.m12( (-m00 * b4 + m10 * b2 - m30 * b0) * invDet );
    this.m13( (m00 * b3 - m10 * b1 + m20 * b0) * invDet );
 
    this.m20( (m13 * a5 - m23 * a4 + m33 * a3) * invDet );
    this.m21( (-m03 * a5 + m23 * a2 - m33 * a1) * invDet );
    this.m22( (m03 * a4 - m13 * a2 + m33 * a0) * invDet );
    this.m23( (-m03 * a3 + m13 * a1 - m23 * a0) * invDet );
 
    this.m30( (-m12 * a5 + m22 * a4 - m32 * a3) * invDet );
    this.m31( (m02 * a5 - m22 * a2 + m32 * a1) * invDet );
    this.m32( (-m02 * a4 + m12 * a2 - m32 * a0) * invDet );
    this.m33( (m02 * a3 - m12 * a1 + m22 * a0) * invDet );
    
    return this;
```

### <a name="Matrix3D_getCSSMatrix3D"></a>Matrix3D::getCSSMatrix3D(t)


```javascript


_m3dSupport = this.systemHas3D();


var nn=5;

if(_m3dSupport) {
    var tStr =  "matrix3d("+this.m00().toFixed(nn)+", "+this.m01().toFixed(nn)+", "+this.m02().toFixed(nn)+", "+this.m03().toFixed(nn)+"," 
           +this.m10().toFixed(nn)+", "+this.m11().toFixed(nn)+", "+this.m12().toFixed(nn)+", "+this.m13().toFixed(nn)+","   
           +this.m20().toFixed(nn)+", "+this.m21().toFixed(nn)+", "+this.m22().toFixed(nn)+", "+this.m23().toFixed(nn)+","   
           +this.m30().toFixed(nn)+", "+this.m31().toFixed(nn)+", "+this.m32().toFixed(nn)+", "+this.m33().toFixed(nn)+")";
           
    return tStr+";-webkit-transform:"+tStr+";-ms-transform:"+tStr+";-webkit-transform-origin:0 0;-ms-transform-origin:0 0;";
} else {
    var tStr =  "matrix("+this.m00().toFixed(nn)+", "+this.m01().toFixed(nn)+", " 
           +this.m10().toFixed(nn)+", "+this.m11().toFixed(nn)+", "  
           +this.m30().toFixed(nn)+", "+this.m31().toFixed(nn)+")";
           
    return tStr+";-webkit-transform:"+tStr+";-ms-transform:"+tStr+";-webkit-transform-origin:0 0;-ms-transform-origin:0 0;";    
}

/*
var nn=10;

var tStr =  "matrix3d("+this.m00().toFixed(nn)+", "+this.m01().toFixed(nn)+", "+this.m02().toFixed(nn)+", "+this.m03().toFixed(nn)+"," 
       +this.m10().toFixed(nn)+", "+this.m11().toFixed(nn)+", "+this.m12().toFixed(nn)+", "+this.m13().toFixed(nn)+","   
       +this.m20().toFixed(nn)+", "+this.m21().toFixed(nn)+", "+this.m22().toFixed(nn)+", "+this.m23().toFixed(nn)+","   
       +this.m30().toFixed(nn)+", "+this.m31().toFixed(nn)+", "+this.m32().toFixed(nn)+", "+this.m33().toFixed(nn)+")";
       
return tStr+";-webkit-transform:"+tStr+";-webkit-transform-origin:0 0;";
*/
// "", d, 0, 0, 0,    0, 1, 0, tx,   ty, 0, 1)";
```

### <a name="Matrix3D_getRotation2D"></a>Matrix3D::getRotation2D(t)


```javascript

var i = this.m00(),
    j = this.m01(),
    r;
    
if(j>=0) {
    r = Math.acos( i );
} else {
    r = -1 * Math.acos( i );
}
return r;
```

### <a name="Matrix3D_getSVGTransform"></a>Matrix3D::getSVGTransform(t)


```javascript
// matrix(<a> <b> <c> <d> <e> <f>)

return "matrix("+this.m00().toFixed(5)+","+this.m01().toFixed(5)+","+
        this.m10().toFixed(5)+","+this.m11().toFixed(5)+","+this.m30().toFixed(5)+","+ this.m31().toFixed(5)+")";
```

### <a name="Matrix3D_intersectPlane"></a>Matrix3D::intersectPlane(startPoint, endPoint, origo)


```javascript

// project into plane normal vector
/*
var origoX = this.m30(),
    origoY = this.m31(),
    origoZ = this.m32();
*/

var np = this.normalizeVector3D({
     x : this.m20(),
     y : this.m21(),
     z : this.m22()
});

var startToPlane = {
    x : this.m30() - startPoint.x,
    y : this.m31() - startPoint.y,
    z : this.m32() - startPoint.z 
}

// normalized distance from the starting point
var totalDist =  startToPlane.x * np.x + startToPlane.y * np.y + startToPlane.z * np.z;

var v = {
    x : endPoint.x - startPoint.x,
    y : endPoint.y - startPoint.y,
    z : endPoint.z - startPoint.z
}

var partialDist = v.x * np.x + v.y * np.y + v.z * np.z;


if( ( Math.abs( totalDist ) > 0 ) && ( Math.abs( partialDist) > 0 ) ) {
    
    var t = totalDist / partialDist;

    
    if( Math.abs( t ) > 0 ) {
        
        var isect = {
            x : startPoint.x + v.x * t,
            y : startPoint.y + v.y * t,
            z : startPoint.z + v.z * t
        };
        
        return isect;
        
    }
    
}
```

### <a name="Matrix3D_inverse"></a>Matrix3D::inverse(t)


```javascript

    var m00 = this.m00(), m01 = this.m01(), m02 = this.m02(), m03 = this.m03(),
        m10 = this.m10(), m11 = this.m11(), m12 = this.m12(), m13 = this.m13(),
        m20 = this.m20(), m21 = this.m21(), m22 = this.m22(), m23 = this.m23(),
        m30 = this.m30(), m31 = this.m31(), m32 = this.m32(), m33 = this.m33();

    var a0 = m00 * m11 - m10 * m01;
    var a1 = m00 * m21 - m20 * m01;
    var a2 = m00 * m31 - m30 * m01;
    var a3 = m10 * m21 - m20 * m11;
    var a4 = m10 * m31 - m30 * m11;
    var a5 = m20 * m31 - m30 * m21;
    var b0 = m02 * m13 - m12 * m03;
    var b1 = m02 * m23 - m22 * m03;
    var b2 = m02 * m33 - m32 * m03;
    var b3 = m12 * m23 - m22 * m13;
    var b4 = m12 * m33 - m32 * m13;
    var b5 = m22 * m33 - m32 * m23;
 
    var divider =  (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);
    
    if(divider==0) return;
    
    var invDet = 1 / divider;

    this.m00( (m11 * b5 - m21 * b4 + m31 * b3) * invDet );
    this.m01( (-m01 * b5 + m21 * b2 - m31 * b1) * invDet );
    this.m02( (m01 * b4 - m11 * b2 + m31 * b0) * invDet );
    this.m03( (-m01 * b3 + m11 * b1 - m21 * b0) * invDet );
 
    this.m10( (-m10 * b5 + m20 * b4 - m30 * b3) * invDet );
    this.m11( (m00 * b5 - m20 * b2 + m30 * b1) * invDet );
    this.m12( (-m00 * b4 + m10 * b2 - m30 * b0) * invDet );
    this.m13( (m00 * b3 - m10 * b1 + m20 * b0) * invDet );
 
    this.m20( (m13 * a5 - m23 * a4 + m33 * a3) * invDet );
    this.m21( (-m03 * a5 + m23 * a2 - m33 * a1) * invDet );
    this.m22( (m03 * a4 - m13 * a2 + m33 * a0) * invDet );
    this.m23( (-m03 * a3 + m13 * a1 - m23 * a0) * invDet );
 
    this.m30( (-m12 * a5 + m22 * a4 - m32 * a3) * invDet );
    this.m31( (m02 * a5 - m22 * a2 + m32 * a1) * invDet );
    this.m32( (-m02 * a4 + m12 * a2 - m32 * a0) * invDet );
    this.m33( (m02 * a3 - m12 * a1 + m22 * a0) * invDet );
    
    return this;
```

### <a name="Matrix3D_isValidMatrix"></a>Matrix3D::isValidMatrix()


```javascript
var mm = this._data;

if(isNaN(mm.m00)) return false;
if(isNaN(mm.m01)) return false;
if(isNaN(mm.m02)) return false;
if(isNaN(mm.m03)) return false;

if(isNaN(mm.m10)) return false;
if(isNaN(mm.m11)) return false;
if(isNaN(mm.m12)) return false;
if(isNaN(mm.m13)) return false;

if(isNaN(mm.m20)) return false;
if(isNaN(mm.m21)) return false;
if(isNaN(mm.m22)) return false;
if(isNaN(mm.m23)) return false;

if(isNaN(mm.m30)) return false;
if(isNaN(mm.m31)) return false;
if(isNaN(mm.m32)) return false;
if(isNaN(mm.m33)) return false;

return true;
```

### <a name="Matrix3D_log"></a>Matrix3D::log(t)


```javascript

        
console.log(this._data);
```

### <a name="Matrix3D_matMul"></a>Matrix3D::matMul(other)


```javascript
var m00 = this.m00(), m01 = this.m01(), m02 = this.m02(), m03 = this.m03(),
    m10 = this.m10(), m11 = this.m11(), m12 = this.m12(), m13 = this.m13(),
    m20 = this.m20(), m21 = this.m21(), m22 = this.m22(), m23 = this.m23(),
    m30 = this.m30(), m31 = this.m31(), m32 = this.m32(), m33 = this.m33();
    
var t00 = other.m00(), t01 = other.m01(), t02 = other.m02(), t03 = other.m03(),
    t10 = other.m10(), t11 = other.m11(), t12 = other.m12(), t13 = other.m13(),
    t20 = other.m20(), t21 = other.m21(), t22 = other.m22(), t23 = other.m23(),
    t30 = other.m30(), t31 = other.m31(), t32 = other.m32(), t33 = other.m33();    
    

this.updateFromParams(     m00 * t00 + m10 * t01 + m20 * t02 + m30 * t03,
    m01 * t00 + m11 * t01 + m21 * t02 + m31 * t03,
    m02 * t00 + m12 * t01 + m22 * t02 + m32 * t03,
    m03 * t00 + m13 * t01 + m23 * t02 + m33 * t03,
 
    m00 * t10 + m10 * t11 + m20 * t12 + m30 * t13,
    m01 * t10 + m11 * t11 + m21 * t12 + m31 * t13,
    m02 * t10 + m12 * t11 + m22 * t12 + m32 * t13,
    m03 * t10 + m13 * t11 + m23 * t12 + m33 * t13,
 
    m00 * t20 + m10 * t21 + m20 * t22 + m30 * t23,
    m01 * t20 + m11 * t21 + m21 * t22 + m31 * t23,
    m02 * t20 + m12 * t21 + m22 * t22 + m32 * t23,
    m03 * t20 + m13 * t21 + m23 * t22 + m33 * t23,
 
    m00 * t30 + m10 * t31 + m20 * t32 + m30 * t33,
    m01 * t30 + m11 * t31 + m21 * t32 + m31 * t33,
    m02 * t30 + m12 * t31 + m22 * t32 + m32 * t33,
    m03 * t30 + m13 * t31 + m23 * t32 + m33 * t33 );
    
return this;
```

### <a name="Matrix3D_normalize"></a>Matrix3D::normalize(t)


```javascript

this.copyFrom( new Matrix3D() );
```

### <a name="Matrix3D_normalizeVector3D"></a>Matrix3D::normalizeVector3D(v)


```javascript

var len = Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );

if(len == 0 || isNaN(len)) return {
    x : 1,
    y : 0,
    z : 0
};

return {
    x : v.x / len,
    y : v.y / len,
    z : v.z / len
};

```

### <a name="Matrix3D_projectVector"></a>Matrix3D::projectVector(v)


```javascript
var m00 = this.m00(), m01 = this.m01(), m02 = this.m02(), m03 = this.m03(),
    m10 = this.m10(), m11 = this.m11(), m12 = this.m12(), m13 = this.m13(),
    m20 = this.m20(), m21 = this.m21(), m22 = this.m22(), m23 = this.m23(),
    m30 = this.m30(), m31 = this.m31(), m32 = this.m32(), m33 = this.m33();
        
return {    
   x : m00 * v.x + m10 * v.y + m20 * v.z + m30 * v.w,
   y:  m01 * v.x + m11 * v.y + m21 * v.z + m31 * v.w,
   z:  m02 * v.x + m12 * v.y + m22 * v.z + m32 * v.w,
   w:  m03 * v.x + m13 * v.y + m23 * v.z + m33 * v.w
};
```

### <a name="Matrix3D_rotate"></a>Matrix3D::rotate(axis, radAngle)


```javascript
  
var axis = this.normalizeVector3D( axis );
var ax = axis.x,
    ay = axis.y,
    az = axis.z;
    
var cosA = Math.cos(radAngle);
var sinA = Math.sin(radAngle);

this.updateFromParams(
      cosA + ax * ax * (1 - cosA), ay * ax * (1 - cosA) + az * sinA, az * ax * (1 - cosA) - ay * sinA, 0,
      ay * ax * (1 - cosA) - az * sinA, cosA + ay * ay * (1 - cosA), az * ay * (1 - cosA) + ax * sinA, 0,
      az * ax * (1 - cosA) + ay * sinA, ay * az * (1 - cosA) - ax * sinA, cosA + az * az * (1 - cosA), 0,
      0, 0, 0, 1
    );
    
if(radAngle==0) {
    console.log("*** angle is zero****");
    console.log(this._data);
}
    
/*
  def rotate(axis: Vec3, angle: Float) = {
    import axis.{x => ax, y => ay, z => az}
    val cosA = math.cos(angle).toFloat
    val sinA = math.sin(angle).toFloat
    new Mat4(
      cosA + ax * ax * (1 - cosA), ay * ax * (1 - cosA) + az * sinA, az * ax * (1 - cosA) - ay * sinA, 0,
      ay * ax * (1 - cosA) - az * sinA, cosA + ay * ay * (1 - cosA), az * ay * (1 - cosA) + ax * sinA, 0,
      az * ax * (1 - cosA) + ay * sinA, ay * az * (1 - cosA) - ax * sinA, cosA + az * az * (1 - cosA), 0,
      0, 0, 0, 1
    )
  }
}
*/
```

### <a name="Matrix3D_scale"></a>Matrix3D::scale(s)


```javascript

this.updateFromParams(
    s, 0, 0, 0,
    0, s, 0, 0,
    0, 0, s, 0,
    0, 0, 0, 1
  );
  
return this;
```

### <a name="Matrix3D_screenProjection"></a>Matrix3D::screenProjection(worldVector, camera)


```javascript

var vector = this.projectVector(worldVector);

// if perspective projection
if(camera.d) {
    //console.log("--- wrld and scr vects");
    //console.log(worldVector);
    //console.log(vector);
    //console.log(camera);
    var dist = camera.d - vector.z,
        x = vector.x - (camera.cx || 500),
        y = vector.y - (camera.cy || 500);
    if(dist>0 ) {
        // console.log("Scale factor ", camera.d / dist);
        return {
            x : camera.cx + x * camera.d / dist,
            y : camera.cy + y * camera.d / dist
        }
    }    
} else {
    x = vector.x;// - (camera.cx || 500),
    y = vector.y;// - (camera.cy || 500);    
    
    return {
        x : x,
        y : y
    }    
}



```

### <a name="Matrix3D_setDomContext"></a>Matrix3D::setDomContext(ctx)


```javascript

// projection maybe could be better...
ctx.setTransform(this.m00(),this.m01(),this.m10(), this.m11(), this.m30(), this.m31());
```

### <a name="Matrix3D_systemHas3D"></a>Matrix3D::systemHas3D(t)


```javascript

if(typeof(_m3dSupport) != "undefined") return _m3dSupport;

if(typeof(window) == "undefined") return false;

if (!window.getComputedStyle) {
    return false;
}

var el = document.createElement('p'), 
    has3d,
    transforms = {
        'webkitTransform':'-webkit-transform',
        'OTransform':'-o-transform',
        'msTransform':'-ms-transform',
        'MozTransform':'-moz-transform',
        'transform':'transform'
    };

// Add it to the body to get the computed style.
document.body.insertBefore(el, null);

for (var t in transforms) {
    if (el.style[t] !== undefined) {
        el.style[t] = "translate3d(1px,1px,1px)";
        has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
    }
}

document.body.removeChild(el);

return (has3d !== undefined && has3d.length > 0 && has3d !== "none");

```

### <a name="Matrix3D_translate"></a>Matrix3D::translate(v)


```javascript
this.updateFromParams(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    v.x, v.y, v.z, 1
  );
```

### <a name="Matrix3D_updateFromParams"></a>Matrix3D::updateFromParams(t)


```javascript

var d = this._data;
var i=0;

d.m00 = arguments[i++];
d.m01 = arguments[i++];
d.m02 = arguments[i++];
d.m03 = arguments[i++];

d.m10 = arguments[i++];
d.m11 = arguments[i++];
d.m12 = arguments[i++];
d.m13 = arguments[i++];

d.m20 = arguments[i++];
d.m21 = arguments[i++];
d.m22 = arguments[i++];
d.m23 = arguments[i++];

d.m30 = arguments[i++];
d.m31 = arguments[i++];
d.m32 = arguments[i++];
d.m33 = arguments[i++];




```



   
    
## trait matrixFn

The class has following internal singleton variables:
        
        
### matrixFn::constructor( t )

```javascript

this._data = {
    m00 : 1, m01 : 0, m02 : 0, m03:0,
    m10 : 0, m11 : 1, m12 : 0, m13:0,
    m20 : 0, m21 : 0, m22 : 1, m23:0,
    m30 : 0, m31 : 0, m32 : 0, m33:1
};
```
        
### <a name="matrixFn_m00"></a>matrixFn::m00(t)


```javascript

if(typeof(t)!="undefined") {
    if(this._data.m00 != t) this._dirty = true;
    this._data.m00 = t;
    return this;
}
return this._data.m00;
```

### <a name="matrixFn_m01"></a>matrixFn::m01(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m01 != t) this._dirty = true;
    this._data.m01 = t;
    return this;
}
return this._data.m01;
```

### <a name="matrixFn_m02"></a>matrixFn::m02(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m02 != t) this._dirty = true;
    this._data.m02 = t;
    return this;
}
return this._data.m02;
```

### <a name="matrixFn_m03"></a>matrixFn::m03(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m03 != t) this._dirty = true;
    this._data.m03 = t;
    return this;
}
return this._data.m03;
```

### <a name="matrixFn_m10"></a>matrixFn::m10(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m10 != t) this._dirty = true;
    this._data.m10 = t;
    return this;
}
return this._data.m10;
```

### <a name="matrixFn_m11"></a>matrixFn::m11(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m11 != t) this._dirty = true;
    this._data.m11 = t;
    return this;
}
return this._data.m11;
```

### <a name="matrixFn_m12"></a>matrixFn::m12(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m12 != t) this._dirty = true;
    this._data.m12 = t;
    return this;
}
return this._data.m12;
```

### <a name="matrixFn_m13"></a>matrixFn::m13(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m13 != t) this._dirty = true;
    this._data.m13 = t;
    return this;
}
return this._data.m13;
```

### <a name="matrixFn_m20"></a>matrixFn::m20(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m20 != t) this._dirty = true;
    this._data.m20 = t;
    return this;
}
return this._data.m20;
```

### <a name="matrixFn_m21"></a>matrixFn::m21(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m21 != t) this._dirty = true;
    this._data.m21 = t;
    return this;
}
return this._data.m21;
```

### <a name="matrixFn_m22"></a>matrixFn::m22(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m22 != t) this._dirty = true;
    this._data.m22 = t;
    return this;
}
return this._data.m22;
```

### <a name="matrixFn_m23"></a>matrixFn::m23(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m23 != t) this._dirty = true;
    this._data.m23 = t;
    return this;
}
return this._data.m23;
```

### <a name="matrixFn_m30"></a>matrixFn::m30(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m30 != t) this._dirty = true;
    this._data.m30 = t;
    return this;
}
return this._data.m30;
```

### <a name="matrixFn_m31"></a>matrixFn::m31(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m31 != t) this._dirty = true;
    this._data.m31 = t;
    return this;
}
return this._data.m31;
```

### <a name="matrixFn_m32"></a>matrixFn::m32(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m32 != t) this._dirty = true;
    this._data.m32 = t;
    return this;
}
return this._data.m32;
```

### <a name="matrixFn_m33"></a>matrixFn::m33(t)


```javascript
if(typeof(t)!="undefined") {
    if(this._data.m33 != t) this._dirty = true;
    this._data.m33 = t;
    return this;
}
return this._data.m33;
```


    
    


   
      
    



      
    
      
            
# Class drawLine


The class has following internal singleton variables:
        
        
### <a name="drawLine_adjustDivSize"></a>drawLine::adjustDivSize(t)


```javascript


var d = this.myDiv;
var len = this.length();

d._dom.style.width = len + "px";
d._dom.style.height = (this.options.weight || this.weight || 3)+"px";
```

### <a name="drawLine_adjustStyleProps"></a>drawLine::adjustStyleProps(t)


```javascript

// this.myDiv

var vLen = this.length();

if(! ( vLen > 0 ) ) return;

var dx = this.ex - this.sx,
    dy = -1*( this.ey - this.sy );
    
var cosA = dx / vLen,
    sinA = dy / vLen;
    
var tx = this.sx,
    ty = this.sy;

var mat = cosA.toFixed(5)+","+(-1*sinA).toFixed(5)+",";
mat += sinA.toFixed(5)+","+(cosA).toFixed(5)+","+tx.toFixed(5)+","+ty.toFixed(5);

var matStr = "transform-origin:0 0;-webkit-transform-origin:0 0; -ms-transform-origin: 0 0;-ms-transform: matrix("+mat+"); ";
matStr += "-webkit-transform: matrix("+mat+"); ";  /* Chrome, Safari, Opera */
matStr += "transform: matrix("+mat+");";

var bgColor = this.options.bgColor || "blue";

var styleStr = matStr+";background-color:"+bgColor+";height:"+this.weight+"px;position:absolute;left:0px;top:0px;width:"+vLen+"px;";

this.myDiv.attr({
    style : styleStr
});


    

    
    

```

### <a name="drawLine_attr"></a>drawLine::attr(v)


```javascript
return this.myDiv.attr(v);
```

### <a name="drawLine_getElem"></a>drawLine::getElem(t)


```javascript

return this.myDiv;
```

### <a name="drawLine_hide"></a>drawLine::hide(t)


```javascript
this.myDiv.hide();
```

### drawLine::constructor( sx, sy, ex, ey, options )

```javascript


this.sx = sx;
this.sy = sy;
this.ex = ex;
this.ey = ey;

var myDiv = _e("div");

myDiv.absolute().x(0).y(0);

this.myDiv = myDiv;

this.options = options || {};
this.weight = options.weight || 3;

this.adjustDivSize();
this.adjustStyleProps();


```
        
### <a name="drawLine_length"></a>drawLine::length(t)


```javascript

var dx = this.ex - this.sx,
    dy = this.ey - this.sy;
    
return Math.sqrt( dx*dx + dy*dy );
```

### <a name="drawLine_moveTo"></a>drawLine::moveTo(sx, sy, ex, ey)


```javascript
this.sx = sx;
this.sy = sy;
this.ex = ex;
this.ey = ey;

this.adjustDivSize();
this.adjustStyleProps();

```

### <a name="drawLine_show"></a>drawLine::show(t)


```javascript

this.myDiv.show();
```



   


   



      
    
      
            
# Class surface


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### <a name="surface_frameClear"></a>surface::frameClear(t)


```javascript

```

### <a name="surface_getDom"></a>surface::getDom(t)


```javascript
return this._dom;
```

### <a name="surface_getHeight"></a>surface::getHeight(t)


```javascript
return this._height;
```

### <a name="surface_getWidth"></a>surface::getWidth(t)


```javascript
return this._width;
```

### <a name="surface_guid"></a>surface::guid(t)


```javascript
return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
```

### <a name="surface_id"></a>surface::id(t)


```javascript

if(!this._id) {
    this._id = "sface"+this.guid();
}
return this._id;
```

### <a name="surface_registerRenderer"></a>surface::registerRenderer(className, initFn, refreshFn, removeFn)


```javascript

console.log("*** register registerRenderer for ", className);
if(this.isObject(initFn) && !this.isFunction(initFn)) {
    console.log("*** setting the renderer to ", initFn);
    this._renderFns[className] = initFn;
    return;
}

this._renderFns[className] = {
    start : initFn,
    refresh : refreshFn,
    end : removeFn
};
```

### <a name="surface_removeObject"></a>surface::removeObject(obj, display)


```javascript
var rt = obj.renderClass();

var _renderFns = this._renderFns;

if(_renderFns[rt]) {
    
    var fnData = _renderFns[rt];
    obj.setRenderScope( this.id() );
    var rendData = obj.getRenderData(this.id());
    
    fnData.end( obj, display, rendData  );
    rendData.state=3;

    obj.setRenderScope( null );
    
    obj.removeFromDisplay( display.id(), display );

} 
```

### <a name="surface_render"></a>surface::render(obj, display)


```javascript

var rt = obj.renderClass();

var _renderFns = this._renderFns;

if(_renderFns[rt]) {
    var fnData = _renderFns[rt];
    
    obj.setRenderScope( this.id() );
    
    var rendData = obj.getRenderData(this.id());
    
    if(typeof( rendData.state )=="undefined") rendData.state = 1;
    
    if(obj.askToRemove(this.id())) {
        
        fnData.end( obj, display, rendData  );
        rendData.state=3;
        obj.askToRemove(this.id(), false);
    }

    if(rendData.state==1) {
        fnData.start( obj, display, rendData );
        obj.projectToCamera( display.getCamera() );
        fnData.refresh( obj, display, rendData  );
    }
    
    if(rendData.state==2) {
        obj.projectToCamera( display.getCamera() );
        fnData.refresh( obj, display, rendData  );
    }
  
    
    obj.setRenderScope( null );

} 
```

### <a name="surface_restartObject"></a>surface::restartObject(obj, display, fromClass)


```javascript

// The object may have old render class...
var rt = fromClass || obj.renderClass();
var _renderFns = this._renderFns;

if(_renderFns[rt]) {
    
    var fnData = _renderFns[rt];
    obj.setRenderScope( this.id() );
    var rendData = obj.getRenderData(this.id());
    
    var useG;
    if(rendData.viewG) {
        useG = rendData.viewG;
    }
    fnData.end( obj, display, rendData  );
    rendData.state=1;
    //fnData.start( obj, display, rendData, useG );
    //fnData.refresh( obj, display, rendData, useG );
    obj.setRenderScope( null );


} 
```

### <a name="surface_standardHandleRenderers"></a>surface::standardHandleRenderers(forClass)


```javascript
this.registerRenderer( forClass, function(obj, display, data) {
    
    if(!obj.areHandlesVisible()) {
        return;
    }
    
    var camera = display.getCamera(),
        main = _e(display.getSurface().getDom());
        
    if(!data.rightBottom) {
        
        var rotPath = "M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z";
        var icon = drawIconbox( 50,50, 30, rotPath);
        
        data.rotIcon = icon;
       
        data.topBar = main.div("handle");
        data.leftBar = main.div("handle");
        // data.rightBar = main.div("handle");
        data.bottomBar = main.div("handle");
        data.rightBottom = main.div("handle");
        data.rightMiddle = main.div("handle");
        data.bottomMiddle = main.div("handle");
        data.rightTop = main.div("handle");
        data.rotCenter = main.div("handle");
        
        data.rightBar = drawLine(100,100,500,100, {bgColor:"red", weight:4});
        main.add( data.rightBar.getElem() );  
        data.rightBar.getElem().addClass("handle");
        
        // obj.rotatableFor( data.rightTop );
        obj.rotatableFor( data.rotIcon, display );
        
        obj.resizeableWidthFor( data.rightMiddle );
        obj.resizeableWidthFor( data.rightBar.getElem() );
        obj.resizeableHeightFor( data.bottomMiddle );
        obj.resizeableHeightFor( data.bottomBar );
        obj.resizeableFor( data.rightBottom );
        obj.handleRotationCenter( data.rotCenter );
        
        data.crossLine = drawLine(100,100,500,100, {bgColor:"red", weight:10});
        main.add( data.crossLine.getElem() );    
        obj.rotatableFor( data.crossLine.getElem(), display );
        
        
        
        main.add( icon.getElem() );
        
        icon.getElem().addClass("glow");
        
        if(obj.parent()) {
            var itemList = obj.parent();
            itemList.on("remove", function() {
                if(itemList._removedItem==obj) {
                    data.rotCenter.hide();
                    
                    data.topBar.hide();
                    data.leftBar.hide();
                    data.rightBar.hide();
                    data.bottomBar.hide();
                    
                    data.rightBottom.hide();
                    data.rightMiddle.hide();
                    data.bottomMiddle.hide();
                    data.rightTop.hide();
                    data.crossLine.hide();
                    
                    data.rotIcon.hide();                    
                }
            })
        }
        
    }
}, function(obj, display, data) {
    

    if(obj.areHandlesVisible()) {
        
        if(!data._handlesSet) {
            data.rotCenter.show();
            
            data.topBar.show();
            data.leftBar.show();
            data.rightBar.show();
            data.bottomBar.show();
            
            data.rightBottom.show();
            data.rightMiddle.show();
            data.bottomMiddle.show();
            data.rightTop.show();
            data.crossLine.show();
            
            data.rotIcon.show();            
        }
        
        data._handlesSet = true;
    } else {
        if(data._handlesSet) {
            data.rotCenter.hide();
            
            data.topBar.hide();
            data.leftBar.hide();
            data.rightBar.hide();
            data.bottomBar.hide();
            
            data.rightBottom.hide();
            data.rightMiddle.hide();
            data.bottomMiddle.hide();
            data.rightTop.hide();
            data.crossLine.hide();
            
            data.rotIcon.hide();            
        }
        data._handlesSet = false;
        return;
    }   
    
    // console.log("***** Refreshing the surface 4 ");
    var camera = display.getCamera(),
        surface = display.getSurface(),
        main = _e( display.getSurface().getDom() ),
        perspective = 1000;
        
    var docWidth = surface.getWidth(),
        docHeight = surface.getHeight();    

    data.rightBottom.show();
    data.rightTop.show();
    var rendM = obj.getRenderMatrix().createCopy();
    var move = Matrix3D();
    var a = rendM.m00();
        b = rendM.m10();
    var xScale = Math.sqrt( a*a + b*b );
    if(xScale===0) return;
    
    // data.crossLine
    data.crossLine.show();
    rendM = obj.getRenderMatrix().createCopy();
    var start = rendM.projectVector({ x:obj.w()/2, y:0, z:0, w:1}),
        end = rendM.projectVector({ x:obj.w()/2, y:obj.h()*(-0.3), z:0, w:1});

    // data.crossLine.moveTo(start.x,start.y, end.x, end.y);
    
    rendM = obj.getRenderMatrix().createCopy();
    
    var rightTop = rendM.screenProjection({
        x: obj.w(), y : 0, z:0, w:1
    }, {
        d : perspective,
        cx : docWidth/2,
        cy : docHeight/2
    });      
    var rightBottom = rendM.screenProjection({
        x: obj.w(), y : obj.h(), z:0, w:1
    }, {
        d : perspective,
        cx : docWidth/2,
        cy : docHeight/2
    }); 
    var startV = rendM.screenProjection({
        x: obj.w()/2, y : 0, z:0, w:1
    }, {
        d : perspective,
        cx : docWidth/2,
        cy : docHeight/2
    });    
    var endV = rendM.screenProjection({
        x: obj.w()/2, y : obj.h()*(-0.3), z:0, w:1
    }, {
        d : perspective,
        cx : docWidth/2,
        cy : docHeight/2
    });    
    data.crossLine.moveTo(startV.x,startV.y, endV.x, endV.y);
    
    var handleSize = 20 * ( 1/ xScale );
    move.translate({ x: obj.w(), y : obj.h(), z:0 });
    rendM.matMul( move );
    data.rightBottom.attr({
        "style" : "transform-origin: 0 0;width:"+handleSize+"px;height:"+handleSize+"px;transform:"+rendM.getCSSMatrix3D()
    });     
    
    // new icon rend.
    rendM = obj.getRenderMatrix().createCopy();
    move = Matrix3D();
    move.translate({ x: obj.w(), y : 0, z:0 });
    rendM.matMul( move );
    data.rotIcon.moveTo( rendM.m30(), rendM.m31() );
    
    rendM = obj.getRenderMatrix().createCopy();
    var sv = rendM.screenProjection({
        x: obj.w(), y : 0, z:0, w:1
    }, {
        d : perspective,
        cx : docWidth/2,
        cy : docHeight/2
    });
    data.rotIcon.moveTo( sv.x, sv.y, 30 );


    
    rendM = obj.getRenderMatrix().createCopy();
    move = Matrix3D();
    move.translate({ x: obj.w(), y : obj.h()/2 -handleSize*0.5, z:0 });
    rendM.matMul( move );
    data.rightMiddle.attr({
        "style" : "transform-origin: 0 0;width:"+handleSize+"px;height:"+handleSize+"px;transform:"+rendM.getCSSMatrix3D()
    }); 
    
    rendM = obj.getRenderMatrix().createCopy();
    move = Matrix3D();
    move.translate({ x: obj.w()*obj.ri() - handleSize*0.5, y : obj.h()*obj.rj() - handleSize*0.5, z:0 });
    rendM.matMul( move );
    data.rotCenter.attr({
        "style" : "border-radius:30px;background-color:red;transform-origin: 0 0;width:"+handleSize+"px;height:"+handleSize+"px;transform:"+rendM.getCSSMatrix3D()
    });      

    rendM = obj.getRenderMatrix().createCopy();
    move = Matrix3D();
    move.translate({ x: obj.w()/2 - handleSize*0.5, y : obj.h(), z:0 });
    rendM.matMul( move );
    data.bottomMiddle.attr({
        "style" : "transform-origin: 0 0;width:"+handleSize+"px;height:"+handleSize+"px;transform:"+rendM.getCSSMatrix3D()
    });   
    
    rendM = obj.getRenderMatrix().createCopy();
    data.topBar.attr({
        "style" : "background:none;border-color:red;border-width:4px; border-style:solid; transform-origin: 0 0;width:"+obj.w()+"px;height:"+handleSize*0.2+"px;transform:"+rendM.getCSSMatrix3D()
    });    
    
    rendM = obj.getRenderMatrix().createCopy();
    data.leftBar.attr({
        "style" : "background:none;border-color:red;border-width:4px; border-style:solid; transform-origin: 0 0;width:"+handleSize*0.2+"px;height:"+obj.h()+"px;transform:"+rendM.getCSSMatrix3D()
    });     
    
    rendM = obj.getRenderMatrix().createCopy();
    move = Matrix3D();
    move.translate({ x: 0, y : obj.h(), z:0 });
    rendM.matMul( move );    
    data.bottomBar.attr({
        "style" : "background:none;border-color:red;border-width:4px; border-style:solid; transform-origin: 0 0;width:"+obj.w()+"px;height:"+handleSize*0.2+"px;transform:"+rendM.getCSSMatrix3D()
    });     
    
    data.rightBar.moveTo(rightTop.x,rightTop.y, rightBottom.x, rightBottom.y);

    
}, function(obj, display, data) {
    
    var camera = display.getCamera(),
        main = _e( display.getSurface().getDom() );
        
    if(data.rightBottom) {
        data.rotCenter.hide();
        
        data.topBar.hide();
        data.leftBar.hide();
        data.rightBar.hide();
        data.bottomBar.hide();
        
        data.rightBottom.hide();
        data.rightMiddle.hide();
        data.bottomMiddle.hide();
        data.rightTop.hide();
        data.crossLine.hide();
        
        data.rotIcon.hide();
    }
});
```

### <a name="surface_startObject"></a>surface::startObject(obj, display, nothing)


```javascript
var rt = obj.renderClass();

var _renderFns = this._renderFns;

if(_renderFns[rt]) {
    var fnData = _renderFns[rt];
    
    obj.setRenderScope( this.id() );
    var rendData = obj.getRenderData(this.id());
    rendData.state = 1;

    obj.setRenderScope( null );

} 
```

### <a name="surface_svgGroupHandles"></a>surface::svgGroupHandles(forClass)


```javascript
/*sface5.registerRenderer( "pathpoint", function(obj, display, data) {

        var surface = display.getSurface();
        if(!data.viewObj) {
            var svg = surface.getSvg();
            var icon = svg.circle();
            icon.attr({
                "fill" : "cyan",
                cx : 0,
                cy : 0,
                r : 56
            })

            data.viewObj = icon;
            obj.draggableFor( data.viewObj, display );
        }
    }, 
    function(obj, display, data) {
        
        var p = obj.parent().parent();
        if(!p.areHandlesVisible() && !obj.areHandlesVisible()) {
            data.viewObj.attr({
                r: 0
            });
            return;
        } else {

        }
        
        var surface = display.getSurface();
        var bgStyle = "";
        var rendM = obj.getRenderMatrix().createCopy();
        var move = Matrix3D();
        var a = rendM.m00();
            b = rendM.m10();
        var xScale = Math.sqrt( a*a + b*b );        
        
        var aList = {
            transform : obj.getRenderMatrix().getSVGTransform()
        };
        aList["r"] = 6*(1/xScale);


        data.viewObj.attr(aList); 
  
        
    }, function(obj, display, data) {
        data.viewObj.remove();
    });  
*/    
this.registerRenderer( forClass, function(obj, display, data) {
    

    var surface = display.getSurface();
    if(!data.rotIcon) {
        var svg = surface.getSvg();

        var lineAttr = {
            "stroke" : "blue", 
            "stroke-width" : 2
        };
        var handleAttr = {
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            class : "svghandle",
            r : 56
        };
        // "stroke-dasharray":"2,2"
        data.rotLine = svg.line("handle", lineAttr);
        
        
        data.rotIcon = svg.circle("", handleAttr);

        obj.groupRotationHandler( data.rotIcon, display );

        
        data.topLine = svg.line("", lineAttr);
        data.rightLine = svg.line("", lineAttr);
        data.bottomLine = svg.line("", lineAttr);
        data.leftLine = svg.line("", lineAttr);
        
        obj.resizeableHeightFor( data.bottomLine );
        
        var resizeIcon = svg.circle();
        resizeIcon.attr({
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            r : 56
        })
        data.resizeIcon = resizeIcon;
        obj.groupResizeHandler( data.resizeIcon, display );  

        var resizeIconRt = svg.circle();
        resizeIconRt.attr({
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            r : 56
        })        
        data.resizeIconRt = resizeIconRt;
        obj.groupResizeHandler( data.resizeIconRt, display, {
            i : 0,
            j : 1
        } );   
        
        var resizeIconLt = svg.circle();
        resizeIconLt.attr({
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            r : 56
        })        
        data.resizeIconLt = resizeIconLt;
        obj.groupResizeHandler( data.resizeIconLt, display, {
            i : 1,
            j : 1
        } ); 
        
        var resizeIconLb = svg.circle();
        resizeIconLb.attr({
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            r : 56
        })        
        data.resizeIconLb = resizeIconLb;
        obj.groupResizeHandler( data.resizeIconLb, display, {
            i : 1,
            j : 0
        } );         
 
        data.resizeBottom = svg.circle("", handleAttr);
        obj.resizeableHeightFor( data.resizeBottom, display );
    
        data.resizeLeft = svg.circle("", handleAttr);
        obj.resizeableWidthFor( data.resizeLeft, display, { inverse : true} );
        
        data.resizeRight = svg.circle("", handleAttr);
        obj.resizeableWidthFor( data.resizeRight, display );        
        if(obj.parent()) {
            var itemList = obj.parent();
            itemList.on("remove", function() {
                if(itemList._removedItem==obj) {
                    data.rotIcon.remove();
                    data.rotLine.remove();
                    data.resizeIcon.remove();
                    data.topLine.remove();
                    data.rightLine.remove();
                    data.bottomLine.remove();
                    data.leftLine.remove();
                    data.resizeBottom.remove();
                    data.resizeLeft.remove();
                    data.resizeRight.remove();           
                    data.resizeIconRt.remove();
                    data.resizeIconLt.remove();
                    data.resizeIconLb.remove();
                }
            })
        }        
        
    }

}, function(obj, display, data) {
    

    if(true) {
        
        if(!data._handlesSet) {
            data.rotIcon.show();
            data.rotLine.show();
            data.topLine.show();
            data.rightLine.show();
            data.bottomLine.show();
            data.leftLine.show();
            data.resizeIcon.show();
            data.resizeBottom.show();
            data.resizeLeft.show();
            data.resizeRight.show();
            data.resizeIconRt.show();
            data.resizeIconLt.show();
            data.resizeIconLb.show();
        }
        
        data._handlesSet = true;
    } else {
        if(data._handlesSet) {
            data.rotIcon.hide();
            data.rotLine.hide();
            data.resizeIcon.hide();
            data.topLine.hide();
            data.rightLine.hide();
            data.bottomLine.hide();
            data.leftLine.hide();
            data.resizeBottom.hide();
            data.resizeLeft.hide();
            data.resizeRight.hide();   
            data.resizeIconRt.hide();
            data.resizeIconLt.hide();
            data.resizeIconLb.hide();
        }
        data._handlesSet = false;
        return;
    }   
    
    // console.log("***** Refreshing the surface 4 ");
    var camera = display.getCamera(),
        surface = display.getSurface(),
        main = _e( display.getSurface().getDom() ),
        perspective = 1000;
        
    var docWidth = surface.getWidth(),
        docHeight = surface.getHeight();    

    // OK, then...
    var rendM = obj.getViewMatrix(display.getCamera()).createCopy();
    var move = Matrix3D();
    var a = rendM.m00();
        b = rendM.m10();
    var xScale = Math.sqrt( a*a + b*b );
    if(xScale===0) return;
    
    rendM = obj.getViewMatrix(display.getCamera()).createCopy();
    var getPoint = function(x,y) {
        return rendM.screenProjection({
            x: x, y : y, z:0, w:1
        }, {
            d : perspective,
            cx : docWidth/2,
            cy : docHeight/2
        });         
    }
    
    var rightTopMiddle = getPoint(obj.w()/2, 0),
        rightTopMiddleUp = getPoint(obj.w()/2, -20 / xScale),
        leftTop = getPoint( 0, 0 ),
        rightTop = getPoint( obj.w(), 0),
        rightBottom = getPoint(obj.w(),obj.h()),
        leftBottom = getPoint(0, obj.h()),
        bottomMiddle = getPoint(obj.w()/2, obj.h()),
        rightMiddle = getPoint(obj.w(),obj.h()/2),
        leftMiddle = getPoint(0, obj.h()/2);

    data.rotIcon.attr({
        r : 6,
        cx : rightTopMiddleUp.x,
        cy : rightTopMiddleUp.y
    });
    data.resizeIcon.attr({
        r : 6,
        cx : rightBottom.x,
        cy : rightBottom.y
    });
    data.resizeIconRt.attr({
        r : 6,
        cx : rightTop.x,
        cy : rightTop.y
    });   
    data.resizeIconLt.attr({
        r : 6,
        cx : leftTop.x,
        cy : leftTop.y
    }); 
    data.resizeIconLb.attr({
        r : 6,
        cx : leftBottom.x,
        cy : leftBottom.y
    });     
    data.resizeBottom.attr({
        r : 6,
        cx : bottomMiddle.x,
        cy : bottomMiddle.y
    });    
    data.resizeLeft.attr({
        r : 6,
        cx : leftMiddle.x,
        cy : leftMiddle.y
    });     
    data.resizeRight.attr({
        r : 6,
        cx : rightMiddle.x,
        cy : rightMiddle.y
    });     
    data.rotLine.attr({
        x1 : rightTopMiddle.x,
        y1 : rightTopMiddle.y,
        x2 : rightTopMiddleUp.x,
        y2 : rightTopMiddleUp.y
    });
    
    
    data.topLine.attr({
        x1 : leftTop.x,
        y1 : leftTop.y,
        x2 : rightTop.x,
        y2 : rightTop.y
    });
    data.rightLine.attr({
        x1 : rightTop.x,
        y1 : rightTop.y,
        x2 : rightBottom.x,
        y2 : rightBottom.y
    });
    data.bottomLine.attr({
        x1 : leftBottom.x,
        y1 : leftBottom.y,
        x2 : rightBottom.x,
        y2 : rightBottom.y
    });
    data.leftLine.attr({
        x1 : leftTop.x,
        y1 : leftTop.y,
        x2 : leftBottom.x,
        y2 : leftBottom.y
    });    
    
    

}, function(obj, display, data) {
    if(!data.rotIcon) return;
    data.rotIcon.hide();
    data.rotLine.hide();
    data.resizeIcon.hide();
    data.topLine.hide();
    data.rightLine.hide();
    data.bottomLine.hide();
    data.leftLine.hide();
    data.resizeBottom.hide();
    data.resizeLeft.hide();
    data.resizeRight.hide();   
    data.resizeIconRt.hide();
    data.resizeIconLt.hide();
    data.resizeIconLb.hide();
    
    data._handlesSet = false;

});
```

### <a name="surface_svgHandleRenderers"></a>surface::svgHandleRenderers(forClass)


```javascript
/*sface5.registerRenderer( "pathpoint", function(obj, display, data) {

        var surface = display.getSurface();
        if(!data.viewObj) {
            var svg = surface.getSvg();
            var icon = svg.circle();
            icon.attr({
                "fill" : "cyan",
                cx : 0,
                cy : 0,
                r : 56
            })

            data.viewObj = icon;
            obj.draggableFor( data.viewObj, display );
        }
    }, 
    function(obj, display, data) {
        
        var p = obj.parent().parent();
        if(!p.areHandlesVisible() && !obj.areHandlesVisible()) {
            data.viewObj.attr({
                r: 0
            });
            return;
        } else {

        }
        
        var surface = display.getSurface();
        var bgStyle = "";
        var rendM = obj.getRenderMatrix().createCopy();
        var move = Matrix3D();
        var a = rendM.m00();
            b = rendM.m10();
        var xScale = Math.sqrt( a*a + b*b );        
        
        var aList = {
            transform : obj.getRenderMatrix().getSVGTransform()
        };
        aList["r"] = 6*(1/xScale);


        data.viewObj.attr(aList); 
  
        
    }, function(obj, display, data) {
        data.viewObj.remove();
    });  
*/    
this.registerRenderer( forClass, function(obj, display, data) {
    
    if(!obj.areHandlesVisible()) {
        return;
    }
    
    var surface = display.getSurface();
    if(!data.rotIcon) {
        var svg = surface.getSvg();

        var lineAttr = {
            "stroke" : "blue", 
            "stroke-width" : 2
        };
        var handleAttr = {
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            class : "svghandle",
            r : 56
        };
        // "stroke-dasharray":"2,2"
        data.rotLine = svg.line("handle", lineAttr);
        
        
        data.rotIcon = svg.circle("", handleAttr);
        data.rotIcon.addClass("svghandle");
        obj.rotatableFor( data.rotIcon, display );

        
        data.topLine = svg.line("", lineAttr);
        data.rightLine = svg.line("", lineAttr);
        data.bottomLine = svg.line("", lineAttr);
        data.leftLine = svg.line("", lineAttr);
        
        obj.resizeableHeightFor( data.bottomLine );
        
        var resizeIcon = svg.circle();
        resizeIcon.attr({
            "fill" : "blue",
            cx : 0,
            cy : 0,
            cursor : "pointer",
            r : 56
        })
        data.resizeIcon = resizeIcon;
        obj.resizeableFor( data.resizeIcon, display );        
 
        data.resizeBottom = svg.circle("", handleAttr);
        obj.resizeableHeightFor( data.resizeBottom, display );
    
        data.resizeLeft = svg.circle("", handleAttr);
        obj.resizeableWidthFor( data.resizeLeft, display, { inverse : true} );
        
        data.resizeRight = svg.circle("", handleAttr);
        obj.resizeableWidthFor( data.resizeRight, display );        
        if(obj.parent()) {
            var itemList = obj.parent();
            itemList.on("remove", function() {
                if(itemList._removedItem==obj) {
                    data.rotIcon.remove();
                    data.rotLine.remove();
                    data.resizeIcon.remove();
                    data.topLine.remove();
                    data.rightLine.remove();
                    data.bottomLine.remove();
                    data.leftLine.remove();
                    data.resizeBottom.remove();
                    data.resizeLeft.remove();
                    data.resizeRight.remove();                     
                }
            })
        }        
        
    }

}, function(obj, display, data) {
    

    if(obj.areHandlesVisible()) {
        
        if(!data._handlesSet) {
            data.rotIcon.show();
            data.rotLine.show();
            data.topLine.show();
            data.rightLine.show();
            data.bottomLine.show();
            data.leftLine.show();
            data.resizeIcon.show();
            data.resizeBottom.show();
            data.resizeLeft.show();
            data.resizeRight.show();
        }
        
        data._handlesSet = true;
    } else {
        if(data._handlesSet) {
            data.rotIcon.hide();
            data.rotLine.hide();
            data.resizeIcon.hide();
            data.topLine.hide();
            data.rightLine.hide();
            data.bottomLine.hide();
            data.leftLine.hide();
            data.resizeBottom.hide();
            data.resizeLeft.hide();
            data.resizeRight.hide();            
        }
        data._handlesSet = false;
        return;
    }   
    
    // console.log("***** Refreshing the surface 4 ");
    var camera = display.getCamera(),
        surface = display.getSurface(),
        main = _e( display.getSurface().getDom() ),
        perspective = 1000;
        
    var docWidth = surface.getWidth(),
        docHeight = surface.getHeight();    

    // OK, then...
    var rendM = obj.getRenderMatrix().createCopy();
    var move = Matrix3D();
    var a = rendM.m00();
        b = rendM.m10();
    var xScale = Math.sqrt( a*a + b*b );
    if(xScale===0) return;
    
    rendM = obj.getRenderMatrix().createCopy();
    var getPoint = function(x,y) {
        return rendM.screenProjection({
            x: x, y : y, z:0, w:1
        }, {
            d : perspective,
            cx : docWidth/2,
            cy : docHeight/2
        });         
    }
    
    var rightTopMiddle = getPoint(obj.w()/2, 0),
        rightTopMiddleUp = getPoint(obj.w()/2, -20 / xScale),
        leftTop = getPoint( 0, 0 ),
        rightTop = getPoint( obj.w(), 0),
        rightBottom = getPoint(obj.w(),obj.h()),
        leftBottom = getPoint(0, obj.h()),
        bottomMiddle = getPoint(obj.w()/2, obj.h()),
        rightMiddle = getPoint(obj.w(),obj.h()/2),
        leftMiddle = getPoint(0, obj.h()/2);

    data.rotIcon.attr({
        r : 6,
        cx : rightTopMiddleUp.x,
        cy : rightTopMiddleUp.y
    });
    data.resizeIcon.attr({
        r : 6,
        cx : rightBottom.x,
        cy : rightBottom.y
    });
    data.resizeBottom.attr({
        r : 6,
        cx : bottomMiddle.x,
        cy : bottomMiddle.y
    });    
    data.resizeLeft.attr({
        r : 6,
        cx : leftMiddle.x,
        cy : leftMiddle.y
    });     
    data.resizeRight.attr({
        r : 6,
        cx : rightMiddle.x,
        cy : rightMiddle.y
    });     
    data.rotLine.attr({
        x1 : rightTopMiddle.x,
        y1 : rightTopMiddle.y,
        x2 : rightTopMiddleUp.x,
        y2 : rightTopMiddleUp.y
    });
    
    
    data.topLine.attr({
        x1 : leftTop.x,
        y1 : leftTop.y,
        x2 : rightTop.x,
        y2 : rightTop.y
    });
    data.rightLine.attr({
        x1 : rightTop.x,
        y1 : rightTop.y,
        x2 : rightBottom.x,
        y2 : rightBottom.y
    });
    data.bottomLine.attr({
        x1 : leftBottom.x,
        y1 : leftBottom.y,
        x2 : rightBottom.x,
        y2 : rightBottom.y
    });
    data.leftLine.attr({
        x1 : leftTop.x,
        y1 : leftTop.y,
        x2 : leftBottom.x,
        y2 : leftBottom.y
    });    
    
    

}, function(obj, display, data) {
    data.resizeLeft.hide();
    data.resizeRight.hide();       
    data.rotIcon.hide();
    data.topLine.hide();
    data.rightLine.hide();
    data.bottomLine.hide();
    data.resizeBottom.hide();
    data.resizeIcon.hide();
    data.leftLine.hide();

});
```

### <a name="surface_svgHandles"></a>surface::svgHandles(forClass)


```javascript
/*sface5.registerRenderer( "pathpoint", function(obj, display, data) {

        var surface = display.getSurface();
        if(!data.viewObj) {
            var svg = surface.getSvg();
            var icon = svg.circle();
            icon.attr({
                "fill" : "cyan",
                cx : 0,
                cy : 0,
                r : 56
            })

            data.viewObj = icon;
            obj.draggableFor( data.viewObj, display );
        }
    }, 
    function(obj, display, data) {
        
        var p = obj.parent().parent();
        if(!p.areHandlesVisible() && !obj.areHandlesVisible()) {
            data.viewObj.attr({
                r: 0
            });
            return;
        } else {

        }
        
        var surface = display.getSurface();
        var bgStyle = "";
        var rendM = obj.getRenderMatrix().createCopy();
        var move = Matrix3D();
        var a = rendM.m00();
            b = rendM.m10();
        var xScale = Math.sqrt( a*a + b*b );        
        
        var aList = {
            transform : obj.getRenderMatrix().getSVGTransform()
        };
        aList["r"] = 6*(1/xScale);


        data.viewObj.attr(aList); 
  
        
    }, function(obj, display, data) {
        data.viewObj.remove();
    });  
*/    
this.registerRenderer( forClass, function(obj, display, data) {
    
    if(!obj.areHandlesVisible()) {
        return;
    }
    
    var surface = display.getSurface();
    if(!data.rotIcon) {
        var svg = surface.getSvg();

        var lineAttr = {
            "stroke" : "blue", 
            "stroke-width" : 2
        };
        var handleAttr = {
            "fill" : "blue",
            "stroke" : "white",
            cx : 0,
            cy : 0,
            "stoke-width" : 1,
            cursor : "pointer",
            class : "svghandle",
            r : 56
        };
        // "stroke-dasharray":"2,2"
        data.rotLine = svg.line("handle", lineAttr);
        
        
        data.rotIcon = svg.circle("", handleAttr);

        obj.rotatableFor( data.rotIcon, display );

        
        data.topLine = svg.line("", lineAttr);
        data.rightLine = svg.line("", lineAttr);
        data.bottomLine = svg.line("", lineAttr);
        data.leftLine = svg.line("", lineAttr);
        
        obj.resizeableHeightFor( data.bottomLine );
        
        var resizeIcon = svg.circle();
        resizeIcon.attr(handleAttr);
        data.resizeIcon = resizeIcon;
        obj.resizeableFor( data.resizeIcon, display );  

        var resizeIconRt = svg.circle();
        resizeIconRt.attr(handleAttr)        
        data.resizeIconRt = resizeIconRt;
        obj.resizeableFor( data.resizeIconRt, display, {
            i : 0,
            j : 1
        } );   
        
        var resizeIconLt = svg.circle();
        resizeIconLt.attr(handleAttr)        
        data.resizeIconLt = resizeIconLt;
        obj.resizeableFor( data.resizeIconLt, display, {
            i : 1,
            j : 1
        } ); 
        
        var resizeIconLb = svg.circle();
        resizeIconLb.attr(handleAttr)        
        data.resizeIconLb = resizeIconLb;
        obj.resizeableFor( data.resizeIconLb, display, {
            i : 1,
            j : 0
        } );         
 
        data.resizeBottom = svg.circle("", handleAttr);
        obj.resizeableHeightFor( data.resizeBottom, display );
    
        data.resizeLeft = svg.circle("", handleAttr);
        obj.resizeableWidthFor( data.resizeLeft, display, { inverse : true} );
        
        data.resizeRight = svg.circle("", handleAttr);
        obj.resizeableWidthFor( data.resizeRight, display );        
        if(obj.parent()) {
            var itemList = obj.parent();
            itemList.on("remove", function() {
                if(itemList._removedItem==obj) {
                    data.rotIcon.remove();
                    data.rotLine.remove();
                    data.resizeIcon.remove();
                    data.topLine.remove();
                    data.rightLine.remove();
                    data.bottomLine.remove();
                    data.leftLine.remove();
                    data.resizeBottom.remove();
                    data.resizeLeft.remove();
                    data.resizeRight.remove();           
                    data.resizeIconRt.remove();
                    data.resizeIconLt.remove();
                    data.resizeIconLb.remove();
                }
            })
        }        
        
    }

}, function(obj, display, data) {
    

    if(obj.areHandlesVisible()) {
        
        if(!data._handlesSet) {
            data.rotIcon.show();
            data.rotLine.show();
            data.topLine.show();
            data.rightLine.show();
            data.bottomLine.show();
            data.leftLine.show();
            data.resizeIcon.show();
            data.resizeBottom.show();
            data.resizeLeft.show();
            data.resizeRight.show();
            data.resizeIconRt.show();
            data.resizeIconLt.show();
            data.resizeIconLb.show();
        }
        
        data._handlesSet = true;
    } else {
        if(data._handlesSet) {
            data.rotIcon.hide();
            data.rotLine.hide();
            data.resizeIcon.hide();
            data.topLine.hide();
            data.rightLine.hide();
            data.bottomLine.hide();
            data.leftLine.hide();
            data.resizeBottom.hide();
            data.resizeLeft.hide();
            data.resizeRight.hide();   
            data.resizeIconRt.hide();
            data.resizeIconLt.hide();
            data.resizeIconLb.hide();
        }
        data._handlesSet = false;
        return;
    }   
    
    // console.log("***** Refreshing the surface 4 ");
    var camera = display.getCamera(),
        surface = display.getSurface(),
        main = _e( display.getSurface().getDom() ),
        perspective = 1000;
        
    var docWidth = surface.getWidth(),
        docHeight = surface.getHeight();    

    // OK, then...
    var rendM = obj.getViewMatrix(display.getCamera()).createCopy();
    var move = Matrix3D();
    var a = rendM.m00(),
        b = rendM.m10();
    var xScale = Math.sqrt( a*a + b*b );
    if(xScale===0) return;
    
    rendM = obj.getViewMatrix(display.getCamera()).createCopy();
    var getPoint = function(x,y) {
        return rendM.screenProjection({
            x: x, y : y, z:0, w:1
        }, {
            d : perspective,
            cx : docWidth/2,
            cy : docHeight/2
        });         
    }
    
    var rightTopMiddle = getPoint(obj.w()/2, 0),
        rightTopMiddleUp = getPoint(obj.w()/2, -20 / xScale),
        leftTop = getPoint( 0, 0 ),
        rightTop = getPoint( obj.w(), 0),
        rightBottom = getPoint(obj.w(),obj.h()),
        leftBottom = getPoint(0, obj.h()),
        bottomMiddle = getPoint(obj.w()/2, obj.h()),
        rightMiddle = getPoint(obj.w(),obj.h()/2),
        leftMiddle = getPoint(0, obj.h()/2);

    data.rotIcon.attr({
        r : 6,
        cx : rightTopMiddleUp.x,
        cy : rightTopMiddleUp.y
    });
    data.resizeIcon.attr({
        r : 6,
        cx : rightBottom.x,
        cy : rightBottom.y
    });
    data.resizeIconRt.attr({
        r : 6,
        cx : rightTop.x,
        cy : rightTop.y
    });   
    data.resizeIconLt.attr({
        r : 6,
        cx : leftTop.x,
        cy : leftTop.y
    }); 
    data.resizeIconLb.attr({
        r : 6,
        cx : leftBottom.x,
        cy : leftBottom.y
    });     
    data.resizeBottom.attr({
        r : 6,
        cx : bottomMiddle.x,
        cy : bottomMiddle.y
    });    
    data.resizeLeft.attr({
        r : 6,
        cx : leftMiddle.x,
        cy : leftMiddle.y
    });     
    data.resizeRight.attr({
        r : 6,
        cx : rightMiddle.x,
        cy : rightMiddle.y
    });     
    data.rotLine.attr({
        x1 : rightTopMiddle.x,
        y1 : rightTopMiddle.y,
        x2 : rightTopMiddleUp.x,
        y2 : rightTopMiddleUp.y
    });
    
    
    data.topLine.attr({
        x1 : leftTop.x,
        y1 : leftTop.y,
        x2 : rightTop.x,
        y2 : rightTop.y
    });
    data.rightLine.attr({
        x1 : rightTop.x,
        y1 : rightTop.y,
        x2 : rightBottom.x,
        y2 : rightBottom.y
    });
    data.bottomLine.attr({
        x1 : leftBottom.x,
        y1 : leftBottom.y,
        x2 : rightBottom.x,
        y2 : rightBottom.y
    });
    data.leftLine.attr({
        x1 : leftTop.x,
        y1 : leftTop.y,
        x2 : leftBottom.x,
        y2 : leftBottom.y
    });    
    
    

}, function(obj, display, data) {
    if(!data.rotIcon) return;
    data.rotIcon.hide();
    data.rotLine.hide();
    data.resizeIcon.hide();
    data.topLine.hide();
    data.rightLine.hide();
    data.bottomLine.hide();
    data.leftLine.hide();
    data.resizeBottom.hide();
    data.resizeLeft.hide();
    data.resizeRight.hide();   
    data.resizeIconRt.hide();
    data.resizeIconLt.hide();
    data.resizeIconLb.hide();
    
    data._handlesSet = false;

});
```



   
    
## trait _dataTrait

The class has following internal singleton variables:
        
* _eventOn
        
* _commands
        
        
### <a name="_dataTrait_guid"></a>_dataTrait::guid(t)


```javascript

return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
        
//return Math.random();
// return Math.random().toString(36);
        
/*    
return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
*/
/*        
function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }

return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
       s4() + '-' + s4() + s4() + s4();*/
```

### <a name="_dataTrait_isArray"></a>_dataTrait::isArray(t)


```javascript

if(typeof(t)=="undefined") return this.__isA;

return Object.prototype.toString.call( t ) === '[object Array]';
```

### <a name="_dataTrait_isFunction"></a>_dataTrait::isFunction(fn)


```javascript
return Object.prototype.toString.call(fn) == '[object Function]';
```

### <a name="_dataTrait_isObject"></a>_dataTrait::isObject(t)


```javascript

if(typeof(t)=="undefined") return this.__isO;

return t === Object(t);
```


    
    


   
      
    



      
    
      
            
# Class drawIconbox


The class has following internal singleton variables:
        
        
### <a name="drawIconbox_adjustDivSize"></a>drawIconbox::adjustDivSize(t)


```javascript

```

### <a name="drawIconbox_adjustStyleProps"></a>drawIconbox::adjustStyleProps(t)


```javascript

var scaleF = (this.width / this.origWidth).toFixed(5);

var dx = -1*(1/scaleF)*this.width / 2,    
    dy = -1*(1/scaleF)*this.width / 2;
var matStr = "transform-origin:50% 50%;-webkit-transform-origin:50% 50%; -ms-transform-origin: 50% 50%;";



var ts = "translate("+(this.cx+dx)+"px,"+(this.cy+dy)+"px) scale("+scaleF+")  ;"

matStr+="transform:"+ts;
matStr+="-ms-transform:"+ts;
matStr+="-webkit-transform:"+ts;


var bgColor = this.options.bgColor || "blue";

var styleStr = matStr+";background-color:"+bgColor+";width:"+this.origWidth+"px;height:"+this.origWidth+"px;position:absolute;left:0px;top:0px;";

this.iconG.attr({
    "transform":"scale(1)"
});

this.myDiv.attr({
    style : styleStr
});


    

    
    

```

### <a name="drawIconbox_attr"></a>drawIconbox::attr(v)


```javascript

return this.myDiv.attr(v);
```

### <a name="drawIconbox_draggable"></a>drawIconbox::draggable(f1, f2, f3)


```javascript

this.myDiv.draggable(f1,f2,f3);
this.iconG.draggable(f1,f2,f3);

return this;

```

### <a name="drawIconbox_getElem"></a>drawIconbox::getElem(t)


```javascript

return this.myDiv;
```

### <a name="drawIconbox_hide"></a>drawIconbox::hide(t)


```javascript
this.myDiv.hide();
```

### drawIconbox::constructor( cx, cy, width, iconPath, options )

```javascript


this.cx = cx;
this.cy = cy;
this.origWidth = width;
this.width = width;
this.iconPath = iconPath;
this.options = options || {};

var myDiv = _e("div");
myDiv.absolute().x(0).y(0);
var svg = myDiv.svg();

svg.attr({
    width : this.width,
    height : this.width
})

this.iconG = svg.g();
this.iconG.path({
    d : iconPath,
    fill : this.options.iconColor || "white"
});

this.myDiv = myDiv;

this.adjustStyleProps();


```
        
### <a name="drawIconbox_length"></a>drawIconbox::length(t)


```javascript

var dx = this.ex - this.sx,
    dy = this.ey - this.sy;
    
return Math.sqrt( dx*dx + dy*dy );
```

### <a name="drawIconbox_moveTo"></a>drawIconbox::moveTo(cx, cy, width, ey)


```javascript
this.cx = cx;
this.cy = cy;

if(width) this.width = width;

this.adjustStyleProps();

```

### <a name="drawIconbox_show"></a>drawIconbox::show(t)


```javascript

this.myDiv.show();
```



   


   



      
    
      
            
# Class jsVectors


The class has following internal singleton variables:
        
* projectionMatrix
        
* jVect
        
* iVect
        
* pBase
        
* tn1
        
* nv1
        
* barCoeffs
        
* deVector
        
        
### <a name="jsVectors_add"></a>jsVectors::add(v1, v2)


```javascript

    v1.x = v1.x + v2.x;
    v1.y = v1.y + v2.y;
    
```

### <a name="jsVectors_angleBetween"></a>jsVectors::angleBetween(v1, v2)


```javascript

var n1 = this.normalize( { x : v1.x, y : v1.y } );
var n2 = this.normalize( { x : v2.x, y : v2.y } );

var cp = this.crossProd( n1, n2 );
var dp = this.dotProd(n1, n2 );

var a = Math.acos( dp );
if(cp<0) a = a*-1; // other side...
return a;
    
```

### <a name="jsVectors_calc_cat"></a>jsVectors::calc_cat(t, p0, p1, p2, p3)


```javascript

var t2 = t*t;
var t3 = t2 * t;
return (0.5 *(  (2 * p1) + (-p0 + p2) * t +(2*p0 - 5*p1 + 4*p2 - p3) * t2 +(-p0 + 3*p1- 3*p2 + p3) * t3));

```

### <a name="jsVectors_crossProd"></a>jsVectors::crossProd(v1, v2)


```javascript

        // U x V = Ux*Vy-Uy*Vx
        return v1.x*v2.y - v1.y*v2.x;
    
```

### <a name="jsVectors_diff"></a>jsVectors::diff(p1, p2)


```javascript

return { x : p2.x - p1.x,
         y : p2.y - p1.y };
    
```

### <a name="jsVectors_dist"></a>jsVectors::dist(p1, p2)


```javascript
                    
var dx = p1.x - p2.x;
var dy = p1.y - p2.y;
return Math.sqrt( dx*dx + dy*dy );
    
```

### <a name="jsVectors_dotProd"></a>jsVectors::dotProd(v1, v2)


```javascript

return v1.x*v2.x + v1.y*v2.y;
    
```

### <a name="jsVectors_getBarCoeffs"></a>jsVectors::getBarCoeffs(p0, p1, p2)


```javascript

var bb = barCoeffs;
bb.A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
bb.sign = bb.A < 0 ? -1 : 1;
bb.s1 = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) ) *bb.sign;
bb.s2 = (p2.y - p0.y) * bb.sign;
bb.s3 = (p0.x - p2.x) * bb.sign;
bb.t1 = (p0.x * p1.y - p0.y * p1.x)*bb.sign;
bb.t2 = (p0.y - p1.y) * bb.sign;
bb.t3 = (p1.x - p0.x) * bb.sign;
return bb;
    
```

### jsVectors::constructor( t )

```javascript

if(!tn1) { 
    
   tn1 = { x: 0, y : 0};
   nv1 = { x: 0, y : 0};
   
   projectionMatrix = [0,0,0,0];
   
   jVect = { x:0, y:0 };
   iVect = { x:0, y:0 };
   pBase = { x:0, y:0 }; 
   
   barCoeffs = { Area : 0, s1 : 0, s2 : 0, s3 : 0, t1:0, t2:0, t3:0, sign : 0 };   
   deVector = { x:0, y:0};
   
}
```
        
### <a name="jsVectors_initProjection"></a>jsVectors::initProjection(p1, p2)


```javascript

iVect.y = p2.y - p1.y;
iVect.x = p2.x - p1.x;

jVect.y = iVect.y;
jVect.x = iVect.x;

this.normalize(iVect);
this.normalize(jVect);

this.rotate( jVect, Math.PI/2);

pBase.x = p1.x;
pBase.y = p1.y;
       
   
```

### <a name="jsVectors_length"></a>jsVectors::length(p1)


```javascript

var dx = p1.x;
var dy = p1.y;
return Math.sqrt( dx*dx + dy*dy );        
    
```

### <a name="jsVectors_linesIntersect"></a>jsVectors::linesIntersect(p0, p1, v0, v1)


```javascript

var x1 = p0.x,
    y1 = p0.y,
    x2 = p1.x,
    y2 = p1.y,
    x3 = v0.x,
    y3 = v0.y,
    x4 = v1.x,
    y4 = v1.y;

var x=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
var y=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
if (isNaN(x)||isNaN(y)) {
    return false;
} else {
    if (x1>=x2) {
        if (!(x2<=x&&x<=x1)) {return false;}
    } else {
        if (!(x1<=x&&x<=x2)) {return false;}
    }
    if (y1>=y2) {
        if (!(y2<=y&&y<=y1)) {return false;}
    } else {
        if (!(y1<=y&&y<=y2)) {return false;}
    }
    if (x3>=x4) {
        if (!(x4<=x&&x<=x3)) {return false;}
    } else {
        if (!(x3<=x&&x<=x4)) {return false;}
    }
    if (y3>=y4) {
        if (!(y4<=y&&y<=y3)) {return false;}
    } else {
        if (!(y3<=y&&y<=y4)) {return false;}
    }
}
return true;
    
```

### <a name="jsVectors_mirrorVector"></a>jsVectors::mirrorVector(v1, along, base)


```javascript

// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along.x - base.x;   
tn1.y = along.y - base.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

v1.x = v1.x - base.x;
v1.y = v1.y - base.y;

// if the 'j' or normal projection is positive, turn around
if( this.dotProd(v1,nv1) > 0) 
    this.rotate(nv1, Math.PI);        

this.normalize(tn1);
this.normalize(nv1);

// Create positive coordinates of the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( this.dotProd(v1,nv1) );
//             tnProd = Math.abs( this.dotProd(v1,tn1) );
    
var tnProd = this.dotProd(v1,tn1);
// then, project the length of the base vectors to get the new vector space
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;   

v1.x += base.x;
v1.y += base.y;

return v1;        
    
```

### <a name="jsVectors_normalize"></a>jsVectors::normalize(v)


```javascript

var len = Math.sqrt( v.x*v.x + v.y*v.y);

if(len==0) {
    throw "Error normalizing vector: the length of the vector was zero";
}

v.x = v.x/len;
v.y = v.y/len;
return v;
    
```

### <a name="jsVectors_opposeVector"></a>jsVectors::opposeVector(v1, along)


```javascript


// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along,x;   
tn1.y = along.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

this.normalize(tn1);
this.normalize(nv1);

// Important: turn the tangent to opposing direction...
this.rotate(tn1, Math.PI);

// Create the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( jsMath.dotProd(v1,nv1) ),
    tnProd = Math.abs( jsMath.dotProd(v1,tn1) );
    
// if the 'j' or normal projection is negative, turn around
if( this.dotProd(v1,nv1) < 0) 
    this.rotate(nv1, Math.PI);
    
// then, project the length of the vector to get the new vector
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;        

return v1;
    
```

### <a name="jsVectors_pointInTriangle"></a>jsVectors::pointInTriangle(p, p0, p1, p2)


```javascript


var A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
var sign = A < 0 ? -1 : 1;
var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_pointInTriangleBc"></a>jsVectors::pointInTriangleBc(p, bb)


```javascript

var A = bb.A;
var sign = bb.sign;
var s = (bb.s1 +  bb.s2 * p.x + bb.s3 * p.y);
var t = (bb.t1 +  bb.t2 * p.x + bb.t3 * p.y);

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_project"></a>jsVectors::project(vectorToProject)


```javascript


var p = vectorToProject;

pVector.x = p.x - pBase.x;
pVector.y = p.y - pBase.y;

prodResult.i = this.dotProd( pVector, iVect);
prodResult.j = this.dotProd( pVector, jVect);

return prodResult;

```

### <a name="jsVectors_rotate"></a>jsVectors::rotate(v, angle)


```javascript


var s = Math.sin(angle);
var c = Math.cos(angle);

var x = v.x,
    y = v.y;

v.x = x * c + y * s;
v.y = -x * s + y * c;

return v;
    
```

### <a name="jsVectors_rotateAround"></a>jsVectors::rotateAround(angle, v, around)


```javascript

this.sub(v, around);
this.rotate(v,angle);
this.add(v,around);
    
```

### <a name="jsVectors_sub"></a>jsVectors::sub(v1, v2)


```javascript

v1.x = v1.x - v2.x;
v1.y = v1.y - v2.y;
    
```

### <a name="jsVectors_tangentNormal"></a>jsVectors::tangentNormal(v1, v2, v3)


```javascript


var t1 = {};
t1.x = v2.x - v1.x;
t1.y = v2.y - v1.y;
var t2 = {};
t2.x = v3.x - v2.x;
t2.y = v3.y - v2.y;

var p = { x : t1.x+t2.x,
          y : t1.y+t2.y
        };
return this.normalize(p);
    
```

### <a name="jsVectors_triangleArea"></a>jsVectors::triangleArea(A, B, C)


```javascript

        
var area = A.x * ( B.y - C.y ) +
           B.x * ( C.y - A.y ) +
           C.x * ( A.y - B.y );
        
return Math.abs( area / 2);        
    
```

### <a name="jsVectors_triangleInTriangle"></a>jsVectors::triangleInTriangle(p0, p1, p2, q0, q1, q2)


```javascript

        
var bb = this.getBarCoeffs(p0,p1,p2);

if(this.pointInTriangleBc( q0, bb) ) return true;
if(this.pointInTriangleBc( q1, bb) ) return true;
if(this.pointInTriangleBc( q2, bb) ) return true;

var bb = this.getBarCoeffs(q0, q1, q2 );

if(this.pointInTriangleBc( p0, bb) ) return true;
if(this.pointInTriangleBc( p1, bb) ) return true;
if(this.pointInTriangleBc( p2, bb) ) return true;


if(this.linesIntersect( p0,p1, q0,q1)) return true;
if(this.linesIntersect( p1,p2, q0,q1)) return true;
if(this.linesIntersect( p2,p0, q0,q1)) return true;

if(this.linesIntersect( p0,p1, q1,q2)) return true;
if(this.linesIntersect( p1,p2, q1,q2)) return true;
if(this.linesIntersect( p2,p0, q1,q2)) return true;        

if(this.linesIntersect( p0,p1, q2,q0)) return true;
if(this.linesIntersect( p1,p2, q2,q0)) return true;
if(this.linesIntersect( p2,p0, q2,q0)) return true;             

return false;
    
```

### <a name="jsVectors_unProject"></a>jsVectors::unProject(projectedVector)


```javascript

var p = projectedVector;
deVector.x = p.i * iVect.x + p.j * jVect.x;
deVector.y = p.i * iVect.y + p.j * jVect.y;

deVector.x += pBase.x;
deVector.y += pBase.y;
return deVector;
   
```



   


   



      
    
      
            
# Class surfaceDom2D


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### <a name="surfaceDom2D_frameClear"></a>surfaceDom2D::frameClear(t)


```javascript

```

### <a name="surfaceDom2D_getDom"></a>surfaceDom2D::getDom(t)


```javascript
return this._dom;
```

### surfaceDom2D::constructor( elem, width, height )

```javascript

this._dom = elem;
this._width = width;
this._height = height;

var d = _e(elem);

d.attr({
    style : "width:"+width+"px;height:"+height+"px;background-color:none;position:absolute;left:0px;top:0px;overflow:hidden;"
});

if(!this._renderFns) {
    this._renderFns = {};
}
```
        


   


   



      
    
      
            
# Class display


The class has following internal singleton variables:
        
        
### <a name="display_changeCamera"></a>display::changeCamera(newCamera)


```javascript

var root = this.getCamera().getRootNode(),
    me = this,
    sface = this.getSurface();

// remove all the objects from the old camera
root.forChildren( function(n) {
    sface.removeObject( n, me );
});

this._camera = newCamera;

root = newCamera.getRootNode(),
root.forChildren( function(n) {
    sface.startObject( n, me );
});


// removeObject
```

### <a name="display_getCamera"></a>display::getCamera(t)


```javascript
return this._camera;
```

### <a name="display_getSurface"></a>display::getSurface(t)


```javascript
return this._surface;
```

### <a name="display_id"></a>display::id(t)


```javascript
if(!this._id) {
    this._id = this.guid();
}
return this._id;
```

### display::constructor( camera, surface )

```javascript

console.log("Display constructor called");
console.log(camera);
console.log(surface);

this._camera = camera;
this._surface = surface;

camera.registerDisplay( this );
```
        
### <a name="display_refreshObject"></a>display::refreshObject(obj, fromClass)


```javascript

// restartObject

var s = this.getSurface();
s.restartObject( obj, this, fromClass );

var dd = this;
obj.forChildren( function(cObj) {
    if(cObj==obj) return;
    s.restartObject( cObj, dd, cObj.renderClass() );
});


```

### <a name="display_render"></a>display::render(obj)


```javascript

// console.log("Render for ", obj);

if(obj.addToDisplay) {
    obj.addToDisplay( this.id(), this );
    this._surface.render( obj, this );
} else {
    // console.log("Could not add to display ", obj);
}
```

### <a name="display_renderTree"></a>display::renderTree(rootObj)


```javascript


if(rootObj && rootObj.isFulfilled && !rootObj.isFulfilled()) return;

if(!rootObj) {
    var cam = this.getCamera();
    rootObj = cam.getRootNode();
    
}

var sf = this.getSurface();

if(sf.renderTree) {
    sf.renderTree( rootObj, this );
    return this;
}

var me = this;
me.render( rootObj );
if(rootObj.items) {
    rootObj.items.forEach(function(i) {
        me.renderTree( i );
    });
}

// Might show the handles, but not available here...
```



   
    
## trait _dataTrait

The class has following internal singleton variables:
        
* _eventOn
        
* _commands
        
        
### <a name="_dataTrait_guid"></a>_dataTrait::guid(t)


```javascript

return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
        
//return Math.random();
// return Math.random().toString(36);
        
/*    
return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
*/
/*        
function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }

return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
       s4() + '-' + s4() + s4() + s4();*/
```

### <a name="_dataTrait_isArray"></a>_dataTrait::isArray(t)


```javascript

if(typeof(t)=="undefined") return this.__isA;

return Object.prototype.toString.call( t ) === '[object Array]';
```

### <a name="_dataTrait_isFunction"></a>_dataTrait::isFunction(fn)


```javascript
return Object.prototype.toString.call(fn) == '[object Function]';
```

### <a name="_dataTrait_isObject"></a>_dataTrait::isObject(t)


```javascript

if(typeof(t)=="undefined") return this.__isO;

return t === Object(t);
```


    
    


   
      
    



      
    
      
            
# Class surfaceDom3D


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### surfaceDom3D::constructor( elem, width, height )

```javascript

this._dom = elem;
this._width = width;
this._height = height;

var d = _e(elem);

d.attr({
    style : "width:"+width+"px;height:"+height+"px;background-color:#f3f1e7;position:absolute;left:0px;top:0px;overflow:hidden;"
});

if(!this._renderFns) {
    this._renderFns = {};
}
```
        


   


   



      
    
      
            
# Class surfaceDomCanvas


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### <a name="surfaceDomCanvas_canvasRender"></a>surfaceDomCanvas::canvasRender(obj, display)


```javascript
var rt = obj.renderClass();

var _renderFns = this._renderFns;


if(_renderFns[rt]) {
    var fnData = _renderFns[rt];
    
    obj.setRenderScope( this.id() );
    
    var rendData = obj.getRenderData(this.id());
    
    if(typeof( rendData.state )=="undefined") rendData.state = 1;
    
    if(obj.askToRemove(this.id())) {
        
        fnData.end( obj, display, rendData  );
        rendData.state=3;
        obj.askToRemove(this.id(), false);
    }

    if(rendData.state==1) {
        
        // Different canvas specific instructions come here...
        //var ctx = this.getContext();
        // ctx.save();

        fnData.start( obj, display, rendData );
        obj.projectToCamera( display.getCamera() );
        fnData.refresh( obj, display, rendData  );
        
        // ctx.restore();
    }
    
    if(rendData.state==2) {
        obj.projectToCamera( display.getCamera() );
        fnData.refresh( obj, display, rendData  );
    }
  
    
    obj.setRenderScope( null );

} 
```

### <a name="surfaceDomCanvas_frameClear"></a>surfaceDomCanvas::frameClear(t)


```javascript

if(this._clearIndex && (t === this._clearIndex) ) return;

this._clearIndex = t;

var context = this.getContext();
context.clearRect( 0 , 0 , this.getWidth(), this.getHeight() );
```

### <a name="surfaceDomCanvas_getContext"></a>surfaceDomCanvas::getContext(t)


```javascript


return this.getDom().getContext("2d");
```

### surfaceDomCanvas::constructor( elem, width, height )

```javascript


this._width = width;
this._height = height;
var cont = _e(elem);
var d = cont.canvas();

d.attr({
    style : "width:"+width+"px;height:"+height+"px;position:absolute;left:0px;top:0px;overflow:hidden;",
    width : width+"px",
    height : height+"px"
});
d.width(width);
d.height(height);
cont.width(width);
cont.height(height);

if(!this._renderFns) {
    this._renderFns = {};
}

this._elem = d;
this._dom = d._dom;
```
        
### <a name="surfaceDomCanvas_renderTree"></a>surfaceDomCanvas::renderTree(rootObj, display)


```javascript
if(rootObj.isFulfilled && !rootObj.isFulfilled()) return;
var me = this;
me.canvasRender( rootObj, display );
if(rootObj.items) {
    rootObj.items.forEach(function(i) {
        me.renderTree( i, display );
    });
}
```



   


   



      
    
      
            
# Class surfaceDomSVG


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### <a name="surfaceDomSVG_getHoverLayer"></a>surfaceDomSVG::getHoverLayer(t)


```javascript
return this._hoverLayer;
```

### <a name="surfaceDomSVG_getSvg"></a>surfaceDomSVG::getSvg(t)


```javascript
return this._childHolder;
```

### surfaceDomSVG::constructor( elem, width, height )

```javascript

this._dom = elem;
this._width = width;
this._height = height;

var d = _e(elem);

this._svgElem = d.svg();
this._svgElem.attr({
    width : width,
    height : height
});

this._childHolder = this._svgElem.g();
this._hoverLayer  = this._svgElem.g();

d.attr({
    style : "width:"+width+"px;height:"+height+"px;background-color:none;position:absolute;left:0px;top:0px;overflow:hidden;"
});

if(!this._renderFns) {
    this._renderFns = {};
}
```
        


   


   



      
    
      
            
# Class surfaceDomPixi


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### <a name="surfaceDomPixi_frameClear"></a>surfaceDomPixi::frameClear(t)


```javascript

```

### <a name="surfaceDomPixi_frameFinish"></a>surfaceDomPixi::frameFinish(t)


```javascript

if(this._lastFinishT && (this._lastFinishT===t)) return;

this._lastFinishT=t;

this._renderer.render(this._stage);
```

### <a name="surfaceDomPixi_getStage"></a>surfaceDomPixi::getStage(t)


```javascript
return this._stage;
```

### surfaceDomPixi::constructor( elem, width, height )

```javascript

this._dom = elem;
this._width = width;
this._height = height;

var d = _e(elem);

var stage = new PIXI.Stage(0xffffff);

// create a renderer instance.
var renderer = PIXI.autoDetectRenderer(width, height);

this._stage = stage;
this._renderer = renderer;
    
d._dom.appendChild( renderer.view );    

d.attr({
    style : "width:"+width+"px;height:"+height+"px;background-color:#f0f0f0;position:absolute;left:0px;top:0px;overflow:hidden;"
});

if(!this._renderFns) {
    this._renderFns = {};
}
/*
    var stage = new PIXI.Stage(0x66FF99);
 
    // create a renderer instance.
    var renderer = PIXI.autoDetectRenderer(400, 300);
 
    // add the renderer view element to the DOM
    document.body.appendChild(renderer.view);
 
    requestAnimFrame( animate );
 
    // create a texture from an image path
    var texture = PIXI.Texture.fromImage("bunny.png");
    // create a new Sprite using the texture
    var bunny = new PIXI.Sprite(texture);
 
    // center the sprites anchor point
    bunny.anchor.x = 0.5;
    bunny.anchor.y = 0.5;
 
    // move the sprite t the center of the screen
    bunny.position.x = 200;
    bunny.position.y = 150;
 
    stage.addChild(bunny);
 
    function animate() {
 
        requestAnimFrame( animate );
 
        // just for fun, lets rotate mr rabbit a little
        bunny.rotation += 0.1;
 
        // render the stage   
        renderer.render(stage);
    }
*/
```
        


   


   



      
    
      
            
# Class drawBox


The class has following internal singleton variables:
        
        
### <a name="drawBox_adjustDivSize"></a>drawBox::adjustDivSize(t)


```javascript

```

### <a name="drawBox_adjustStyleProps"></a>drawBox::adjustStyleProps(t)


```javascript

var scaleF = (this.width / this.origWidth).toFixed(5);

var dx = -1*(1/scaleF)*this.width / 2,    
    dy = -1*(1/scaleF)*this.width / 2;
var matStr = "transform-origin:50% 50%;-webkit-transform-origin:50% 50%; -ms-transform-origin: 50% 50%;";

var ts = "translate("+(this.cx+dx)+"px,"+(this.cy+dy)+"px) scale("+scaleF+")  ;"

matStr+="transform:"+ts;
matStr+="-ms-transform:"+ts;
matStr+="-webkit-transform:"+ts;

var bgColor = this.options.bgColor || "blue";

var styleStr = matStr+";background-color:"+bgColor+";width:"+this.origWidth+"px;height:"+this.origWidth+"px;position:absolute;left:0px;top:0px;";

this.myDiv.attr({
    style : styleStr
});


    

    
    

```

### <a name="drawBox_attr"></a>drawBox::attr(v)


```javascript

return this.myDiv.attr(v);
```

### <a name="drawBox_draggable"></a>drawBox::draggable(f1, f2, f3)


```javascript

this.myDiv.draggable(f1,f2,f3);

return this;

```

### <a name="drawBox_getElem"></a>drawBox::getElem(t)


```javascript

return this.myDiv;
```

### <a name="drawBox_hide"></a>drawBox::hide(t)


```javascript
this.myDiv.hide();
```

### drawBox::constructor( cx, cy, width, options, nothing )

```javascript


this.cx = cx;
this.cy = cy;
this.origWidth = width;
this.width = width;
this.options = options || {};

var myDiv = _e("div");
myDiv.absolute().x(0).y(0);
this.myDiv = myDiv;
this.adjustStyleProps();


```
        
### <a name="drawBox_length"></a>drawBox::length(t)


```javascript

var dx = this.ex - this.sx,
    dy = this.ey - this.sy;
    
return Math.sqrt( dx*dx + dy*dy );
```

### <a name="drawBox_moveTo"></a>drawBox::moveTo(cx, cy, width, ey)


```javascript
this.cx = cx;
this.cy = cy;

if(width) this.width = width;

this.adjustStyleProps();

```

### <a name="drawBox_show"></a>drawBox::show(t)


```javascript

this.myDiv.show();
```



   


   



      
    
      
            
# Class pathTools


The class has following internal singleton variables:
        
        
### <a name="pathTools_childenToContextBezier"></a>pathTools::childenToContextBezier(obj, ctx)


```javascript
 
var pos = 0;
while( obj.items.item(pos+3) ) {
    
    var b1 = obj.items.item(pos).getTransformMatrix(),
        b2 = obj.items.item(pos+1).getTransformMatrix(),
        b3 = obj.items.item(pos+2).getTransformMatrix(),
        b4 = obj.items.item(pos+3).getTransformMatrix();        
        
    if(pos==0) ctx.moveTo(b1.m30(), b1.m31());
    
    ctx.bezierCurveTo(b2.m30(), b2.m31(),
                      b3.m30(), b3.m31(),
                      b4.m30(), b4.m31());
                          
    pos+=3;                        
 }
```

### <a name="pathTools_childrenToSvgBezier"></a>pathTools::childrenToSvgBezier(obj)


```javascript

var pos = 0,
    str = "";
while( obj.items.item(pos+3) ) {
    
    var b1 = obj.items.item(pos).getTransformMatrix(),
        b2 = obj.items.item(pos+1).getTransformMatrix(),
        b3 = obj.items.item(pos+2).getTransformMatrix(),
        b4 = obj.items.item(pos+3).getTransformMatrix();        
        
    if(pos==0) str += "M "+b1.m30()+" "+b1.m31();
    
    str+=" C ";
    str+=" "+b2.m30()+" "+b2.m31();
    str+=" "+b3.m30()+" "+b3.m31();
    str+=" "+b4.m30()+" "+b4.m31();
                          
    pos+=3;                        
 }    
 
 return str;
```

### pathTools::constructor( t )

```javascript

```
        


   


   



      
    
      
            
# Class rendererPackageSVG


The class has following internal singleton variables:
        
        
### rendererPackageSVG::constructor( main )

```javascript

```
        
### <a name="rendererPackageSVG_initSvg"></a>rendererPackageSVG::initSvg(surface)


```javascript

surface.registerRenderer("page", new svgPageRenderer() );
surface.registerRenderer("none", new svgPageRenderer() );
surface.registerRenderer("camera", new svgPageRenderer() );

surface.registerRenderer("box", new svgRectRenderer() );
surface.registerRenderer("circle", new svgCircleRenderer() );
surface.registerRenderer("text", new svgTextRenderer() );
surface.registerRenderer("svgpath", new svgPathRenderer() );

surface.registerRenderer("bezierpath", new svgBezierObjectRenderer() );
surface.registerRenderer("bezierpoint", new svgBezierPointRenderer() );
surface.registerRenderer("bezierhandle", new svgBezierHandleRenderer() );

// svgImageRenderer

surface.registerRenderer("image", new svgImageRenderer() );
```



   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


   
      
            
# Class drawLine


The class has following internal singleton variables:
        
        
### drawLine::constructor( sx, sy, ex, ey, options )

```javascript

```
        


   


   



      
    
      
            
# Class svgPageRenderer


The class has following internal singleton variables:
        
        
### <a name="svgPageRenderer_end"></a>svgPageRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgPageRenderer_refresh"></a>svgPageRenderer::refresh(obj, display, data)


```javascript
var cam = display.getCamera();
var rm = cam.getRenderMatrix().createCopy().inverse();
data.viewG.attr({
    transform : rm.getSVGTransform()
});
```

### <a name="svgPageRenderer_start"></a>svgPageRenderer::start(obj, display, data)


```javascript
var surface = display.getSurface();
if (!data.viewObj) {
    
    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p && p.getRenderData) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    
    data.viewG = main.g();
    data.viewObj = data.viewG.g();
    data.childG = data.viewG.g();
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj);

}
```



   


   



      
    
      
            
# Class svgRectRenderer


The class has following internal singleton variables:
        
        
### <a name="svgRectRenderer_end"></a>svgRectRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgRectRenderer_refresh"></a>svgRectRenderer::refresh(obj, display, data)


```javascript
  var surface = display.getSurface();
  var bgStyle = "";
  var aList = {
    x: 0,
    y: 0,
    width: obj.w(),
    height: obj.h()

  };
  if (obj.bgcolor) {
    aList["fill"] = obj.bgcolor();
  }
  if (obj.alpha) {
    aList["fill-opacity"] = obj.alpha();
  }
  // obj.getViewMatrix(display.getCamera()).getSVGTransform()
  data.viewObj.attr(aList);
  data.viewG.attr({
    transform: obj.getLocalTransform().getSVGTransform()
  })
```

### <a name="svgRectRenderer_start"></a>svgRectRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

var main = surface.getSvg();
var p = obj.displayParent();

if (p) {
  var pData = p.getRenderData();
  if (pData.viewG) {
    main = pData.childG;
  }
}

data.viewG = main.g();
data.viewObj = data.viewG.rect();
data.childG = data.viewG.g();
obj.draggableFor(data.viewObj, display);

obj.domMVC(data.childG);

     obj.matchDomPosition( main, data.viewG, obj);
//    data.viewG._index = obj.indexOf();



}
```



   


   



      
    
      
            
# Class svgCircleRenderer


The class has following internal singleton variables:
        
        
### <a name="svgCircleRenderer_end"></a>svgCircleRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgCircleRenderer_refresh"></a>svgCircleRenderer::refresh(obj, display, data)


```javascript
var surface = display.getSurface();
var bgStyle = "";
var r = Math.min(obj.w() / 2, obj.h() / 2);
var aList = {
cx: r,
cy: r,
r: r
};
if (obj.bgcolor) {
aList["fill"] = obj.bgcolor();
}
if (obj.alpha) {
aList["fill-opacity"] = obj.alpha();
}
data.viewObj.attr(aList);
data.viewG.attr({
transform: obj.getLocalTransform().getSVGTransform()
})
```

### <a name="svgCircleRenderer_start"></a>svgCircleRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    
    data.viewG = main.g();
    data.viewObj = data.viewG.circle();
    data.childG = data.viewG.g();
    obj.draggableFor(data.viewObj, display);
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj);

}
```



   


   



      
    
      
            
# Class svgTextRenderer


The class has following internal singleton variables:
        
        
### <a name="svgTextRenderer_end"></a>svgTextRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgTextRenderer_refresh"></a>svgTextRenderer::refresh(obj, display, data)


```javascript
  var surface = display.getSurface();
  var bgStyle = "";
  var r = Math.min(obj.w() / 2, obj.h() / 2),
      fs = 14;
 
   var aList = {
    x: 0,
    y: fs
  };
  
  if (obj.fontSize) {
    fs = aList["font-size"] = obj.fontSize();
  }      
      

  if (obj.bgcolor) {
    aList["fill"] = obj.bgcolor();
  }

  aList["font-family"] = "Verdana";

  if (obj.alpha) {
    aList["fill-opacity"] = obj.alpha();
  }
  data.viewObj.text(obj.text());
  data.viewObj.attr(aList);
  data.viewG.attr({
    transform: obj.getLocalTransform().getSVGTransform()
  })
```

### <a name="svgTextRenderer_start"></a>svgTextRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    
    data.viewG = main.g();
    data.viewObj = data.viewG.svg_text();
    data.childG = data.viewG.g();
    obj.draggableFor(data.viewObj, display);
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj); 

}
```



   


   



      
    
      
            
# Class svgPathRenderer


The class has following internal singleton variables:
        
        
### <a name="svgPathRenderer_end"></a>svgPathRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgPathRenderer_refresh"></a>svgPathRenderer::refresh(obj, display, data)


```javascript


  var svgPath = obj.svgPath(),
    w = obj.w(),
    h = obj.h();
    
  
  
  var parser = obj.getSvgParser();
  /*
    parser.parse(svgPath);
    parser.makePathAbsolute();
    parser.fitPathInto( w, h );
  */
  
    // parser.drawPath( ctx, w, h); 
  var pathStr = parser.svgString();
 
  var surface = display.getSurface();
  var bgStyle = "";
  var r = Math.min(obj.w() / 2, obj.h() / 2);
  var aList = {
    d : pathStr
  };
  if (obj.bgcolor) {
    aList["fill"] = obj.bgcolor();
  }
  if (obj.alpha) {
    aList["fill-opacity"] = obj.alpha();
  }
  data.viewObj.attr(aList);
  data.viewG.attr({
    transform: obj.getLocalTransform().getSVGTransform()
  })
```

### <a name="svgPathRenderer_start"></a>svgPathRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    
    data.viewG = main.g();
    data.viewObj = data.viewG.path();
    data.childG = data.viewG.g();
    obj.draggableFor(data.viewObj, display);
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj);

}
```



   


   



      
    
      
            
# Class svgBezierObjectRenderer


The class has following internal singleton variables:
        
        
### <a name="svgBezierObjectRenderer_end"></a>svgBezierObjectRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgBezierObjectRenderer_refresh"></a>svgBezierObjectRenderer::refresh(obj, display, data)


```javascript

  var me = this;
  
  var svgPath = "",
      i = 0,
      cnt = 0;
  
  obj.forChildren( function(ch) {
     if(ch==obj) return; 
     if(cnt==0) {
         svgPath+="M "+ch.getX()+" "+ch.getY();
     } else {
         if(i==0) svgPath+=" C ";
         svgPath+= ch.getX()+" "+ch.getY()+" ";
         i++;
         if(i==3) i=0;
     }
     cnt++;
  });


  var w = obj.w(),
    h = obj.h();
  /*
    var parser = svgPathParser();
    parser.parse(svgPath);
    parser.makePathAbsolute();
    parser.fitPathInto( w, h );
    */
    
    // parser.drawPath( ctx, w, h); 
  var pathStr = svgPath;
 
  var surface = display.getSurface();
  var bgStyle = "";
  var r = Math.min(obj.w() / 2, obj.h() / 2);
  var aList = {
    d : pathStr
  };
  if (obj.bgcolor) {
    aList["fill"] = obj.bgcolor();
  }
  if (obj.alpha) {
    aList["fill-opacity"] = obj.alpha();
  }
  data.viewObj.attr(aList);
  data.viewG.attr({
    transform: obj.getLocalTransform().getSVGTransform()
  })
```

### <a name="svgBezierObjectRenderer_start"></a>svgBezierObjectRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    
    data.viewG = main.g();
    data.viewObj = data.viewG.path();
    data.childG = data.viewG.g();
    obj.draggableFor(data.viewObj, display);
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj);

}
```



   


   



      
    
      
            
# Class svgBezierHandleRenderer


The class has following internal singleton variables:
        
        
### <a name="svgBezierHandleRenderer_end"></a>svgBezierHandleRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgBezierHandleRenderer_refresh"></a>svgBezierHandleRenderer::refresh(obj, display, data)


```javascript
  var surface = display.getSurface();
  var bgStyle = "";
  var aList = {
    x: -1*obj.w()/2,
    y: -1*obj.h()/2,
    width: obj.w(),
    height: obj.h()
  };
  if (obj.bgcolor) {
    aList["fill"] = obj.bgcolor();
  }
  if (obj.alpha) {
    aList["fill-opacity"] = obj.alpha();
  }
  // obj.getViewMatrix(display.getCamera()).getSVGTransform()
  data.viewObj.attr(aList);
  data.viewG.attr({
    transform: obj.getLocalTransform().getSVGTransform()
  })
  
    var prevObj = obj.prev();
    if(prevObj.renderClass()=="bezierhandle") {
        prevObj = obj.next();
    }  

data.crossLine.attr({
    stroke : "cyan",
    x1 : prevObj.getX(),
    y1 : prevObj.getY(),
    x2 : obj.getX(),
    y2 : obj.getY()
});

  
  /*
             data.crossLine = drawLine(100,100,500,100, {bgColor:"cyan", weight:1});
            main.add( data.crossLine.getElem() );         
            
            main.add( icon.getElem() );
        }
    }, 
    function(obj, display, data) {
        
        var camera = display.getCamera(),
            surface = display.getSurface(),
            main = _e( display.getSurface().getDom() ),
            perspective = 1000;
            
        var docWidth = surface.getWidth(),
            docHeight = surface.getHeight();    
            
        var prevObj = obj.prev();
        if(prevObj.renderClass()=="pathhandle") {
            prevObj = obj.next();
        }
        
        rendM = obj.getRenderMatrix().createCopy();
        var sv = rendM.screenProjection({
            x: 0, y : 0, z:0, w:1
        }, {
            d : perspective,
            cx : docWidth/2,
            cy : docHeight/2
        });
        data.viewObj.moveTo( sv.x, sv.y, 15 );

        rendM = prevObj.getRenderMatrix().createCopy();
        var sv2 = rendM.screenProjection({
            x: 0, y : 0, z:0, w:1
        }, {
            d : perspective,
            cx : docWidth/2,
            cy : docHeight/2
        });
        data.crossLine.moveTo( sv.x, sv.y, sv2.x, sv2.y);
  */
```

### <a name="svgBezierHandleRenderer_start"></a>svgBezierHandleRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

var main = surface.getSvg();
var p = obj.displayParent();

if (p) {
  var pData = p.getRenderData();
  if (pData.viewG) {
    main = pData.childG;
  }
}

data.viewG = main.g();
data.viewObj = data.viewG.rect();

data.crossLine = data.viewG.parent().parent().line().attr({
    stroke : "cyan",
    x1 : 0,
    x2 : 0,
    y1 : 0,
    y2 : 0
});

data.childG = data.viewG.g();
obj.draggableFor(data.viewObj, display);

obj.domMVC(data.childG);

     obj.matchDomPosition( main, data.viewG, obj);
//    data.viewG._index = obj.indexOf();



}
```



   


   



      
    
      
            
# Class svgBezierPointRenderer


The class has following internal singleton variables:
        
        
### <a name="svgBezierPointRenderer_end"></a>svgBezierPointRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgBezierPointRenderer_refresh"></a>svgBezierPointRenderer::refresh(obj, display, data)


```javascript
var surface = display.getSurface();
var bgStyle = "";
var r = Math.min(obj.w() / 2, obj.h() / 2);
var aList = {
cx: 0,
cy: 0,
r: r
};
if (obj.bgcolor) {
aList["fill"] = obj.bgcolor();
}
if (obj.alpha) {
aList["fill-opacity"] = obj.alpha();
}
data.viewObj.attr(aList);
data.viewG.attr({
transform: obj.getLocalTransform().getSVGTransform()
})
```

### <a name="svgBezierPointRenderer_start"></a>svgBezierPointRenderer::start(obj, display, data)


```javascript

var surface = display.getSurface();
if (!data.viewObj) {

    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    
    data.viewG = main.g();
    data.viewObj = data.viewG.circle();
    data.childG = data.viewG.g();
    obj.draggableFor(data.viewObj, display);
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj);

}
```



   


   



      
    
      
            
# Class svgImageRenderer


The class has following internal singleton variables:
        
        
### <a name="svgImageRenderer_end"></a>svgImageRenderer::end(obj, display, data)


```javascript
data.viewG.remove();
data.viewG = null;
data.viewObj = null;
```

### <a name="svgImageRenderer_refresh"></a>svgImageRenderer::refresh(obj, display, data)


```javascript
  if(!data._imageObj) return;
  if(!data._width) return;

  var surface = display.getSurface();
  var aList = {};

  if (obj.alpha) {
     aList["opacity"] = obj.alpha();
  }
/*
    data.viewObj = data.viewG.image({
        "xlink:href" : obj.url(),
        x : 0, y : 0, height : 200, width:200
    });
*/
// data.viewObj 


  data.viewObj.attr(aList);
  data.viewObj.attr({
     "xlink:href" : obj.url(),
     "width" : obj.w(),
     "height" : obj.w() * ( data._height / data._width )
  })  
  data.viewG.attr({
     "transform": obj.getLocalTransform().getSVGTransform()
  })
```

### <a name="svgImageRenderer_start"></a>svgImageRenderer::start(obj, display, data)


```javascript
// <image xlink:href="firefox.jpg" x="0" y="0" height="50px" width="50px"/>

if(!data._imageObj) {
    var imageObj = new Image();
    imageObj.onload = function() {
      data._imageObj = imageObj;
      data._width = data._imageObj.width;
      data._height = data._imageObj.height;
      // context.drawImage(imageObj, 69, 50);
    };
    imageObj.src = obj.url();
}

var surface = display.getSurface();
if (!data.viewObj) {

    var main = surface.getSvg();
    var p = obj.displayParent();
    
    if (p) {
      var pData = p.getRenderData();
      if (pData.viewG) {
        main = pData.childG;
      }
    }
    /*
s.g().image({
    "xlink:href" : "/static/s1.png",
    x : 0, y : 0, height : 200, width:200
});
    
    */
    data.viewG = main.g();
    data.viewObj = data.viewG.image({
        "xlink:href" : obj.url(),
        x : 0, y : 0, height : obj.w(), width:obj.h()
    });
    data.childG = data.viewG.g();
    obj.draggableFor(data.viewObj, display);
    
    obj.domMVC(data.childG);
    
    obj.matchDomPosition( main, data.viewG, obj); 

}
```



   


   



      
    



      
    
      
            
# Class surfaceDomSVGLayer


The class has following internal singleton variables:
        
* _renderFns
        
* _sfaceCnt
        
        
### <a name="surfaceDomSVGLayer_getHoverLayer"></a>surfaceDomSVGLayer::getHoverLayer(t)


```javascript

```

### <a name="surfaceDomSVGLayer_getSvg"></a>surfaceDomSVGLayer::getSvg(t)


```javascript
return this._svg;
```

### surfaceDomSVGLayer::constructor( elem, width, height )

```javascript

this._dom = elem._dom;
this._width = width;
this._height = height;

this._svg = elem;

if(!this._renderFns) {
    this._renderFns = {};
}
```
        


   


   



      
    
      
            
# Class svgPathParser


The class has following internal singleton variables:
        
* _parsedData
        
        
### <a name="svgPathParser_drawPath"></a>svgPathParser::drawPath(ctx, w, h)


```javascript
var _firstX, _firstY, x, y;
ctx.beginPath();
this._all.forEach(function(cmd) {
   
   if(cmd.name =="M") {
       x = cmd.points[0];
       y = cmd.points[1];
       ctx.moveTo( x,y );
   }
   
   if(cmd.name =="m") {
       x = x + cmd.points[0];
       y = y + cmd.points[1];
       ctx.moveTo( x,y );
   }        
   
   if(cmd.name=="q") {
       for(var s=0; s<cmd.points.length;s+=4) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];
           //x=x0; y=y0;
           var x1 = x + p[s+2],
               y1 = y + p[s+3];
           x=x1; y=y1;
           ctx.quadraticCurveTo( x0,y0,x1,y1,x2,y2 );
       }
   }
   
   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="Q") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=4) {
           ctx.quadraticCurveTo( p[s+0],p[s+1],p[s+2],p[s+3]);
       }
   }
   
   if(cmd.name=="c") {
       for(var s=0; s<cmd.points.length;s+=6) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];
           //x=x0; y=y0;
           var x1 = x + p[s+2],
               y1 = y + p[s+3];
           // x=x1; y=y1;
          var x2 = x + p[s+4],
               y2 = y + p[s+5];
           x=x2; y=y2;
           ctx.bezierCurveTo( x0,y0,x1,y1,x2,y2 );
       }
   }
   
   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="C") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=6) {
           ctx.bezierCurveTo( p[s+0],p[s+1],p[s+2],p[s+3],p[s+4],p[s+5] );
       }
   }           
   if(cmd.name=="l") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];  
           x=x0; y=y0;
           ctx.lineTo( x0,y0 );
       }
   }
   
   if(cmd.name=="H") {
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var x0 = p[s+0];  
           x=x0; 
           ctx.lineTo( x0, y );
       }
   }    
   
   if(cmd.name=="V") {
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var y0 = p[s+0];  
           y=y0; 
           ctx.lineTo( x, y0 );
       }
   }
   

   if(cmd.name=="L") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = p[s+0],
               y0 = p[s+1];  
           x=x0; y=y0;
           ctx.lineTo( x0,y0 );
       }
   }           
   
   if(cmd.name=="z") {
       ctx.closePath();
   }
})
     
   
```

### <a name="svgPathParser_findDimensions"></a>svgPathParser::findDimensions()


```javascript

if(this._limits) return this._limits;

var _firstX, _firstY;
var _minX, _minY, _maxX, _maxY, x,y;

var limits = function(x,y) {

    if(typeof(_minX) == "undefined") {
       _minX = x;
       _maxX = x;
       _minY = y;
       _maxY = y;
    }
    _minX = Math.min(_minX, x);
    _minY = Math.min(_minY, y);
    _maxX = Math.max(_maxX, x);
    _maxY = Math.max(_maxY, y);            

}

this._all.forEach(function(cmd) {

    if(cmd.name =="M") {
       
       x = cmd.points[0];
       y = cmd.points[1];
       
       limits(x,y);
             
    }
    
    if(cmd.name =="m") {
       
       x = x + cmd.points[0];
       y = y + cmd.points[1];
       limits(x,y);
       
    }   
    
    if(cmd.name=="c") {
       for(var s=0; s<cmd.points.length;s+=6) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];
           //x=x0; y=y0;
           var x1 = x + p[s+2],
               y1 = y + p[s+3];
           // x=x1; y=y1;
          var x2 = x + p[s+4],
               y2 = y + p[s+5];
               
           limits(x0,y0);
           limits(x1,y1);
           limits(x2,y2);
           x=x2; y=y2;
           
       }
    }
    
    if(cmd.name=="C") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=6) {
           limits(p[s+0],p[s+1]);
           limits(p[s+2],p[s+3]);
           limits(p[s+4],p[s+5]);
       }
    }           
    if(cmd.name=="l") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];  
           x=x0; y=y0;
           limits(x,y);
       }
    }
    
    if(cmd.name=="L") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = p[s+0],
               y0 = p[s+1];  
           x=x0; y=y0;
           limits(x,y);
       }
    }           
});

// NOTE: in these SVG photos created by the potrace the y-axis
// is reversed, so the maxY is actually the minY 
this._limits = [_minX, _minY, _maxX, _maxY];
return this._limits;

```

### <a name="svgPathParser_fitPathInto"></a>svgPathParser::fitPathInto(w, h)


```javascript

var dim = this.findDimensions();

var allIn = true;
for(var i=0; i<4; i++) {
   if(dim[i]<0 || dim[i]>w) allIn = false;
}

var drawW = Math.abs( dim[2] - dim[0] ),
    drawH = Math.abs( dim[3] - dim[1] );
   
var flipY = false;

if(Math.abs( dim[3]) < Math.abs( dim[1]) ) {
   flipY = true;
}
   
var scale1 = w / drawW,
   scale2 = h / drawH,
   transX = -dim[0],
   transY = -dim[1];

var scaleX = Math.min(scale1, scale2),
   scaleY = scaleX;
   

if(flipY) {
   scaleY = -scaleY;
   transY = -dim[3]; // for example if -100 => +100
}

var tx = function(x) {
   return (x + transX)*scaleX;
}
var ty = function(y) {
   return (y + transY)*scaleY;
}

this._all.forEach(function(cmd) {
   
   if(cmd.name =="M") {
       
       cmd.points[0] = tx( cmd.points[0] );
       cmd.points[1] = ty( cmd.points[1] );
   }
   if(cmd.name =="m") {
       cmd.points[0] *= scaleX;
       cmd.points[1] *= scaleY;
       
   }        

   if(cmd.name =="L") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           p[s+0] = tx(p[s+0]); 
           p[s+1] = ty(p[s+1]);
       }
   }
   
   if(cmd.name=="c") {
       for(var s=0; s<cmd.points.length;s+=6) {
           var p = cmd.points;
           p[s+0] *= scaleX;
           p[s+2] *= scaleX;
           p[s+4] *= scaleX;
           p[s+1] *= scaleY;
           p[s+3] *= scaleY;
           p[s+5] *= scaleY;                   
       }
   }
   
   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="C") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=6) {
           p[s+0] = tx(p[s+0]); 
           p[s+2] = tx(p[s+2]); 
           p[s+4] = tx(p[s+4]); 
           p[s+1] = ty(p[s+1]); 
           p[s+3] = ty(p[s+3]); 
           p[s+5] = ty(p[s+5]); 
       }
   }      
   
   if(cmd.name=="Q") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=4) {
           p[s+0] = tx(p[s+0]); 
           p[s+2] = tx(p[s+2]); 
           p[s+1] = ty(p[s+1]); 
           p[s+3] = ty(p[s+3]); 
       }
   }            
   
   if(cmd.name=="l") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           p[s+0] *= scaleX;
           p[s+1] *= scaleY;    
       }
   }
   
  
});

this._limits = null;


```

### <a name="svgPathParser_forCmds"></a>svgPathParser::forCmds(fn)


```javascript
this._all.forEach(fn);
```

### <a name="svgPathParser_fromBezierArray"></a>svgPathParser::fromBezierArray(list)


```javascript
var x,y,i,plen = list.length;
var target = this._all;
this._all = [];

for(var i=0; i<plen;i++) {
   
   var bez = list[i]; 
   if(i==0) {
       var c = {
           name : "M",
           points : [
            bez.point_x(0), bez.point_y(0) 
           ]
       };
       this._all.push(c);               
   }
   var c = {
       name : "C",
       points : [
        bez.point_x(1), bez.point_y(1), 
        bez.point_x(2), bez.point_y(2), 
        bez.point_x(3), bez.point_y(3)
       ]
   };
   this._all.push(c);
}
this.saveToOriginals();
          
```

### <a name="svgPathParser_getCommands"></a>svgPathParser::getCommands(t)


```javascript
return this._all;
```

### <a name="svgPathParser_getPath"></a>svgPathParser::getPath(i)


```javascript

return this._all[i];
```

### <a name="svgPathParser_getSegmentCount"></a>svgPathParser::getSegmentCount(t)


```javascript

var last = this._all.length;
if( this._all[last-1].name == "z" ) last--;

return last;
```

### <a name="svgPathParser_getSubPaths"></a>svgPathParser::getSubPaths(t)


```javascript
return this._subPaths;
```

### svgPathParser::constructor( w, h, intoDom )

```javascript
this._activeCmd = null;
this._all = [];
this._stringLeft = "";

this._original = null;

this._x = 0;
this._y = 0;

if(!_parsedData) {
    _parsedData = {};
}
```
        
### <a name="svgPathParser_initCmd"></a>svgPathParser::initCmd(n)


```javascript
this._activeCmd = {
   name : n,
   points : []
};
this._all.push(this._activeCmd);
return this._activeCmd;
   
```

### <a name="svgPathParser_inverse"></a>svgPathParser::inverse(t)


```javascript
var all = this.originals();

var point = { x: 0, y:0 };

var x,y,i,plen = all.length;

this._all.reverse();

var target = this._all;
var all = this._all;

var newCmds = [];

var getPrevPoints = function(currCmd, prevCmd) {
      var res = [];
      var n = (currCmd.points.length/2),
          i = currCmd.points.length-4;
      while(n>0) {
          if(n==1) {
            if(!prevCmd) return res;
            i = prevCmd.points.length - 2;
            res.push(prevCmd.points[i]);
            res.push(prevCmd.points[i+1]);
          } else {
            res.push(currCmd.points[i]);
            res.push(currCmd.points[i+1]);  
            i-=2;
          }
          n--;
      }
    return res;
};

if(all[0].name=="z") {
    all.shift();
    // plen--;
}

for(var i=0; i<plen;i++) {
   
   var cmd = all[i],
       tCmd = all[i],
       nextCmd = all[i+1],
       prevCmd;
       
   if(!cmd) break;
   if(i>0) prevCmd = all[i-1];
   
   if(i==0) {
        var ii = cmd.points.length-2;
        var cc = { name : "M", points : [
                cmd.points[ii], cmd.points[ii+1]
            ] };
        newCmds.push(cc);
   } else {
        var cc = { name : prevCmd.name, points : getPrevPoints(prevCmd, cmd) };   
        newCmds.push(cc);
   }
}

var cc = { name : "z", points : [] };
newCmds.push(cc);

// console.log(newCmds);

this._all = newCmds;
```

### <a name="svgPathParser_makePathAbsolute"></a>svgPathParser::makePathAbsolute()


```javascript


var _firstX, _firstY;
var x,y,
    lastBx, lastBy,
    bNoBx = true;
    
var firstSmoothPoint = function() {
    if(bNoBx) {
        lastBx = x;
        lastBy = y;
    }
    var dx = x - lastBx,
        dy = y - lastBy;
    return {
        x : x + dx,
        y : y + dy
    };
}
this._all.forEach(function(cmd) {

   if(cmd.name =="M") {
       x = cmd.points[0];
       y = cmd.points[1];
       bNoBx = true;
   }
   
   if(cmd.name =="L") {
       x = cmd.points[0];
       y = cmd.points[1];
       bNoBx = true;
   }   
   
   if(cmd.name =="m") {
       
       x = x + cmd.points[0];
       y = y + cmd.points[1];
       
       cmd.points[0] = x;
       cmd.points[1] = y;
       cmd.name = "M";
       bNoBx = true;
   }          
   
   if(cmd.name=="q") {
       for(var s=0; s<cmd.points.length;s+=4) {
           var p = cmd.points;
           
           p[s+0] = x + p[s+0];
           p[s+1] = y + p[s+1];
           p[s+2] = x + p[s+2];
           p[s+3] = y + p[s+3];
           x = p[s+2];
           y = p[s+3];
           cmd.name = "Q";
       }
       bNoBx = true;
   }   
   if(cmd.name=="C") {
       var p = cmd.points;
       lastBx = p[2];
       lastBy = p[3];   
       
       x = p[4];
       y = p[5];      
       bNoBx = false;
   }
   if(cmd.name=="c") {
       for(var s=0; s<cmd.points.length;s+=6) {
           var p = cmd.points;
           
           p[s+0] = x + p[s+0];
           p[s+1] = y + p[s+1];
           p[s+2] = x + p[s+2];
           p[s+3] = y + p[s+3];
           p[s+4] = x + p[s+4];
           p[s+5] = y + p[s+5];
           x = p[s+4];
           y = p[s+5];
           lastBx = p[s+2];
           lastBy = p[s+3];
           cmd.name = "C";
       }
       bNoBx = false;
   }
   
   if(cmd.name=="S") {
       var p = cmd.points;
       var first = firstSmoothPoint();
       var newPoints = [];
       newPoints[0] = first.x;
       newPoints[1] = first.y;
       newPoints[2] = p[0];
       newPoints[3] = p[1];
       newPoints[4] = p[2];
       newPoints[5] = p[3];
       x = newPoints[4];
       y = newPoints[5];
       lastBx = newPoints[2];
       lastBy = newPoints[3];     
       cmd.name = "C";
       cmd.points = newPoints;
       bNoBx = false;
   }
   if(cmd.name=="s") {
       var p = cmd.points;
       var first = firstSmoothPoint();
       var newPoints = [];
       newPoints[0] = first.x;
       newPoints[1] = first.y;
       newPoints[2] = x+p[0];
       newPoints[3] = y+p[1];
       newPoints[4] = x+p[2];
       newPoints[5] = y+p[3];
       x = newPoints[4];
       y = newPoints[5];
       lastBx = newPoints[2];
       lastBy = newPoints[3];     
       cmd.name = "C";
       cmd.points = newPoints;
       bNoBx = false;
   }   
   
   if(cmd.name=="h") {
       bNoBx = true;
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var x0 = x + p[s+0];  
           x=x0;
           p[s+0] = x0;
           cmd.points = [x0,y];
           cmd.name = "L";
           return;
       }
   }    
   
   if(cmd.name=="H") {
       bNoBx = true;
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var x0 = p[s+0];  
           x=x0;
           p[s+0] = x0;
           cmd.points = [x0,y];
           cmd.name = "L";
           return;
       }
   }    
   
   if(cmd.name=="V") {
       bNoBx = true;
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           //console.log("--- V ----");
           //console.log("Point cnt ", cmd.points.length);
           //console.log(p, "y : ",y, " delta :  ",p[s+0]);
           var y0 = p[s+0];  
           y=y0;
           //console.log("After add : ",y, "and y0 = ", y0);
           cmd.points = [x,y0];
           cmd.name = "L";
           //console.log(cmd);
           return;
       }
   }
   
    if(cmd.name=="v") {
       bNoBx = true;
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var y0 = y + p[s+0];  
           y=y0;
           cmd.points = [x,y0];
           cmd.name = "L";
           return;
       }
   }   
   
  
 
   if(cmd.name=="l") {
       bNoBx = true;
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];  
           x=x0; y=y0;
           p[s+0] = x0;
           p[s+1] = y0;
           cmd.name = "L";
       }
   }
})


```

### <a name="svgPathParser_normalize"></a>svgPathParser::normalize(width, height)


```javascript
if(!width) width = 800;
if(!height) height = 800;
this.makePathAbsolute();
this.fitPathInto(width,height);
   
```

### <a name="svgPathParser_originals"></a>svgPathParser::originals()


```javascript

if(!this._original) {
   this._original = JSON.parse( JSON.stringify( this._all ) );
}
return this._original;
   
```

### <a name="svgPathParser_parse"></a>svgPathParser::parse(str)


```javascript
/*var old;
if(old = _parsedData[str]) {
    this._all = JSON.parse( old );
    return;
}*/

this._activeCmd = null;
this._all = [];
this._stringLeft = "";

this._original = null;

this._x = 0;
this._y = 0;
  
this._usedCommands = {};
if(!str) str = "M25.979,12.896 L 5.979,12.896,5.979,19.562,25.979,19.562z";
var c,
   leftString = str;
var lastLen = 0;
var maxCnt = 10000;


this._subPaths = str.split("M");
//console.log("Sub paths");
//console.log(this._subPaths);

this._subIndex = 0;

while(leftString = this.popCommand(leftString)) {
   if(leftString.length==0) break;
   if(leftString.length==lastLen) break;
   
   if(maxCnt-- < 0 ) break;
   
   lastLen = leftString.length;
}

// _parsedData[str] = JSON.stringify( this._all );

// console.log("Used commands", this._usedCommands);
return this._all;
   
```

### <a name="svgPathParser_path"></a>svgPathParser::path()


```javascript

return this._all;
   
```

### <a name="svgPathParser_pathFunction"></a>svgPathParser::pathFunction(t)


```javascript
/*
this.initBezier();
var ntCnt = this.getSegmentCount();
var t1 = ntCnt * t;
var t_index = Math.floor( t1 );
var seg = this.getSegmentNro(t_index);
var sub_t = t1 - t_index;

// for example ntCnt = 10
// t = 9,5
var stepLen = 1 / ntCnt,        // 0,1
    nowStep = t_index / ntCnt,  // 0,9
    totStep = t,                // 0,95
    remStep = totStep - nowStep, // 0,05
    relStep = remStep / stepLen; // 0,05 / 0,1 = 0,5

var bez = seg.bezier();
// console.log("Rel step "+relStep);
pathFnData.x = bez.x(relStep);
pathFnData.y = bez.y(relStep);
var nn = bez.tangent(relStep, true);

pathFnData.normal.x = nn.x;
pathFnData.normal.y = nn.y;

fn(pathFnData);
*/
```

### <a name="svgPathParser_popCommand"></a>svgPathParser::popCommand(str)


```javascript


//console.log("popCommand");
//console.log(str);

str = str.trim();

var cmdStr = str.charAt(0),
   cmd = null;

if(cmdStr=="M") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}

if(cmdStr=="m") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}  

if(cmdStr=="Q") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}       

if(cmdStr=="q") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}       

if(cmdStr=="S") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}       

if(cmdStr=="s") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}       

if(cmdStr=="C") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}       

if(cmdStr=="c") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}

if(cmdStr=="H") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}         

if(cmdStr=="h") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}         

if(cmdStr=="V") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}         

if(cmdStr=="v") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}         

if(cmdStr=="L") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}         

if(cmdStr=="l") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}      

if(cmdStr=="Z") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}          

if(cmdStr=="z") {
   cmd = this.initCmd(cmdStr);
   str = str.substring(1);
}       

// Find the points....
if(cmd) {
   
   this._usedCommands[cmdStr] = "true";
   str = str.trim();
   
   var ok = true;
   
   while(ok && str.length>0) {
       
       var firstChar = str.charAt(0);
       if(firstChar==",") {
           str = str.substring(1);
           str = str.trim();
       }
       var allowed = ["-","1","2","3","4","5","6","7","8","9","0", "."];
       var collect = "",
           minusCnt = 0;
       
       while( allowed.indexOf( str.charAt(0))>=0) {
           if(str.charAt(0)=="-") {
               minusCnt++;
               if(minusCnt>1) {
                   break;
               }
           }
           collect = collect + str.charAt(0);
           str = str.substring(1);
           minusCnt = 1;
       }
       
       // we have a number
       if(collect.length>0) {
          //console.log("Found number "+collect);
          cmd.points.push( parseFloat( collect ));    
       } else {
          // nothing more there...
          //console.log("Did not find number from "+str);
          break;
       }
       str = str.trim();
   }
}

if(!cmd) {
   console.error("No command found for");
   console.error(str);
}

this._activeCmd = cmd;
this._stringLeft = str;

return str;


```

### <a name="svgPathParser_relativePosition"></a>svgPathParser::relativePosition(t)


```javascript

// perhaps faster would be to manage the bezier array directly...
var list = this.toBezierArray();
var ntCnt = list.length;

var t1 = ntCnt * t;
var t_index = Math.floor( t1 );

if(t_index>=ntCnt) t_index = ntCnt-1;
if(t_index<0) t_index = 0;

var bez = list[t_index];
var sub_t = t1 - t_index;

// for example ntCnt = 10
// t = 9,5
var stepLen = 1 / ntCnt,        // 0,1
    nowStep = t_index / ntCnt,  // 0,9
    totStep = t,                // 0,95
    remStep = totStep - nowStep, // 0,05
    relStep = remStep / stepLen; // 0,05 / 0,1 = 0,5

var pathFnData = { x : 0, y : 0, normal : { x : 0, y : 0} };
pathFnData.x = bez.x(relStep);
pathFnData.y = bez.y(relStep);
var nn = bez.tangent(relStep, true);
pathFnData.normal.x = nn.x;
pathFnData.normal.y = nn.y;

return pathFnData;
```

### <a name="svgPathParser_replacePartWith"></a>svgPathParser::replacePartWith(index, pathStr, invert)


```javascript

var createQuatPath2 = function(str, invert) {
    var parser = svgPathParser();
    parser.parse(str);
    parser.makePathAbsolute();
    var list = parser.toBezierArray();
    parser.fromBezierArray( list );
    if(invert) parser.inverse();
    var qPath = parser.toQuaternionPath();
    
    var createQuatPath = function( startPoint, refVector ) {
        
        var iter = pathIterator( qPath );
        var ep = iter.endPoint();
        var str = "M 0 0 "+iter.toSvgPath();
        var sp = startPoint;
        /*
        var refVector = {
            x : -100,
            y : 100
        };*/
        
        if(refVector.x==0 && refVector.y==0) return "";
        
        var len = Math.sqrt(ep.x*ep.x + ep.y*ep.y),
            refLen = Math.sqrt(refVector.x*refVector.x + refVector.y*refVector.y),
            scale = refLen / len;
        if(len==0) return str;
        var math = jsVectors();
        var angle = math.angleBetween( ep, refVector );
        // var angle = math.angleBetween(  refVector, ep );
        var str = iter.toSvgPath(sp, quaternion().rotate(angle), function(p) {
            p.d = p.d*scale;
            return p;
        });
        return str;
    }
    return createQuatPath;
}

var ppp = this.getPath( index );
ppp.replaceFunction = createQuatPath2(pathStr, invert);

```

### <a name="svgPathParser_saveToOriginals"></a>svgPathParser::saveToOriginals()


```javascript
this._original = JSON.parse( JSON.stringify( this._all ) );
   
```

### <a name="svgPathParser_scaleFactor"></a>svgPathParser::scaleFactor(w, h)


```javascript

       var dim = this.findDimensions();
       
       var drawW = Math.abs( dim[2] - dim[0] ),
           drawH = Math.abs( dim[3] - dim[1] );
           
       var scale1 = w / drawW,
           scale2 = h / drawH;
       var x,y;
      
       var scale = Math.min(scale1, scale2);

       return scale; 
   
```

### <a name="svgPathParser_svgString"></a>svgPathParser::svgString(t)


```javascript
var _firstX, _firstY, x, y,
    str = "";

this._all.forEach(function(cmd) {
   
   if(cmd.name =="M") {

       x = cmd.points[0];
       y = cmd.points[1];
       str+="M"+x+","+y+" ";
   }
   
   if(cmd.name =="m") {
       x = x + cmd.points[0];
       y = y + cmd.points[1];
       str+="M"+x+","+y+" ";
   }        
   
   if(cmd.name=="q") {

       str+="Q";
       for(var s=0; s<cmd.points.length;s+=4) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];
           //x=x0; y=y0;
           var x1 = x + p[s+2],
               y1 = y + p[s+3];
           x=x1; y=y1;
           str+=x0+","+y0+" "+x1+","+y1+" ";
       }
   }
   
   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="Q") {
       var p = cmd.points,
           len = cmd.points.length;
       str+="Q";
       for(var s=0; s<len;s+=4) {
           var x0 = p[s+0],
               y0 = p[s+1];
           var x1 = p[s+2],
               y1 = p[s+3];
           x=x1; y=y1;
           str+=x0+","+y0+" "+x1+","+y1+" ";
       }
   }   
   
   if(cmd.name=="c") {
       str+="C";
       for(var s=0; s<cmd.points.length;s+=6) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];
           //x=x0; y=y0;
           var x1 = x + p[s+2],
               y1 = y + p[s+3];
           // x=x1; y=y1;
          var x2 = x + p[s+4],
               y2 = y + p[s+5];
           x=x2; y=y2;
           str+=x0+","+y0+" "+x1+","+y1+" "+x2+","+y2+" ";
       }
   }
   
   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="C") {
       
       var p = cmd.points,
           len = cmd.points.length;
           
       if(cmd.replaceFunction) {
           var sp = {
               x : x,
               y : y
           };
           for(var s=0; s<len;s+=6) {
               // str+=p[s+0]+","+p[s+1]+" "+p[s+2]+","+p[s+3]+" "+p[s+4]+","+p[s+5]+" ";
               x = p[s+4];
               y = p[s+5];
           }           
           var ref = {
               x : x - sp.x,
               y : y - sp.y
           }
           var strR = cmd.replaceFunction( sp, ref );
           console.log("The inserted path ", strR);
           str+=" "+strR+" ";
       } else {     
           str+="C";
           for(var s=0; s<len;s+=6) {
               str+=p[s+0]+","+p[s+1]+" "+p[s+2]+","+p[s+3]+" "+p[s+4]+","+p[s+5]+" ";
               x = p[s+4];
               y = p[s+5];
           }
       }
   }           
   if(cmd.name=="l") {
       str+="L";
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = x + p[s+0],
               y0 = y + p[s+1];  
           x=x0; y=y0;
           str+=x0+","+y0+" ";
       }
   }
   
   if(cmd.name=="H") {
       str+="L";
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var x0 = p[s+0];  
           x=x0; 
           // ctx.lineTo( x0, y );
           str+=x0+","+y+" ";
       }
   }    
   
   if(cmd.name=="V") {
       str+="L";
       for(var s=0; s<cmd.points.length;s++) {
           var p = cmd.points;
           var y0 = p[s+0];  
           y=y0; 
           // ctx.lineTo( x, y0 );
           str+=x+","+y0+" ";
       }
   }
   

   if(cmd.name=="L") {
       
       if(cmd.replaceFunction) {
           var sp = {
               x : x,
               y : y
           };
           for(var s=0; s<cmd.points.length;s+=2) {
               var p = cmd.points;
               var x0 = p[s+0],
                   y0 = p[s+1];  
               x=x0; y=y0;
           }         
           var ref = {
               x : x - sp.x,
               y : y - sp.y
           }
           var strR = cmd.replaceFunction( sp, ref );
           console.log("The inserted path ", strR);
           str+=" "+strR+" ";
       } else {       
           str+="L";
           for(var s=0; s<cmd.points.length;s+=2) {
               var p = cmd.points;
               var x0 = p[s+0],
                   y0 = p[s+1];  
               x=x0; y=y0;
               // ctx.lineTo( x0,y0 );
               str+=x0+","+y0+" ";
           }
       }
   }           
   
   if(cmd.name=="z") {
       str+="z";
   }
});
return str;
     
   
```

### <a name="svgPathParser_toBezierArray"></a>svgPathParser::toBezierArray(t)


```javascript
var _firstX, _firstY, x, y,
    str = "",
    res = [];
this._all.forEach(function(cmd) {
   
   if(cmd.name =="M") {
       x = cmd.points[0];
       y = cmd.points[1];
   }

   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="Q") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=4) {
           var x0 = p[s+0],
               y0 = p[s+1];
           var x1 = p[s+2],
               y1 = p[s+3];
           
           var bc = new jsBezierCurve();
           bc.fromQuadCurve({ x : x, y : y},{ x : x0, y : y0},{ x : x1, y : y1});
           res.push(bc);
           x=x1; y=y1;
       }
   }
   
   // Not relative coordinates... the algo is much simpler here...
   if(cmd.name=="C") {
       var p = cmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=6) {
           
           var x0 = p[s+0],
               y0 = p[s+1];
           var x1 = p[s+2],
               y1 = p[s+3];
           var x2 = p[s+4],
               y2 = p[s+5];       
           var bc = new jsBezierCurve();
           bc.fromPoints({ x : x, y : y},{ x : x0, y : y0},{ x : x1, y : y1}, { x : x2, y : y2});
           res.push(bc);
           x=x2; y=y2;
       }
   }           


   if(cmd.name=="L") {
       str+="L";
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points;
           var x0 = p[s+0],
               y0 = p[s+1];  
           var bc = new jsBezierCurve();
           bc.fromLine({ x : x, y : y},{ x : x0, y : y0});
           res.push(bc);               
               
           x=x0; y=y0;
       }
   }           

});
return res;
     
   
```

### <a name="svgPathParser_toQuaternionPath"></a>svgPathParser::toQuaternionPath(t)


```javascript

var isFirstPoint = true;
var pv = {
    x : 0,
    y : 0
};
var dv = {
    x : 100,
    y : 0
};
var lastDv = {
    x : 100,
    y : 0
};

var matLib = jsVectors();

var cmdList = [];

// {"name":"L","points":[374.29469458855607,171.03419547847162]}
this.forCmds( function(c) {
   //  main.div().text(JSON.stringify(c));
    var v = {};
    var cmd = { cmd : c.name, path : [] };
    
    var pickQuat = function(x,y) {

        dv.x = x - pv.x;
        dv.y = y - pv.y;
        var dist = Math.sqrt( dv.x*dv.x + dv.y*dv.y );
        if(dist==0) {
            dv.x += 0.2;
            dv.y += 0.2;
            x += 0.02;
            y += 0.02;
            dist = Math.sqrt( dv.x*dv.x + dv.y*dv.y );
        }
        var r = matLib.angleBetween( lastDv, dv );
        

        var q = quaternion();
        q.setFromAxisRotation({
            x : 0,
            y : 0,
            z : 1
        }, r);   
        
        if(!isFirstPoint) cmd.path.push({ q : q, d : dist});
        isFirstPoint = false;
        pv.x = x;
        pv.y = y;
        lastDv.x = dv.x;
        lastDv.y = dv.y;        
        
    }
    
    if(c.name=="M") {
        pickQuat( c.points[0], c.points[1]);
    }    
    if(c.name=="L") {
        pickQuat( c.points[0], c.points[1]);
    }
    if(c.name=="Q") {
        pickQuat( c.points[0], c.points[1]);
        pickQuat( c.points[2], c.points[3]);
    }    
    if(c.name=="C") {
        pickQuat( c.points[0], c.points[1]);
        pickQuat( c.points[2], c.points[3]);
        pickQuat( c.points[4], c.points[5]);
    }
    if(cmd.path.length) cmdList.push(cmd);
});

return cmdList;
```

### <a name="svgPathParser_transformPoints"></a>svgPathParser::transformPoints(fn)


```javascript

// creates a backup of the "all" and then uses the "all" as target
var all = this.originals();
var point = { x: 0, y:0 };
var x,y,i,plen = all.length;
var target = this._all;

for(var i=0; i<plen;i++) {
    
    var cmd = all[i],
       tCmd = this._all[i];
    
    if(!cmd) return;
    
    if(cmd.name =="M") {
       point.x  = cmd.points[0];
       point.y  = cmd.points[1];
       fn(point);
       tCmd.points[0] = point.x;
       tCmd.points[1] = point.y;
       
    }
    
    if(cmd.name=="Q") {
       var p = cmd.points,
           tp = tCmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=4) {
           
           point.x  = p[s+0], point.y  = p[s+1];     
           fn(point);
           tp[s+0] = point.x, tp[s+1] = point.y;
    
           point.x  = p[s+2], point.y  = p[s+3];     
           fn(point);
           tp[s+2] = point.x, tp[s+3] = point.y;
           
       }
    }
    
    
    if(cmd.name=="C") {
       var p = cmd.points,
           tp = tCmd.points,
           len = cmd.points.length;
       for(var s=0; s<len;s+=6) {
           
           point.x  = p[s+0], point.y  = p[s+1];     
           fn(point);
           tp[s+0] = point.x, tp[s+1] = point.y;
    
           point.x  = p[s+2], point.y  = p[s+3];     
           fn(point);
           tp[s+2] = point.x, tp[s+3] = point.y;
           
           point.x  = p[s+4], point.y  = p[s+5];     
           fn(point);
           tp[s+4] = point.x, tp[s+5] = point.y;                   
       }
    }           
    if(cmd.name=="L") {
       for(var s=0; s<cmd.points.length;s+=2) {
           var p = cmd.points,
               tp = tCmd.points;
           point.x  = p[s+0], point.y  = p[s+1];     
           fn(point);
           tp[s+0] = point.x, tp[s+1] = point.y;
       }
    }
    
}      
    
    
    

```



   
    
    
    
    
    
    
    
    


   
      
            
# Class jsVectors


The class has following internal singleton variables:
        
* projectionMatrix
        
* jVect
        
* iVect
        
* pBase
        
* tn1
        
* nv1
        
* barCoeffs
        
* deVector
        
        
### <a name="jsVectors_add"></a>jsVectors::add(v1, v2)


```javascript

    v1.x = v1.x + v2.x;
    v1.y = v1.y + v2.y;
    
```

### <a name="jsVectors_angleBetween"></a>jsVectors::angleBetween(v1, v2)


```javascript

var n1 = this.normalize( { x : v1.x, y : v1.y } );
var n2 = this.normalize( { x : v2.x, y : v2.y } );

var cp = this.crossProd( n1, n2 );
var dp = this.dotProd(n1, n2 );

var a = Math.acos( dp );
if(cp<0) a = a*-1; // other side...
return a;
    
```

### <a name="jsVectors_calc_cat"></a>jsVectors::calc_cat(t, p0, p1, p2, p3)


```javascript

var t2 = t*t;
var t3 = t2 * t;
return (0.5 *(  (2 * p1) + (-p0 + p2) * t +(2*p0 - 5*p1 + 4*p2 - p3) * t2 +(-p0 + 3*p1- 3*p2 + p3) * t3));

```

### <a name="jsVectors_crossProd"></a>jsVectors::crossProd(v1, v2)


```javascript

        // U x V = Ux*Vy-Uy*Vx
        return v1.x*v2.y - v1.y*v2.x;
    
```

### <a name="jsVectors_diff"></a>jsVectors::diff(p1, p2)


```javascript

return { x : p2.x - p1.x,
         y : p2.y - p1.y };
    
```

### <a name="jsVectors_dist"></a>jsVectors::dist(p1, p2)


```javascript
                    
var dx = p1.x - p2.x;
var dy = p1.y - p2.y;
return Math.sqrt( dx*dx + dy*dy );
    
```

### <a name="jsVectors_dotProd"></a>jsVectors::dotProd(v1, v2)


```javascript

return v1.x*v2.x + v1.y*v2.y;
    
```

### <a name="jsVectors_getBarCoeffs"></a>jsVectors::getBarCoeffs(p0, p1, p2)


```javascript

var bb = barCoeffs;
bb.A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
bb.sign = bb.A < 0 ? -1 : 1;
bb.s1 = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) ) *bb.sign;
bb.s2 = (p2.y - p0.y) * bb.sign;
bb.s3 = (p0.x - p2.x) * bb.sign;
bb.t1 = (p0.x * p1.y - p0.y * p1.x)*bb.sign;
bb.t2 = (p0.y - p1.y) * bb.sign;
bb.t3 = (p1.x - p0.x) * bb.sign;
return bb;
    
```

### jsVectors::constructor( t )

```javascript

if(!tn1) { 
    
   tn1 = { x: 0, y : 0};
   nv1 = { x: 0, y : 0};
   
   projectionMatrix = [0,0,0,0];
   
   jVect = { x:0, y:0 };
   iVect = { x:0, y:0 };
   pBase = { x:0, y:0 }; 
   
   barCoeffs = { Area : 0, s1 : 0, s2 : 0, s3 : 0, t1:0, t2:0, t3:0, sign : 0 };   
   deVector = { x:0, y:0};
   
}
```
        
### <a name="jsVectors_initProjection"></a>jsVectors::initProjection(p1, p2)


```javascript

iVect.y = p2.y - p1.y;
iVect.x = p2.x - p1.x;

jVect.y = iVect.y;
jVect.x = iVect.x;

this.normalize(iVect);
this.normalize(jVect);

this.rotate( jVect, Math.PI/2);

pBase.x = p1.x;
pBase.y = p1.y;
       
   
```

### <a name="jsVectors_length"></a>jsVectors::length(p1)


```javascript

var dx = p1.x;
var dy = p1.y;
return Math.sqrt( dx*dx + dy*dy );        
    
```

### <a name="jsVectors_linesIntersect"></a>jsVectors::linesIntersect(p0, p1, v0, v1)


```javascript

var x1 = p0.x,
    y1 = p0.y,
    x2 = p1.x,
    y2 = p1.y,
    x3 = v0.x,
    y3 = v0.y,
    x4 = v1.x,
    y4 = v1.y;

var x=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
var y=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
if (isNaN(x)||isNaN(y)) {
    return false;
} else {
    if (x1>=x2) {
        if (!(x2<=x&&x<=x1)) {return false;}
    } else {
        if (!(x1<=x&&x<=x2)) {return false;}
    }
    if (y1>=y2) {
        if (!(y2<=y&&y<=y1)) {return false;}
    } else {
        if (!(y1<=y&&y<=y2)) {return false;}
    }
    if (x3>=x4) {
        if (!(x4<=x&&x<=x3)) {return false;}
    } else {
        if (!(x3<=x&&x<=x4)) {return false;}
    }
    if (y3>=y4) {
        if (!(y4<=y&&y<=y3)) {return false;}
    } else {
        if (!(y3<=y&&y<=y4)) {return false;}
    }
}
return true;
    
```

### <a name="jsVectors_mirrorVector"></a>jsVectors::mirrorVector(v1, along, base)


```javascript

// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along.x - base.x;   
tn1.y = along.y - base.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

v1.x = v1.x - base.x;
v1.y = v1.y - base.y;

// if the 'j' or normal projection is positive, turn around
if( this.dotProd(v1,nv1) > 0) 
    this.rotate(nv1, Math.PI);        

this.normalize(tn1);
this.normalize(nv1);

// Create positive coordinates of the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( this.dotProd(v1,nv1) );
//             tnProd = Math.abs( this.dotProd(v1,tn1) );
    
var tnProd = this.dotProd(v1,tn1);
// then, project the length of the base vectors to get the new vector space
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;   

v1.x += base.x;
v1.y += base.y;

return v1;        
    
```

### <a name="jsVectors_normalize"></a>jsVectors::normalize(v)


```javascript

var len = Math.sqrt( v.x*v.x + v.y*v.y);

if(len==0) {
    throw "Error normalizing vector: the length of the vector was zero";
}

v.x = v.x/len;
v.y = v.y/len;
return v;
    
```

### <a name="jsVectors_opposeVector"></a>jsVectors::opposeVector(v1, along)


```javascript


// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along,x;   
tn1.y = along.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

this.normalize(tn1);
this.normalize(nv1);

// Important: turn the tangent to opposing direction...
this.rotate(tn1, Math.PI);

// Create the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( jsMath.dotProd(v1,nv1) ),
    tnProd = Math.abs( jsMath.dotProd(v1,tn1) );
    
// if the 'j' or normal projection is negative, turn around
if( this.dotProd(v1,nv1) < 0) 
    this.rotate(nv1, Math.PI);
    
// then, project the length of the vector to get the new vector
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;        

return v1;
    
```

### <a name="jsVectors_pointInTriangle"></a>jsVectors::pointInTriangle(p, p0, p1, p2)


```javascript


var A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
var sign = A < 0 ? -1 : 1;
var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_pointInTriangleBc"></a>jsVectors::pointInTriangleBc(p, bb)


```javascript

var A = bb.A;
var sign = bb.sign;
var s = (bb.s1 +  bb.s2 * p.x + bb.s3 * p.y);
var t = (bb.t1 +  bb.t2 * p.x + bb.t3 * p.y);

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_project"></a>jsVectors::project(vectorToProject)


```javascript


var p = vectorToProject;

pVector.x = p.x - pBase.x;
pVector.y = p.y - pBase.y;

prodResult.i = this.dotProd( pVector, iVect);
prodResult.j = this.dotProd( pVector, jVect);

return prodResult;

```

### <a name="jsVectors_rotate"></a>jsVectors::rotate(v, angle)


```javascript


var s = Math.sin(angle);
var c = Math.cos(angle);

var x = v.x,
    y = v.y;

v.x = x * c + y * s;
v.y = -x * s + y * c;

return v;
    
```

### <a name="jsVectors_rotateAround"></a>jsVectors::rotateAround(angle, v, around)


```javascript

this.sub(v, around);
this.rotate(v,angle);
this.add(v,around);
    
```

### <a name="jsVectors_sub"></a>jsVectors::sub(v1, v2)


```javascript

v1.x = v1.x - v2.x;
v1.y = v1.y - v2.y;
    
```

### <a name="jsVectors_tangentNormal"></a>jsVectors::tangentNormal(v1, v2, v3)


```javascript


var t1 = {};
t1.x = v2.x - v1.x;
t1.y = v2.y - v1.y;
var t2 = {};
t2.x = v3.x - v2.x;
t2.y = v3.y - v2.y;

var p = { x : t1.x+t2.x,
          y : t1.y+t2.y
        };
return this.normalize(p);
    
```

### <a name="jsVectors_triangleArea"></a>jsVectors::triangleArea(A, B, C)


```javascript

        
var area = A.x * ( B.y - C.y ) +
           B.x * ( C.y - A.y ) +
           C.x * ( A.y - B.y );
        
return Math.abs( area / 2);        
    
```

### <a name="jsVectors_triangleInTriangle"></a>jsVectors::triangleInTriangle(p0, p1, p2, q0, q1, q2)


```javascript

        
var bb = this.getBarCoeffs(p0,p1,p2);

if(this.pointInTriangleBc( q0, bb) ) return true;
if(this.pointInTriangleBc( q1, bb) ) return true;
if(this.pointInTriangleBc( q2, bb) ) return true;

var bb = this.getBarCoeffs(q0, q1, q2 );

if(this.pointInTriangleBc( p0, bb) ) return true;
if(this.pointInTriangleBc( p1, bb) ) return true;
if(this.pointInTriangleBc( p2, bb) ) return true;


if(this.linesIntersect( p0,p1, q0,q1)) return true;
if(this.linesIntersect( p1,p2, q0,q1)) return true;
if(this.linesIntersect( p2,p0, q0,q1)) return true;

if(this.linesIntersect( p0,p1, q1,q2)) return true;
if(this.linesIntersect( p1,p2, q1,q2)) return true;
if(this.linesIntersect( p2,p0, q1,q2)) return true;        

if(this.linesIntersect( p0,p1, q2,q0)) return true;
if(this.linesIntersect( p1,p2, q2,q0)) return true;
if(this.linesIntersect( p2,p0, q2,q0)) return true;             

return false;
    
```

### <a name="jsVectors_unProject"></a>jsVectors::unProject(projectedVector)


```javascript

var p = projectedVector;
deVector.x = p.i * iVect.x + p.j * jVect.x;
deVector.y = p.i * iVect.y + p.j * jVect.y;

deVector.x += pBase.x;
deVector.y += pBase.y;
return deVector;
   
```



   


   



      
    
      
            
# Class quaternion


The class has following internal singleton variables:
        
        
### <a name="quaternion_copy"></a>quaternion::copy(q)


```javascript
this.x = q.x;
this.y = q.y;
this.z = q.z;
this.w = q.w;
```

### quaternion::constructor( x, y, z, w )

```javascript
this.x = x || 0;
this.y = y || 0;
this.z = z || 0;
this.w = ( w !== undefined ) ? w : 1;

```
        
### <a name="quaternion_inverse"></a>quaternion::inverse(t)


```javascript
this.x *= -1;
this.y *= -1;
this.z *= -1;
return this;
```

### <a name="quaternion_multiply"></a>quaternion::multiply(q1, q2)


```javascript

if(!q2) {
    q2 = q1;
    q1 = this;
}

var x =  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
var y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
var z =  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
var w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;

this.x = x;
this.y = y;
this.z = z;
this.w = w;

return this;
```

### <a name="quaternion_normalizeVector3D"></a>quaternion::normalizeVector3D(v)


```javascript
var len = Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );

if(len == 0 || isNaN(len)) return {
    x : 1,
    y : 0,
    z : 0
};

return {
    x : v.x / len,
    y : v.y / len,
    z : v.z / len
};

```

### <a name="quaternion_projectVector"></a>quaternion::projectVector(vector)


```javascript
var dest = {
    x : 0,
    y : 0,
    z : 0
};

// p=q∗vq

var x    = vector.x,  y  = vector.y,  z  = vector.z,
  qx   = this.x, qy = this.y, qz = this.z, qw = this.w;

// calculate quat * vector

var ix =  qw * x + qy * z - qz * y,
  iy =  qw * y + qz * x - qx * z,
  iz =  qw * z + qx * y - qy * x,
  iw = -qx * x - qy * y - qz * z;

// calculate result * inverse quat

dest.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
dest.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
dest.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

return dest;

```

### <a name="quaternion_rotate"></a>quaternion::rotate(r)


```javascript
this.setFromAxisRotation({
    x : 0,
    y : 0,
    z : 1
}, r);

return this;
```

### <a name="quaternion_setFromAxisRotation"></a>quaternion::setFromAxisRotation(v, rot)


```javascript
 
v = this.normalizeVector3D(v);

var halfAngle = rot / 2,
  s = Math.sin( halfAngle );

this.x = v.x * s;
this.y = v.y * s;
this.z = v.z * s;
this.w = Math.cos( halfAngle );

return this;

```



   
    
    


   
      
            
# Class jsVectors


The class has following internal singleton variables:
        
* projectionMatrix
        
* jVect
        
* iVect
        
* pBase
        
* tn1
        
* nv1
        
* barCoeffs
        
* deVector
        
        
### <a name="jsVectors_add"></a>jsVectors::add(v1, v2)


```javascript

    v1.x = v1.x + v2.x;
    v1.y = v1.y + v2.y;
    
```

### <a name="jsVectors_angleBetween"></a>jsVectors::angleBetween(v1, v2)


```javascript

var n1 = this.normalize( { x : v1.x, y : v1.y } );
var n2 = this.normalize( { x : v2.x, y : v2.y } );

var cp = this.crossProd( n1, n2 );
var dp = this.dotProd(n1, n2 );

var a = Math.acos( dp );
if(cp<0) a = a*-1; // other side...
return a;
    
```

### <a name="jsVectors_calc_cat"></a>jsVectors::calc_cat(t, p0, p1, p2, p3)


```javascript

var t2 = t*t;
var t3 = t2 * t;
return (0.5 *(  (2 * p1) + (-p0 + p2) * t +(2*p0 - 5*p1 + 4*p2 - p3) * t2 +(-p0 + 3*p1- 3*p2 + p3) * t3));

```

### <a name="jsVectors_crossProd"></a>jsVectors::crossProd(v1, v2)


```javascript

        // U x V = Ux*Vy-Uy*Vx
        return v1.x*v2.y - v1.y*v2.x;
    
```

### <a name="jsVectors_diff"></a>jsVectors::diff(p1, p2)


```javascript

return { x : p2.x - p1.x,
         y : p2.y - p1.y };
    
```

### <a name="jsVectors_dist"></a>jsVectors::dist(p1, p2)


```javascript
                    
var dx = p1.x - p2.x;
var dy = p1.y - p2.y;
return Math.sqrt( dx*dx + dy*dy );
    
```

### <a name="jsVectors_dotProd"></a>jsVectors::dotProd(v1, v2)


```javascript

return v1.x*v2.x + v1.y*v2.y;
    
```

### <a name="jsVectors_getBarCoeffs"></a>jsVectors::getBarCoeffs(p0, p1, p2)


```javascript

var bb = barCoeffs;
bb.A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
bb.sign = bb.A < 0 ? -1 : 1;
bb.s1 = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) ) *bb.sign;
bb.s2 = (p2.y - p0.y) * bb.sign;
bb.s3 = (p0.x - p2.x) * bb.sign;
bb.t1 = (p0.x * p1.y - p0.y * p1.x)*bb.sign;
bb.t2 = (p0.y - p1.y) * bb.sign;
bb.t3 = (p1.x - p0.x) * bb.sign;
return bb;
    
```

### jsVectors::constructor( t )

```javascript

if(!tn1) { 
    
   tn1 = { x: 0, y : 0};
   nv1 = { x: 0, y : 0};
   
   projectionMatrix = [0,0,0,0];
   
   jVect = { x:0, y:0 };
   iVect = { x:0, y:0 };
   pBase = { x:0, y:0 }; 
   
   barCoeffs = { Area : 0, s1 : 0, s2 : 0, s3 : 0, t1:0, t2:0, t3:0, sign : 0 };   
   deVector = { x:0, y:0};
   
}
```
        
### <a name="jsVectors_initProjection"></a>jsVectors::initProjection(p1, p2)


```javascript

iVect.y = p2.y - p1.y;
iVect.x = p2.x - p1.x;

jVect.y = iVect.y;
jVect.x = iVect.x;

this.normalize(iVect);
this.normalize(jVect);

this.rotate( jVect, Math.PI/2);

pBase.x = p1.x;
pBase.y = p1.y;
       
   
```

### <a name="jsVectors_length"></a>jsVectors::length(p1)


```javascript

var dx = p1.x;
var dy = p1.y;
return Math.sqrt( dx*dx + dy*dy );        
    
```

### <a name="jsVectors_linesIntersect"></a>jsVectors::linesIntersect(p0, p1, v0, v1)


```javascript

var x1 = p0.x,
    y1 = p0.y,
    x2 = p1.x,
    y2 = p1.y,
    x3 = v0.x,
    y3 = v0.y,
    x4 = v1.x,
    y4 = v1.y;

var x=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
var y=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
if (isNaN(x)||isNaN(y)) {
    return false;
} else {
    if (x1>=x2) {
        if (!(x2<=x&&x<=x1)) {return false;}
    } else {
        if (!(x1<=x&&x<=x2)) {return false;}
    }
    if (y1>=y2) {
        if (!(y2<=y&&y<=y1)) {return false;}
    } else {
        if (!(y1<=y&&y<=y2)) {return false;}
    }
    if (x3>=x4) {
        if (!(x4<=x&&x<=x3)) {return false;}
    } else {
        if (!(x3<=x&&x<=x4)) {return false;}
    }
    if (y3>=y4) {
        if (!(y4<=y&&y<=y3)) {return false;}
    } else {
        if (!(y3<=y&&y<=y4)) {return false;}
    }
}
return true;
    
```

### <a name="jsVectors_mirrorVector"></a>jsVectors::mirrorVector(v1, along, base)


```javascript

// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along.x - base.x;   
tn1.y = along.y - base.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

v1.x = v1.x - base.x;
v1.y = v1.y - base.y;

// if the 'j' or normal projection is positive, turn around
if( this.dotProd(v1,nv1) > 0) 
    this.rotate(nv1, Math.PI);        

this.normalize(tn1);
this.normalize(nv1);

// Create positive coordinates of the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( this.dotProd(v1,nv1) );
//             tnProd = Math.abs( this.dotProd(v1,tn1) );
    
var tnProd = this.dotProd(v1,tn1);
// then, project the length of the base vectors to get the new vector space
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;   

v1.x += base.x;
v1.y += base.y;

return v1;        
    
```

### <a name="jsVectors_normalize"></a>jsVectors::normalize(v)


```javascript

var len = Math.sqrt( v.x*v.x + v.y*v.y);

if(len==0) {
    throw "Error normalizing vector: the length of the vector was zero";
}

v.x = v.x/len;
v.y = v.y/len;
return v;
    
```

### <a name="jsVectors_opposeVector"></a>jsVectors::opposeVector(v1, along)


```javascript


// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along,x;   
tn1.y = along.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

this.normalize(tn1);
this.normalize(nv1);

// Important: turn the tangent to opposing direction...
this.rotate(tn1, Math.PI);

// Create the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( jsMath.dotProd(v1,nv1) ),
    tnProd = Math.abs( jsMath.dotProd(v1,tn1) );
    
// if the 'j' or normal projection is negative, turn around
if( this.dotProd(v1,nv1) < 0) 
    this.rotate(nv1, Math.PI);
    
// then, project the length of the vector to get the new vector
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;        

return v1;
    
```

### <a name="jsVectors_pointInTriangle"></a>jsVectors::pointInTriangle(p, p0, p1, p2)


```javascript


var A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
var sign = A < 0 ? -1 : 1;
var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_pointInTriangleBc"></a>jsVectors::pointInTriangleBc(p, bb)


```javascript

var A = bb.A;
var sign = bb.sign;
var s = (bb.s1 +  bb.s2 * p.x + bb.s3 * p.y);
var t = (bb.t1 +  bb.t2 * p.x + bb.t3 * p.y);

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_project"></a>jsVectors::project(vectorToProject)


```javascript


var p = vectorToProject;

pVector.x = p.x - pBase.x;
pVector.y = p.y - pBase.y;

prodResult.i = this.dotProd( pVector, iVect);
prodResult.j = this.dotProd( pVector, jVect);

return prodResult;

```

### <a name="jsVectors_rotate"></a>jsVectors::rotate(v, angle)


```javascript


var s = Math.sin(angle);
var c = Math.cos(angle);

var x = v.x,
    y = v.y;

v.x = x * c + y * s;
v.y = -x * s + y * c;

return v;
    
```

### <a name="jsVectors_rotateAround"></a>jsVectors::rotateAround(angle, v, around)


```javascript

this.sub(v, around);
this.rotate(v,angle);
this.add(v,around);
    
```

### <a name="jsVectors_sub"></a>jsVectors::sub(v1, v2)


```javascript

v1.x = v1.x - v2.x;
v1.y = v1.y - v2.y;
    
```

### <a name="jsVectors_tangentNormal"></a>jsVectors::tangentNormal(v1, v2, v3)


```javascript


var t1 = {};
t1.x = v2.x - v1.x;
t1.y = v2.y - v1.y;
var t2 = {};
t2.x = v3.x - v2.x;
t2.y = v3.y - v2.y;

var p = { x : t1.x+t2.x,
          y : t1.y+t2.y
        };
return this.normalize(p);
    
```

### <a name="jsVectors_triangleArea"></a>jsVectors::triangleArea(A, B, C)


```javascript

        
var area = A.x * ( B.y - C.y ) +
           B.x * ( C.y - A.y ) +
           C.x * ( A.y - B.y );
        
return Math.abs( area / 2);        
    
```

### <a name="jsVectors_triangleInTriangle"></a>jsVectors::triangleInTriangle(p0, p1, p2, q0, q1, q2)


```javascript

        
var bb = this.getBarCoeffs(p0,p1,p2);

if(this.pointInTriangleBc( q0, bb) ) return true;
if(this.pointInTriangleBc( q1, bb) ) return true;
if(this.pointInTriangleBc( q2, bb) ) return true;

var bb = this.getBarCoeffs(q0, q1, q2 );

if(this.pointInTriangleBc( p0, bb) ) return true;
if(this.pointInTriangleBc( p1, bb) ) return true;
if(this.pointInTriangleBc( p2, bb) ) return true;


if(this.linesIntersect( p0,p1, q0,q1)) return true;
if(this.linesIntersect( p1,p2, q0,q1)) return true;
if(this.linesIntersect( p2,p0, q0,q1)) return true;

if(this.linesIntersect( p0,p1, q1,q2)) return true;
if(this.linesIntersect( p1,p2, q1,q2)) return true;
if(this.linesIntersect( p2,p0, q1,q2)) return true;        

if(this.linesIntersect( p0,p1, q2,q0)) return true;
if(this.linesIntersect( p1,p2, q2,q0)) return true;
if(this.linesIntersect( p2,p0, q2,q0)) return true;             

return false;
    
```

### <a name="jsVectors_unProject"></a>jsVectors::unProject(projectedVector)


```javascript

var p = projectedVector;
deVector.x = p.i * iVect.x + p.j * jVect.x;
deVector.y = p.i * iVect.y + p.j * jVect.y;

deVector.x += pBase.x;
deVector.y += pBase.y;
return deVector;
   
```



   


   



      
    



      
    
      
            
# Class jsBezierCurve


The class has following internal singleton variables:
        
* jsMath
        
        
### <a name="jsBezierCurve_derivate"></a>jsBezierCurve::derivate(d, t)


```javascript

        
var P0 = this._points[d][0],
    P1 = this._points[d][1],
    P2 = this._points[d][2],
    P3 = this._points[d][3];
    
var t2 = t*t;
var nt = 1-t;
var nt2 = nt*nt;

// dP(t) / dt =  -3(1-t)^2 * P0 + 3(1-t)^2 * P1 - 6t(1-t) * P1 - 3t^2 * P2 + 6t(1-t) * P2 + 3t^2 * P3
// or from Wikipedia
// 
// F(t)/dt = 3*nt2 * (P1-P0) + 6*t*nt*(P2-P1) + 3*t2*(P3-P2)

// var derivative = -3*nt2* P0 + 3*nt2 * P1 - 6*t*nt*P1 - 3*t2 * P2 + 6*t*nt * P2 + 3*t2 * P3;

// This should give the exact derivate of the point at certain position
var FT_dt = 3*nt2*(P1-P0) + 6*t*nt*(P2-P1) + 3*t2*(P3-P2);
return FT_dt;

```

### <a name="jsBezierCurve_distanceOf"></a>jsBezierCurve::distanceOf(x, y)


```javascript

        var t = this.findClosestT(x,y);
        var dx = this.x(t)-x,
            dy = this.y(t)-y;
        return Math.sqrt(dx*dx+ dy*dy);
    
```

### <a name="jsBezierCurve_findClosestT"></a>jsBezierCurve::findClosestT(x, y)


```javascript

var tStart = 0, tMiddle = 0.5, tEnd = 1;
var iterations = 10;

while(iterations--) {
    var d0_x = this.x(tStart) - x,
        d0_y = this.y(tStart) - y,
        d2_x = this.x(tEnd)-x,
        d2_y = this.y(tEnd)-y;
    var d0 = Math.sqrt( d0_x*d0_x +  d0_y*d0_y),
        d2 = Math.sqrt( d2_x*d2_x +  d2_y*d2_y);
        
    if(d0<d2) {
        tEnd = tMiddle;
    } else {
        tStart = tMiddle;
    }
    tMiddle = tStart + ( tEnd - tStart ) / 2;
}
var d0_x = this.x(tStart) - x,
    d0_y = this.y(tStart) - y,
    d1_x = this.x(tMiddle)-x,
    d1_y = this.y(tMiddle)-y;            
    d2_x = this.x(tEnd)-x,
    d2_y = this.y(tEnd)-y;
var d0 = Math.sqrt( d0_x*d0_x +  d0_y*d0_y),
    d1 = Math.sqrt( d1_x*d1_x +  d1_y*d1_y),
    d2 = Math.sqrt( d2_x*d2_x +  d2_y*d2_y);
    
if(d0<d1 && d0<d2) return tStart;
if(d2<d1 && d2<d0) return tEnd;
return tMiddle;

```

### <a name="jsBezierCurve_fitListTo"></a>jsBezierCurve::fitListTo(list)


```javascript

var start = {
  x:  list[0].point_x(0),
  y:  list[0].point_y(0)
};

var ei = list.length-1;

var end = {
  x:  list[ei].point_x(3),
  y:  list[ei].point_y(3)
};

// what we have here is a list of segments, starting from (x,y) ending to (x2,y2)
// have to rotate
// have to scale

var myStart = {
    x : this.x(0),
    y : this.y(0)
};
var myEnd = {
    x : this.x(1),
    y : this.y(1)
};
var dx = myEnd.x - myStart.x,
    dy = myEnd.y - myStart.y;
    
var myLen = Math.sqrt( dx*dx + dy*dy );

var ldx = end.x - start.x,
    ldy = end.y - start.y;

var listLen = Math.sqrt( ldx*ldx + ldy*ldy );
var relAngle = jsMath.angleBetween({
    x : dx, y : dy
}, {
    x : ldx, y : ldy
});

// TODO: convert to path parser fromBezierArray()
// make a quaternion list
// scale & rotate the quaternion data to create new path




```

### <a name="jsBezierCurve_fromLine"></a>jsBezierCurve::fromLine(p0, p1)


```javascript

var len  = p1.x - p0.x;
var step = len/3;
this.initCoeffs(0, p0.x, p0.x+step, p0.x+step*2, p1.x);

var len  = p1.y - p0.y;
var step = len/3;
this.initCoeffs(1, p0.y, p0.y+step, p0.y+step*2, p1.y);


```

### <a name="jsBezierCurve_fromPoints"></a>jsBezierCurve::fromPoints(p0, p1, p2, p3)


```javascript
this.initCoeffs(0, p0.x, p1.x, p2.x, p3.x);
this.initCoeffs(1, p0.y, p1.y, p2.y, p3.y);
```

### <a name="jsBezierCurve_fromQuadCurve"></a>jsBezierCurve::fromQuadCurve(p0, p1, p2)


```javascript
//CP1 = QP0 + 2/3 *(QP1-QP0)
//CP2 = QP2 + 2/3 *(QP1-QP2)
this.initCoeffs(0, p0.x, p0.x+(2/3)*(p1.x-p0.x), p2.x + (2/3)*(p1.x-p2.x), p2.x);
this.initCoeffs(0, p0.y, p0.y+(2/3)*(p1.y-p0.y), p2.y + (2/3)*(p1.y-p2.y), p2.y);

```

### jsBezierCurve::constructor( t )

```javascript

this._points = [];
this._m = [];

if(!jsMath) jsMath = jsVectors();
```
        
### <a name="jsBezierCurve_initCoeffs"></a>jsBezierCurve::initCoeffs(d, v0, v1, v2, v3)


```javascript

        if(!this._coeffs) 
            this._coeffs = [];
            
        if(!this._coeffs[d]) this._coeffs[d] = [];
        if(!this._points[d]) this._points[d] = [];

        // the actual points used in each dimension
        this._points[d][0] = v0;
        this._points[d][1] = v1;
        this._points[d][2] = v2;
        this._points[d][3] = v3;

        var c = this._coeffs[d];
        c[0] = 3 * (v1 - v0);
        c[1] = 3 * (v2 - v1) - c[0];
        c[2] = v3 - v0 - c[0] - c[1];
        c[3] = v0;
        /*
        if(d==0) {
            this._m[0].x = v0;
            this._m[1].x = v1;
            this._m[2].x = v2;
            this._m[3].x = v3;
        }  
        if(d==1) {
            this._m[0].y = v0;
            this._m[1].y = v1;
            this._m[2].y = v2;
            this._m[3].y = v3;
        }
*/
    
```

### <a name="jsBezierCurve_inverseProject"></a>jsBezierCurve::inverseProject(projection)


```javascript

        
        var pt = projection.t;
        
        var n = this.normal(pt,true);
        
        var p_x = n.x * projection.nvProd + this.x(pt),
            p_y = n.y * projection.nvProd + this.y(pt);
        
        var t = this.tangent(pt, true);
        
        p_x = p_x + projection.tangetProd * t.x;
        p_y = p_y + projection.tangetProd * t.y;
        
        // inverse x and inverse y
        projection.ix = p_x;
        projection.iy = p_y;
            
    
```

### <a name="jsBezierCurve_mirrorControls"></a>jsBezierCurve::mirrorControls(t)


```javascript

var base = {
    x : this._points[0][0],
    y : this._points[1][0]
};

var along = {
    x : this._points[0][3],
    y : this._points[1][3]
};

var v1 = {
    x : this._points[0][1],
    y : this._points[1][1]
};
var v2 = {
    x : this._points[0][2],
    y : this._points[1][2]
};

jsMath.mirrorVector( v1, along, base);
jsMath.mirrorVector( v2, along, base);

this.initCoeffs( 0, base.x, v1.x, v2.x, along.x);
this.initCoeffs( 1, base.y, v1.y, v2.y, along.y);

```

### <a name="jsBezierCurve_normal"></a>jsBezierCurve::normal(t, bUnitVector)


```javascript

        var v = this.tangent(t);
        // direction of the curve at certain point...
        var vx = v.x;
        v.x = -v.y;
        v.y = vx;
        if( bUnitVector) jsMath.normalize(v);
        return v;
    
```

### <a name="jsBezierCurve_point_x"></a>jsBezierCurve::point_x(i)


```javascript

        return this._points[0][i];
    
```

### <a name="jsBezierCurve_point_y"></a>jsBezierCurve::point_y(i)


```javascript

        return this._points[1][i];
    
```

### <a name="jsBezierCurve_points"></a>jsBezierCurve::points()


```javascript

        return this._m;
    
```

### <a name="jsBezierCurve_projectPoint"></a>jsBezierCurve::projectPoint(x, y, projection)


```javascript

        
        // logaritmic function ? 
        
        var maxCnt=20;
        var t = 0.5, step = 0.25; // start from the middle
        
        while( maxCnt--) {
            
            // We try to find a point where the projection to the tangent is as small as possible
            var tn = this.tangent(t,true);
            dv.x = x - this.x(t);
            dv.y = y - this.y(t);
            var prod = dv.x * tn.x  +  dv.y*tn.y;
            
            // close enough
            if( Math.abs( prod ) < 0.05 ) {
                // found it...
                break;
            }
            if(prod > 0) {
                t += step;
            } else {
                t += -step;
            }
            step = step / 2;
        }
        
        var n = this.normal(t,true);
        if(!projection) projection = {};
        projection.tangentProd = prod;
        projection.nvProd = n.x * dv.x + n.y * d.y;
        projection.nv_x = n.x;
        projection.nv_y = n.y;
        projection.tn_x = tn.x;
        projection.tn_y = tn.y;
        projection.ix = 0; // when projected back, the inversed coords here
        projection.iy = 0;
        projection.t = t;
        
        return projection;        
    
```

### <a name="jsBezierCurve_setControls"></a>jsBezierCurve::setControls(p0, p1, p2, p3, fn)


```javascript

this.initCoeffs(0, p0.x, p1.x, p2.x, p3.x);
this.initCoeffs(1, p0.y, p1.y, p2.y, p3.y);

    
```

### <a name="jsBezierCurve_split"></a>jsBezierCurve::split(t)


```javascript


var plist = this._points[0];
var v1 = this.splitCoeff(plist[0],plist[1],plist[2],plist[3],t);
plist = this._points[1];
var v2 = this.splitCoeff(plist[0],plist[1],plist[2],plist[3],t);

this.fromPoints(  { x : v1.p0, y : v2.p0 },
                { x : v1.p1, y : v2.p1 },
                { x : v1.p2, y : v2.p2 },
                { x : v1.p3, y : v2.p3 }
);

var b2 = jsBezierCurve();
b2.fromPoints(  { x : v1.p3, y : v2.p3 },
                { x : v1.p4, y : v2.p4 },
                { x : v1.p5, y : v2.p5 },
                { x : v1.p6, y : v2.p6 }
);

return b2;

```

### <a name="jsBezierCurve_splitCoeff"></a>jsBezierCurve::splitCoeff(P0, P1, P2, P3, t)


```javascript
var v = {};
v.p0 = P0;
v.p1 = (1-t)*P0 + t*P1;
var m2 = (1-t)*P1 + t*P2;
v.p5 = (1-t)*P2 + t*P3;

v.p2  = (1-t)*v.p1 + t*m2;
v.p4  = (1-t)*m2 + t*v.p5;
v.p3  = (1-t)*v.p2 + t*v.p4;        
v.p6  = P3;

return v;
```

### <a name="jsBezierCurve_step"></a>jsBezierCurve::step(t, dim)


```javascript

if(!this._coeffs) return;
var c = this._coeffs[dim];
if(!c) return;
var t2 = t*t, t3 = t2*t;
return c[2] * t3 + c[1] * t2 + c[0] *t + c[3];
    
```

### <a name="jsBezierCurve_tangent"></a>jsBezierCurve::tangent(t, bUnitVector)


```javascript

        // direction of the curve at certain point...
        var nv = {};
        nv.x = this.derivate(0,t);
        nv.y = this.derivate(1,t);
        if( bUnitVector) jsMath.normalize(nv);
        return nv;
    
```

### <a name="jsBezierCurve_x"></a>jsBezierCurve::x(t)


```javascript

        return this.step(t,0);
    
```

### <a name="jsBezierCurve_y"></a>jsBezierCurve::y(t)


```javascript

        return this.step(t,1);
    
```

### <a name="jsBezierCurve_z"></a>jsBezierCurve::z(t)


```javascript
return this.step(t,2);
```



   


   



      
    
      
            
# Class pathIterator


The class has following internal singleton variables:
        
        
### <a name="pathIterator_bezierSplit"></a>pathIterator::bezierSplit(P0, P1, P2, P3, t)


```javascript
var v = {};
v.p1 = (1-t)*P0 + t*P1;
var m2 = (1-t)*P1 + t*P2;
v.p5 = (1-t)*P2 + t*P3;

v.p2  = (1-t)*v.p1 + t*m2;
v.p4  = (1-t)*m2 + t*v.p5;
v.p3  = (1-t)*v.p2 + t*v.p4;        

return v;
```

### <a name="pathIterator_endPoint"></a>pathIterator::endPoint(pv, m, fn)


```javascript

if(!pv) {
    pv = {
        x : 0,
        y : 0,
        z : 0
    }
}
if(!m)  m = quaternion();

var me = this,
    cnt = 0;
    
if(!fn) {
    fn = function(q) {
        return q;
    }
}

this.list.forEach( function(c) {
    
    cnt++;
    if(c.cmd=="Q") {
    
        var ii=0;
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;    
            ii++;
        });
    }
    
    if(c.cmd=="M") {
    
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;         
        });
    }
    
    if(c.cmd=="L") {
    
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;         
        });
    }
    
    if(c.cmd=="C") {

        
        var ii=0;
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;    
            ii++;
        });
    }    
})

return pv;

```

### pathIterator::constructor( list )

```javascript

/*
  list of path iterators
 
   {
        q : quaternion,
        d : distance
   },
   {
        q : quaternion,
        d : distance
   },   
*/

this.list = list;

```
        
### <a name="pathIterator_partToSvgPath"></a>pathIterator::partToSvgPath(start, end, pv, m)


```javascript

var str = "";
if(!pv) {
    pv = {
        x : 0,
        y : 0,
        z : 0
    }
}
if(!m)  m = quaternion();

this.addedObjects = [];
var me = this,
    cnt = 0;

this.list.forEach( function(c) {
    
    cnt++;
    
    if(cnt < start) return;
    if(cnt > end ) return;
    
    var g = _e("g");
    g.circle().attr({
        fill : "#ffaa88",
        cx : pv.x,
        cy : pv.y,
        r : 10
    });
    g.svg_text().attr({
        x : pv.x,
        y : pv.y + 10,
        "font-size" : 20,
        "fill" : "black"
    }).text(cnt+"");
    me.addedObjects.push( g );

    if(c.cmd=="Q") {
    
        var ii=0;
        c.path.forEach( function(p) {
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;    
            if(ii==0) {
                str+="Q ";
            }
            str+=" "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
            ii++;
        });
    }
    
    if(c.cmd=="M") {
    
        c.path.forEach( function(p) {
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;         
            str+="M "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
        });
    }
    
    if(c.cmd=="L") {
    
        c.path.forEach( function(p) {
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;         
            str+="L "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
        });
    }
    
    if(c.cmd=="C") {

        
        var ii=0;
        c.path.forEach( function(p) {
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;    
            if(ii==0) {
                str+="C ";
            }
            str+=" "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
            ii++;
        });
        

    }    
    
    
    

    // no screen projection here...
    
    /*
    if(p.sub) {
        var ii = pathIterator( p.sub );
        var subQ = quaternion();
        subQ.copy( m );
        str+= ii.toSvgPath({
            x : pv.x,
            y : pv.y,
            z : pv.z
        }, subQ);
    }
    */
    
})

return str;

/*

var v = m.projectVector({
    x : 100,
    y : 0,
    z : 0
});

main.p().text(JSON.stringify(v));
var vLen = Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );
main.p().text("len = "+ vLen); 

m.multiply( step2 );

var v = m.projectVector({
    x : 100,
    y : 0,
    z : 0
});

main.p().text(JSON.stringify(v));
var vLen = Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );
main.p().text("len = "+ vLen);
*/
```

### <a name="pathIterator_pathFunction"></a>pathIterator::pathFunction(t)


```javascript
/*
        this.initBezier();
        var ntCnt = this.getSegmentCount();
        var t1 = ntCnt * t;
        var t_index = Math.floor( t1 );
        var seg = this.getSegmentNro(t_index);
        var sub_t = t1 - t_index;
        
        // for example ntCnt = 10
        // t = 9,5
        var stepLen = 1 / ntCnt,        // 0,1
            nowStep = t_index / ntCnt,  // 0,9
            totStep = t,                // 0,95
            remStep = totStep - nowStep, // 0,05
            relStep = remStep / stepLen; // 0,05 / 0,1 = 0,5
        
        var bez = seg.bezier();
        // console.log("Rel step "+relStep);
        pathFnData.x = bez.x(relStep);
        pathFnData.y = bez.y(relStep);
        var nn = bez.tangent(relStep, true);
        
        pathFnData.normal.x = nn.x;
        pathFnData.normal.y = nn.y;
        
        fn(pathFnData);
*/
```

### <a name="pathIterator_quadToCubic"></a>pathIterator::quadToCubic(P0, P1, P2)


```javascript
//CP1 = QP0 + 2/3 *(QP1-QP0)
//CP2 = QP2 + 2/3 *(QP1-QP2)

return {
    p0 : P0,
    p1 : P0 + 2/3 *(P1-P0),
    p2 : P2 + 2/3 *(P1-P2),
    p3 : P2
}

```

### <a name="pathIterator_toSvgCubicPath"></a>pathIterator::toSvgCubicPath(pv, m)


```javascript
var str = "";
if(!pv) {
    pv = {
        x : 0,
        y : 0,
        z : 0
    }
}
if(!m)  m = quaternion();

var ii = 0;
this.list.forEach( function(p) {
    var dv = { x : p.d, y : 0, z : 0 };
    m.multiply( p.q );
    var v = m.projectVector(dv);
    pv.x += v.x;
    pv.y += v.y;
    pv.z += v.z;
    // no screen projection here...
    if(ii==0) {
        str+="C "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
    } else {
        str+=" "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
    }
    ii++;

    
})

return str;
```

### <a name="pathIterator_toSvgPath"></a>pathIterator::toSvgPath(pv, m, fn)


```javascript

var str = "";
if(!pv) {
    pv = {
        x : 0,
        y : 0,
        z : 0
    }
}
if(!m)  m = quaternion();

this.addedObjects = [];
var me = this,
    cnt = 0;
    
if(!fn) {
    fn = function(q) {
        return q;
    }
}

this.list.forEach( function(c) {
    
    cnt++;
    /*
    var g = _e("g");
    g.circle().attr({
        fill : "#ffaa77",
        cx : pv.x,
        cy : pv.y,
        r : 10
    });
    g.svg_text().attr({
        x : pv.x,
        y : pv.y + 10,
        "font-size" : 20,
        "fill" : "#222222"
    }).text(cnt+"");
    me.addedObjects.push( g ); */

    if(c.cmd=="Q") {
    
        var ii=0;
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;    
            if(ii==0) {
                str+="Q ";
            }
            str+=" "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
            ii++;
        });
    }
    
    if(c.cmd=="M") {
    
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;         
            str+="M "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
        });
    }
    
    if(c.cmd=="L") {
    
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;         
            str+="L "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
        });
    }
    
    if(c.cmd=="C") {

        
        var ii=0;
        c.path.forEach( function(p) {
            p = fn(p);
            var dv = { x : p.d, y : 0, z : 0 };
            m.multiply( p.q );
            var v = m.projectVector(dv);
            pv.x += v.x;
            pv.y += v.y;
            pv.z += v.z;    
            if(ii==0) {
                str+="C ";
            }
            str+=" "+pv.x.toFixed(3)+", "+pv.y.toFixed(3);
            ii++;
        });
        

    }    
    
    
    

    // no screen projection here...
    
    /*
    if(p.sub) {
        var ii = pathIterator( p.sub );
        var subQ = quaternion();
        subQ.copy( m );
        str+= ii.toSvgPath({
            x : pv.x,
            y : pv.y,
            z : pv.z
        }, subQ);
    }
    */
    
})

return str;

/*

var v = m.projectVector({
    x : 100,
    y : 0,
    z : 0
});

main.p().text(JSON.stringify(v));
var vLen = Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );
main.p().text("len = "+ vLen); 

m.multiply( step2 );

var v = m.projectVector({
    x : 100,
    y : 0,
    z : 0
});

main.p().text(JSON.stringify(v));
var vLen = Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );
main.p().text("len = "+ vLen);
*/
```



   
    
    


   
      
            
# Class jsVectors


The class has following internal singleton variables:
        
* projectionMatrix
        
* jVect
        
* iVect
        
* pBase
        
* tn1
        
* nv1
        
* barCoeffs
        
* deVector
        
        
### <a name="jsVectors_add"></a>jsVectors::add(v1, v2)


```javascript

    v1.x = v1.x + v2.x;
    v1.y = v1.y + v2.y;
    
```

### <a name="jsVectors_angleBetween"></a>jsVectors::angleBetween(v1, v2)


```javascript

var n1 = this.normalize( { x : v1.x, y : v1.y } );
var n2 = this.normalize( { x : v2.x, y : v2.y } );

var cp = this.crossProd( n1, n2 );
var dp = this.dotProd(n1, n2 );

var a = Math.acos( dp );
if(cp<0) a = a*-1; // other side...
return a;
    
```

### <a name="jsVectors_calc_cat"></a>jsVectors::calc_cat(t, p0, p1, p2, p3)


```javascript

var t2 = t*t;
var t3 = t2 * t;
return (0.5 *(  (2 * p1) + (-p0 + p2) * t +(2*p0 - 5*p1 + 4*p2 - p3) * t2 +(-p0 + 3*p1- 3*p2 + p3) * t3));

```

### <a name="jsVectors_crossProd"></a>jsVectors::crossProd(v1, v2)


```javascript

        // U x V = Ux*Vy-Uy*Vx
        return v1.x*v2.y - v1.y*v2.x;
    
```

### <a name="jsVectors_diff"></a>jsVectors::diff(p1, p2)


```javascript

return { x : p2.x - p1.x,
         y : p2.y - p1.y };
    
```

### <a name="jsVectors_dist"></a>jsVectors::dist(p1, p2)


```javascript
                    
var dx = p1.x - p2.x;
var dy = p1.y - p2.y;
return Math.sqrt( dx*dx + dy*dy );
    
```

### <a name="jsVectors_dotProd"></a>jsVectors::dotProd(v1, v2)


```javascript

return v1.x*v2.x + v1.y*v2.y;
    
```

### <a name="jsVectors_getBarCoeffs"></a>jsVectors::getBarCoeffs(p0, p1, p2)


```javascript

var bb = barCoeffs;
bb.A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
bb.sign = bb.A < 0 ? -1 : 1;
bb.s1 = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) ) *bb.sign;
bb.s2 = (p2.y - p0.y) * bb.sign;
bb.s3 = (p0.x - p2.x) * bb.sign;
bb.t1 = (p0.x * p1.y - p0.y * p1.x)*bb.sign;
bb.t2 = (p0.y - p1.y) * bb.sign;
bb.t3 = (p1.x - p0.x) * bb.sign;
return bb;
    
```

### jsVectors::constructor( t )

```javascript

if(!tn1) { 
    
   tn1 = { x: 0, y : 0};
   nv1 = { x: 0, y : 0};
   
   projectionMatrix = [0,0,0,0];
   
   jVect = { x:0, y:0 };
   iVect = { x:0, y:0 };
   pBase = { x:0, y:0 }; 
   
   barCoeffs = { Area : 0, s1 : 0, s2 : 0, s3 : 0, t1:0, t2:0, t3:0, sign : 0 };   
   deVector = { x:0, y:0};
   
}
```
        
### <a name="jsVectors_initProjection"></a>jsVectors::initProjection(p1, p2)


```javascript

iVect.y = p2.y - p1.y;
iVect.x = p2.x - p1.x;

jVect.y = iVect.y;
jVect.x = iVect.x;

this.normalize(iVect);
this.normalize(jVect);

this.rotate( jVect, Math.PI/2);

pBase.x = p1.x;
pBase.y = p1.y;
       
   
```

### <a name="jsVectors_length"></a>jsVectors::length(p1)


```javascript

var dx = p1.x;
var dy = p1.y;
return Math.sqrt( dx*dx + dy*dy );        
    
```

### <a name="jsVectors_linesIntersect"></a>jsVectors::linesIntersect(p0, p1, v0, v1)


```javascript

var x1 = p0.x,
    y1 = p0.y,
    x2 = p1.x,
    y2 = p1.y,
    x3 = v0.x,
    y3 = v0.y,
    x4 = v1.x,
    y4 = v1.y;

var x=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
var y=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
if (isNaN(x)||isNaN(y)) {
    return false;
} else {
    if (x1>=x2) {
        if (!(x2<=x&&x<=x1)) {return false;}
    } else {
        if (!(x1<=x&&x<=x2)) {return false;}
    }
    if (y1>=y2) {
        if (!(y2<=y&&y<=y1)) {return false;}
    } else {
        if (!(y1<=y&&y<=y2)) {return false;}
    }
    if (x3>=x4) {
        if (!(x4<=x&&x<=x3)) {return false;}
    } else {
        if (!(x3<=x&&x<=x4)) {return false;}
    }
    if (y3>=y4) {
        if (!(y4<=y&&y<=y3)) {return false;}
    } else {
        if (!(y3<=y&&y<=y4)) {return false;}
    }
}
return true;
    
```

### <a name="jsVectors_mirrorVector"></a>jsVectors::mirrorVector(v1, along, base)


```javascript

// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along.x - base.x;   
tn1.y = along.y - base.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

v1.x = v1.x - base.x;
v1.y = v1.y - base.y;

// if the 'j' or normal projection is positive, turn around
if( this.dotProd(v1,nv1) > 0) 
    this.rotate(nv1, Math.PI);        

this.normalize(tn1);
this.normalize(nv1);

// Create positive coordinates of the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( this.dotProd(v1,nv1) );
//             tnProd = Math.abs( this.dotProd(v1,tn1) );
    
var tnProd = this.dotProd(v1,tn1);
// then, project the length of the base vectors to get the new vector space
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;   

v1.x += base.x;
v1.y += base.y;

return v1;        
    
```

### <a name="jsVectors_normalize"></a>jsVectors::normalize(v)


```javascript

var len = Math.sqrt( v.x*v.x + v.y*v.y);

if(len==0) {
    throw "Error normalizing vector: the length of the vector was zero";
}

v.x = v.x/len;
v.y = v.y/len;
return v;
    
```

### <a name="jsVectors_opposeVector"></a>jsVectors::opposeVector(v1, along)


```javascript


// the direction tangent and normal are normalized and the vector is projected into it            
tn1.x = along,x;   
tn1.y = along.y;
nv1.x = -tn1.y;
nv1.y = tn1.x;

this.normalize(tn1);
this.normalize(nv1);

// Important: turn the tangent to opposing direction...
this.rotate(tn1, Math.PI);

// Create the projection of the vector to the 'base' cordinates
var nvProd = Math.abs( jsMath.dotProd(v1,nv1) ),
    tnProd = Math.abs( jsMath.dotProd(v1,tn1) );
    
// if the 'j' or normal projection is negative, turn around
if( this.dotProd(v1,nv1) < 0) 
    this.rotate(nv1, Math.PI);
    
// then, project the length of the vector to get the new vector
v1.x = nv1.x * nvProd + tn1.x *tnProd,
v1.y = nv1.y * nvProd + tn1.y *tnProd;        

return v1;
    
```

### <a name="jsVectors_pointInTriangle"></a>jsVectors::pointInTriangle(p, p0, p1, p2)


```javascript


var A = 1/2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
var sign = A < 0 ? -1 : 1;
var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_pointInTriangleBc"></a>jsVectors::pointInTriangleBc(p, bb)


```javascript

var A = bb.A;
var sign = bb.sign;
var s = (bb.s1 +  bb.s2 * p.x + bb.s3 * p.y);
var t = (bb.t1 +  bb.t2 * p.x + bb.t3 * p.y);

return s > 0 && t > 0 && (s + t) < 2 * A * sign;
        
    
```

### <a name="jsVectors_project"></a>jsVectors::project(vectorToProject)


```javascript


var p = vectorToProject;

pVector.x = p.x - pBase.x;
pVector.y = p.y - pBase.y;

prodResult.i = this.dotProd( pVector, iVect);
prodResult.j = this.dotProd( pVector, jVect);

return prodResult;

```

### <a name="jsVectors_rotate"></a>jsVectors::rotate(v, angle)


```javascript


var s = Math.sin(angle);
var c = Math.cos(angle);

var x = v.x,
    y = v.y;

v.x = x * c + y * s;
v.y = -x * s + y * c;

return v;
    
```

### <a name="jsVectors_rotateAround"></a>jsVectors::rotateAround(angle, v, around)


```javascript

this.sub(v, around);
this.rotate(v,angle);
this.add(v,around);
    
```

### <a name="jsVectors_sub"></a>jsVectors::sub(v1, v2)


```javascript

v1.x = v1.x - v2.x;
v1.y = v1.y - v2.y;
    
```

### <a name="jsVectors_tangentNormal"></a>jsVectors::tangentNormal(v1, v2, v3)


```javascript


var t1 = {};
t1.x = v2.x - v1.x;
t1.y = v2.y - v1.y;
var t2 = {};
t2.x = v3.x - v2.x;
t2.y = v3.y - v2.y;

var p = { x : t1.x+t2.x,
          y : t1.y+t2.y
        };
return this.normalize(p);
    
```

### <a name="jsVectors_triangleArea"></a>jsVectors::triangleArea(A, B, C)


```javascript

        
var area = A.x * ( B.y - C.y ) +
           B.x * ( C.y - A.y ) +
           C.x * ( A.y - B.y );
        
return Math.abs( area / 2);        
    
```

### <a name="jsVectors_triangleInTriangle"></a>jsVectors::triangleInTriangle(p0, p1, p2, q0, q1, q2)


```javascript

        
var bb = this.getBarCoeffs(p0,p1,p2);

if(this.pointInTriangleBc( q0, bb) ) return true;
if(this.pointInTriangleBc( q1, bb) ) return true;
if(this.pointInTriangleBc( q2, bb) ) return true;

var bb = this.getBarCoeffs(q0, q1, q2 );

if(this.pointInTriangleBc( p0, bb) ) return true;
if(this.pointInTriangleBc( p1, bb) ) return true;
if(this.pointInTriangleBc( p2, bb) ) return true;


if(this.linesIntersect( p0,p1, q0,q1)) return true;
if(this.linesIntersect( p1,p2, q0,q1)) return true;
if(this.linesIntersect( p2,p0, q0,q1)) return true;

if(this.linesIntersect( p0,p1, q1,q2)) return true;
if(this.linesIntersect( p1,p2, q1,q2)) return true;
if(this.linesIntersect( p2,p0, q1,q2)) return true;        

if(this.linesIntersect( p0,p1, q2,q0)) return true;
if(this.linesIntersect( p1,p2, q2,q0)) return true;
if(this.linesIntersect( p2,p0, q2,q0)) return true;             

return false;
    
```

### <a name="jsVectors_unProject"></a>jsVectors::unProject(projectedVector)


```javascript

var p = projectedVector;
deVector.x = p.i * iVect.x + p.j * jVect.x;
deVector.y = p.i * iVect.y + p.j * jVect.y;

deVector.x += pBase.x;
deVector.y += pBase.y;
return deVector;
   
```



   


   



      
    



      
    



      
    
      
            
# Class jsBezierCurve


The class has following internal singleton variables:
        
* jsMath
        
        
### <a name="jsBezierCurve_derivate"></a>jsBezierCurve::derivate(d, t)


```javascript

        
var P0 = this._points[d][0],
    P1 = this._points[d][1],
    P2 = this._points[d][2],
    P3 = this._points[d][3];
    
var t2 = t*t;
var nt = 1-t;
var nt2 = nt*nt;

// dP(t) / dt =  -3(1-t)^2 * P0 + 3(1-t)^2 * P1 - 6t(1-t) * P1 - 3t^2 * P2 + 6t(1-t) * P2 + 3t^2 * P3
// or from Wikipedia
// 
// F(t)/dt = 3*nt2 * (P1-P0) + 6*t*nt*(P2-P1) + 3*t2*(P3-P2)

// var derivative = -3*nt2* P0 + 3*nt2 * P1 - 6*t*nt*P1 - 3*t2 * P2 + 6*t*nt * P2 + 3*t2 * P3;

// This should give the exact derivate of the point at certain position
var FT_dt = 3*nt2*(P1-P0) + 6*t*nt*(P2-P1) + 3*t2*(P3-P2);
return FT_dt;

```

### <a name="jsBezierCurve_distanceOf"></a>jsBezierCurve::distanceOf(x, y)


```javascript

        var t = this.findClosestT(x,y);
        var dx = this.x(t)-x,
            dy = this.y(t)-y;
        return Math.sqrt(dx*dx+ dy*dy);
    
```

### <a name="jsBezierCurve_findClosestT"></a>jsBezierCurve::findClosestT(x, y)


```javascript

        var tStart = 0, tMiddle = 0.5, tEnd = 1;
        var iterations = 10;
        
        while(iterations--) {
            var d0_x = this.x(tStart) - x,
                d0_y = this.y(tStart) - y,
                d2_x = this.x(tEnd)-x,
                d2_y = this.y(tEnd)-y;
            var d0 = Math.sqrt( d0_x*d0_x +  d0_y*d0_y),
                d2 = Math.sqrt( d2_x*d2_x +  d2_y*d2_y);
                
            if(d0<d2) {
                tEnd = tMiddle;
            } else {
                tStart = tMiddle;
            }
            tMiddle = tStart + ( tEnd - tStart ) / 2;
        }
        var d0_x = this.x(tStart) - x,
            d0_y = this.y(tStart) - y,
            d1_x = this.x(tMiddle)-x,
            d1_y = this.y(tMiddle)-y;            
            d2_x = this.x(tEnd)-x,
            d2_y = this.y(tEnd)-y;
        var d0 = Math.sqrt( d0_x*d0_x +  d0_y*d0_y),
            d1 = Math.sqrt( d1_x*d1_x +  d1_y*d1_y),
            d2 = Math.sqrt( d2_x*d2_x +  d2_y*d2_y);
            
        if(d0<d1 && d0<d2) return tStart;
        if(d2<d1 && d2<d0) return tEnd;
        return tMiddle;
    
```

### <a name="jsBezierCurve_fitListTo"></a>jsBezierCurve::fitListTo(list)


```javascript

var start = {
  x:  list[0].point_x(0),
  y:  list[0].point_y(0)
};

var ei = list.length-1;

var end = {
  x:  list[ei].point_x(3),
  y:  list[ei].point_y(3)
};

// what we have here is a list of segments, starting from (x,y) ending to (x2,y2)
// have to rotate
// have to scale

var myStart = {
    x : this.x(0),
    y : this.y(0)
};
var myEnd = {
    x : this.x(1),
    y : this.y(1)
};
var dx = myEnd.x - myStart.x,
    dy = myEnd.y - myStart.y;
    
var myLen = Math.sqrt( dx*dx + dy*dy );

var ldx = end.x - start.x,
    ldy = end.y - start.y;

var listLen = Math.sqrt( ldx*ldx + ldy*ldy );
var relAngle = jsMath.angleBetween({
    x : dx, y : dy
}, {
    x : ldx, y : ldy
});

// TODO: convert to path parser fromBezierArray()
// make a quaternion list
// scale & rotate the quaternion data to create new path




```

### <a name="jsBezierCurve_fromLine"></a>jsBezierCurve::fromLine(p0, p1)


```javascript

var len  = p1.x - p0.x;
var step = len/3;
this.initCoeffs(0, p0.x, p0.x+step, p0.x+step*2, p1.x);

var len  = p1.y - p0.y;
var step = len/3;
this.initCoeffs(1, p0.y, p0.y+step, p0.y+step*2, p1.y);


```

### <a name="jsBezierCurve_fromPoints"></a>jsBezierCurve::fromPoints(p0, p1, p2, p3)


```javascript
this.initCoeffs(0, p0.x, p1.x, p2.x, p3.x);
this.initCoeffs(1, p0.y, p1.y, p2.y, p3.y);
```

### <a name="jsBezierCurve_fromQuadCurve"></a>jsBezierCurve::fromQuadCurve(p0, p1, p2)


```javascript
//CP1 = QP0 + 2/3 *(QP1-QP0)
//CP2 = QP2 + 2/3 *(QP1-QP2)


this.initCoeffs(0, p0.x, p0.x+(2/3)*(p1.x-p0.x), p2.x + (2/3)*(p1.x-p2.x), p2.x);
this.initCoeffs(0, p0.y, p0.y+(2/3)*(p1.y-p0.y), p2.y + (2/3)*(p1.y-p2.y), p2.y);

/*
p1.x, p2.x, p3.x);
this.initCoeffs(1, p0.y, p1.y, p2.y, p3.y);

return {
    p0 : p0,
    p1 : p0 + 2/3 *(p1-p0),
    p2 : p2 + 2/3 *(p1-p2),
    p3 : p2
}
*/

```

### jsBezierCurve::constructor( t )

```javascript

this._points = [];
this._m = [];

if(!jsMath) jsMath = jsVectors();
```
        
### <a name="jsBezierCurve_initCoeffs"></a>jsBezierCurve::initCoeffs(d, v0, v1, v2, v3)


```javascript

        if(!this._coeffs) 
            this._coeffs = [];
            
        if(!this._coeffs[d]) this._coeffs[d] = [];
        if(!this._points[d]) this._points[d] = [];

        // the actual points used in each dimension
        this._points[d][0] = v0;
        this._points[d][1] = v1;
        this._points[d][2] = v2;
        this._points[d][3] = v3;

        var c = this._coeffs[d];
        c[0] = 3 * (v1 - v0);
        c[1] = 3 * (v2 - v1) - c[0];
        c[2] = v3 - v0 - c[0] - c[1];
        c[3] = v0;
        /*
        if(d==0) {
            this._m[0].x = v0;
            this._m[1].x = v1;
            this._m[2].x = v2;
            this._m[3].x = v3;
        }  
        if(d==1) {
            this._m[0].y = v0;
            this._m[1].y = v1;
            this._m[2].y = v2;
            this._m[3].y = v3;
        }
*/
    
```

### <a name="jsBezierCurve_inverseProject"></a>jsBezierCurve::inverseProject(projection)


```javascript

        
        var pt = projection.t;
        
        var n = this.normal(pt,true);
        
        var p_x = n.x * projection.nvProd + this.x(pt),
            p_y = n.y * projection.nvProd + this.y(pt);
        
        var t = this.tangent(pt, true);
        
        p_x = p_x + projection.tangetProd * t.x;
        p_y = p_y + projection.tangetProd * t.y;
        
        // inverse x and inverse y
        projection.ix = p_x;
        projection.iy = p_y;
            
    
```

### <a name="jsBezierCurve_mirrorControls"></a>jsBezierCurve::mirrorControls(t)


```javascript

var base = {
    x : this._points[0][0],
    y : this._points[1][0]
};

var along = {
    x : this._points[0][3],
    y : this._points[1][3]
};

var v1 = {
    x : this._points[0][1],
    y : this._points[1][1]
};
var v2 = {
    x : this._points[0][2],
    y : this._points[1][2]
};

jsMath.mirrorVector( v1, along, base);
jsMath.mirrorVector( v2, along, base);

this.initCoeffs( 0, base.x, v1.x, v2.x, along.x);
this.initCoeffs( 1, base.y, v1.y, v2.y, along.y);

```

### <a name="jsBezierCurve_normal"></a>jsBezierCurve::normal(t, bUnitVector)


```javascript

        var v = this.tangent(t);
        // direction of the curve at certain point...
        var vx = v.x;
        v.x = -v.y;
        v.y = vx;
        if( bUnitVector) jsMath.normalize(v);
        return v;
    
```

### <a name="jsBezierCurve_point_x"></a>jsBezierCurve::point_x(i)


```javascript

        return this._points[0][i];
    
```

### <a name="jsBezierCurve_point_y"></a>jsBezierCurve::point_y(i)


```javascript

        return this._points[1][i];
    
```

### <a name="jsBezierCurve_points"></a>jsBezierCurve::points()


```javascript

        return this._m;
    
```

### <a name="jsBezierCurve_projectPoint"></a>jsBezierCurve::projectPoint(x, y, projection)


```javascript

        
        // logaritmic function ? 
        
        var maxCnt=20;
        var t = 0.5, step = 0.25; // start from the middle
        
        while( maxCnt--) {
            
            // We try to find a point where the projection to the tangent is as small as possible
            var tn = this.tangent(t,true);
            dv.x = x - this.x(t);
            dv.y = y - this.y(t);
            var prod = dv.x * tn.x  +  dv.y*tn.y;
            
            // close enough
            if( Math.abs( prod ) < 0.05 ) {
                // found it...
                break;
            }
            if(prod > 0) {
                t += step;
            } else {
                t += -step;
            }
            step = step / 2;
        }
        
        var n = this.normal(t,true);
        if(!projection) projection = {};
        projection.tangentProd = prod;
        projection.nvProd = n.x * dv.x + n.y * d.y;
        projection.nv_x = n.x;
        projection.nv_y = n.y;
        projection.tn_x = tn.x;
        projection.tn_y = tn.y;
        projection.ix = 0; // when projected back, the inversed coords here
        projection.iy = 0;
        projection.t = t;
        
        return projection;        
    
```

### <a name="jsBezierCurve_setControls"></a>jsBezierCurve::setControls(p0, p1, p2, p3, fn)


```javascript

this.initCoeffs(0, p0.x, p1.x, p2.x, p3.x);
this.initCoeffs(1, p0.y, p1.y, p2.y, p3.y);

    
```

### <a name="jsBezierCurve_split"></a>jsBezierCurve::split(t)


```javascript


var plist = this._points[0];
var v1 = this.splitCoeff(plist[0],plist[1],plist[2],plist[3],t);
plist = this._points[1];
var v2 = this.splitCoeff(plist[0],plist[1],plist[2],plist[3],t);

this.fromPoints(  { x : v1.p0, y : v2.p0 },
                { x : v1.p1, y : v2.p1 },
                { x : v1.p2, y : v2.p2 },
                { x : v1.p3, y : v2.p3 }
);

var b2 = jsBezierCurve();
b2.fromPoints(  { x : v1.p3, y : v2.p3 },
                { x : v1.p4, y : v2.p4 },
                { x : v1.p5, y : v2.p5 },
                { x : v1.p6, y : v2.p6 }
);

return b2;

```

### <a name="jsBezierCurve_splitCoeff"></a>jsBezierCurve::splitCoeff(P0, P1, P2, P3, t)


```javascript
var v = {};
v.p0 = P0;
v.p1 = (1-t)*P0 + t*P1;
var m2 = (1-t)*P1 + t*P2;
v.p5 = (1-t)*P2 + t*P3;

v.p2  = (1-t)*v.p1 + t*m2;
v.p4  = (1-t)*m2 + t*v.p5;
v.p3  = (1-t)*v.p2 + t*v.p4;        
v.p6  = P3;

return v;
```

### <a name="jsBezierCurve_step"></a>jsBezierCurve::step(t, dim)


```javascript

        if(!this._coeffs) return;
        var c = this._coeffs[dim];
        if(!c) return;
        var t2 = t*t, t3 = t2*t;
        return c[2] * t3 + c[1] * t2 + c[0] *t + c[3];
    
```

### <a name="jsBezierCurve_tangent"></a>jsBezierCurve::tangent(t, bUnitVector)


```javascript

        // direction of the curve at certain point...
        var nv = {};
        nv.x = this.derivate(0,t);
        nv.y = this.derivate(1,t);
        if( bUnitVector) jsMath.normalize(nv);
        return nv;
    
```

### <a name="jsBezierCurve_x"></a>jsBezierCurve::x(t)


```javascript

        return this.step(t,0);
    
```

### <a name="jsBezierCurve_y"></a>jsBezierCurve::y(t)


```javascript

        return this.step(t,1);
    
```

### <a name="jsBezierCurve_z"></a>jsBezierCurve::z(t)


```javascript
return this.step(t,2);
```



   


   



      
    
      
            
# Class displayItem


The class has following internal singleton variables:
        
* _renderFunctions
        
* _handleRenderFn
        
* _activeItems
        
* _debugView
        
* _initDone
        
* _renderables
        
* _cameraList
        
* _cameraFunctions
        
* _activeCamera
        
* _displayList
        
* _keyboard
        
* _renderScope
        
* _activeChangeListeners
        
* _objectCache
        
* lastOnMs
        
* minDeltaMs
        
        
### <a name="displayItem__callCamera"></a>displayItem::_callCamera(t)


```javascript
var rt = this.renderClass();

if(_cameraFunctions[rt]) {
    _cameraFunctions[rt](this);
} 
```

### <a name="displayItem__callRender"></a>displayItem::_callRender(t)


```javascript
var rt = this.renderClass();

if(!_renderFunctions) return;

if(_renderFunctions[rt]) {
    _renderFunctions[rt](this);
} else {
  if(this._renderFn) {
    // this._renderFn();
  }
}

var data = this.getRenderData();
data.lastIndex = _renderables.renderIndex;

if(this.items) {
    this.items.forEach(function(i) {
        i._callRender();
    });
}

if( this._handlesVisible )
    this.showHandles( );
```

### <a name="displayItem__classFactory"></a>displayItem::_classFactory(model)


```javascript

if(_objectCache && model && model.getID) {
    var id = model.getID(), obj = _objectCache[id];
    if( obj ) return obj;
}
```

### <a name="displayItem__find"></a>displayItem::_find(id)


```javascript
if(!_objectCache) _objectCache = {};
return _objectCache[id];
```

### <a name="displayItem__getTransfromFromModel"></a>displayItem::_getTransfromFromModel(me, model)


```javascript

var o = me;
me.on("x", function(oo,v) {
    var tm = o.getTransformMatrix();
    tm.m30( v );
});
me.on("y", function(oo,v) {
    var tm = o.getTransformMatrix();
    tm.m31( v );
})
me.on("scaleFactor", function(oo,v) {
    var sm = o.getScaleMatrix();
    sm.scale( v );
});

me.on("rad", function(oo,v) {
    if(isNaN(v)) return;
    
    var sn = Math.sin(v),
        cs = Math.cos(v);
    var rm = o.getRotationMatrix();
    rm.m00( cs );    
    rm.m11( cs );   
    rm.m10( -1*sn );    
    rm.m01( sn );         
});    

var doR = false;
if(me.x && me.y) {
    me.translate(me.x(), me.y(), 0);
    doR = true;
}

if(me.rad) {
    var v = me.rad();
    if(!isNaN(v)) {
         var sn = Math.sin(v),
            cs = Math.cos(v);
        var rm = o.getRotationMatrix();
        rm.m00( cs );    
        rm.m11( cs );   
        rm.m10( -1*sn );    
        rm.m01( sn );              
    }
} 

if(me.scaleFactor) {
    me.scale( me.scaleFactor() );
    doR = true;
}  
```

### <a name="displayItem__onFrame"></a>displayItem::_onFrame(t)

This function is run on every frame, to update transformations for rendering and eventually to render items on screen.
```javascript
var ms = (new Date()).getTime();

if(lastOnMs) {
    var delta = ms - lastOnMs;
    if(delta > minDeltaMs) {
        minDeltaMs = delta * 2;
        
        lastOnMs = ms;
        return;
    }
}

lastOnMs = ms;

var index = _renderables.renderIndex;

var rObj,
    bCamInit = false;

// if the surface has a bitmap frame, like canvas, now is the time to clear it    
_displayList.forEach( function(display) { 
    display.getSurface().frameClear(index);
});

// transform the nodes in their matrix space    
_displayList.forEach( function(display) {     
    var cam = display.getCamera();
    cam._callCamera(); // initialize camera
    var root = cam.getRootNode();
    root.startRootTransform();
}); 

// render the display lists
_displayList.forEach( function(display) {     
    display.renderTree( );
});         

// some advanced surface, like 3rd party libraries, may have their own "render" function, which can be
// called here before the rendering tree setup.
_displayList.forEach( function(display) { 
    var s = display.getSurface();
    if(s.frameFinish) {
        s.frameFinish( index );
    }
});        

// saving the new transformations to remote data, if any
_displayList.forEach( function(display) {     
    var cam = display.getCamera();
    var root = cam.getRootNode();
    root.saveTransformUpdates();
});          

// The renderables is perhaps a bit difficult, is it???
_renderables.renderIndex++;

```

### <a name="displayItem__prepareCameras"></a>displayItem::_prepareCameras(t)


```javascript

if( _cameraList ) {
    _cameraList.forEach( function(cam) {
        if(cam._callCamera) cam._callCamera( );

    });
}
```

### <a name="displayItem_activeItemsBB"></a>displayItem::activeItemsBB(camera)

The bounding box for the active items.
```javascript

var rect = {};

// projection....
this.forActiveItems( function(item) {

    item.projectToCamera( camera );
    var view = item.getViewMatrix( camera );    
    
    var list = [];
    list.push( view.projectVector({
            x : 0, 
            y : 0,
            z : 0,
            w : 1
        }) );
    list.push( view.projectVector({
            x : item.w(), 
            y : 0,
            z : 0,
            w : 1
        }) ); 
    list.push( view.projectVector({
            x : item.w(), 
            y : item.h(),
            z : 0,
            w : 1
        }) );  
    list.push( view.projectVector({
            x : 0, 
            y : item.h(),
            z : 0,
            w : 1
        }) ); 
    
    list.forEach( function(v) {
         if(typeof(rect.xmin)=="undefined") {
             rect.xmin = v.x;
             rect.xmax = v.x;
         }
         if(typeof(rect.ymin)=="undefined") {
             rect.ymin = v.y;
             rect.ymax = v.y;
         }
         
         if(v.x < rect.xmin) rect.xmin = v.x;
         if(v.y < rect.ymin) rect.ymin = v.y;
         if(v.x > rect.xmax) rect.xmax = v.x;
         if(v.y > rect.ymax) rect.ymax = v.y;
    });
    
});

return rect;

```

### <a name="displayItem_addActiveItem"></a>displayItem::addActiveItem(item, bClearOthers)


```javascript

if(bClearOthers) {
    this.clearActiveItems();
}

if(this.isArray(item)) {
    var me = this;
    item.forEach( function(ii) {
        me.addActiveItem( ii );
    })
    return this;
}

if(_activeItems.indexOf( item ) >=0 ) return;

_activeItems.push( item );


_activeChangeListeners.forEach( function(fn) {
    fn(item);
})
```

### <a name="displayItem_addCamera"></a>displayItem::addCamera(cam)


```javascript


if(_cameraList.indexOf(cam)<0) {
    _cameraList.push(cam);
}
```

### <a name="displayItem_addToDisplay"></a>displayItem::addToDisplay(displayId, pDisplay)


```javascript

if(!this._displayList) {
    this._displayList = {};
}

if(this.isObject(displayId)) {
    pDisplay = displayId;
    displayId = pDisplay.id();
}

this._displayList[displayId] = pDisplay;
```

### <a name="displayItem_addToGroup"></a>displayItem::addToGroup(newParent)


```javascript

if(newParent == this ) return;

var p = this.parent()
if(p) p = p.parent();
if(p && p != newParent) {

    var transV = this.getRenderMatrix().projectVector({
        x : this.w() * this.ri(),
        y : this.h() * this.rj(),
        z : 0,
        w : 1
    });
    
    var newPInv = newParent.getRenderMatrix().createCopy().inverse();
    //var myRendTrans = this.getRenderMatrix().createTransformCopy();

    var invV = newPInv.projectVector( transV );

    var newR = newParent._rotMatrix.createCopy().inverse().matMul( this._rotMatrix );
    var newS = newParent._scaleMatrix.createCopy().inverse().matMul( this._scaleMatrix );
    this._transMatrix.m30( invV.x );
    this._transMatrix.m31( invV.y );
    this._transMatrix.m32( invV.z ); 
    
    //this._transMatrix.m30( newPInv.m30() );
    //this._transMatrix.m31( newPInv.m31() );
    //this._transMatrix.m32( newPInv.m32() );
    
    this._rotMatrix.copyFrom( newR );
    this._scaleMatrix.copyFrom( newS );
    
    this.remove();
    
    newParent.items.push( this );
    
    
    this.callRender();
    
}

```

### <a name="displayItem_addToRenderList"></a>displayItem::addToRenderList(obj)


```javascript

if(obj.isFulfilled && !obj.isFulfilled()) return;

if(_renderables) {
    var p = obj,
        np;
    while(np = p.parent()) {
        if(np.addToRenderList) {
            p = np;
        } else {
            break;
        }
    }
    
    if(_renderables.list.indexOf( p ) < 0) {
        _renderables.list.push( p );
    }
    
}
```

### <a name="displayItem_applyLocalTransform"></a>displayItem::applyLocalTransform(withRotPoint)


```javascript
// Wasting a bit resources here :/

var local = Matrix3D();

var ri = 0,
    rj = 0;
    
if(withRotPoint) {
    ri = withRotPoint.i;
    rj = withRotPoint.j;
} else {
    if(this.ri) {
        ri = this.ri();
        rj = this.rj();
    }
}

var toCorner = Matrix3D();
toCorner.translate( { x: -1*ri*this.w(),  y: -1*rj*this.h(), z:0});

local.matMul(this._transMatrix);
local.matMul(this._scaleMatrix);
local.matMul( this._rotMatrix);
local.matMul(toCorner);

return local;

```

### <a name="displayItem_applyTransforms"></a>displayItem::applyTransforms(parentMatrix, noRecurse)


```javascript
// Wasting a bit resources here :/

var local = Matrix3D();

if(!parentMatrix) {
    parentMatrix = Matrix3D();
} else {
    parentMatrix = parentMatrix.createCopy();
}

if(!this._lastParentMatrix) {
    this._lastParentMatrix = parentMatrix.createCopy();
} else {
    this._lastParentMatrix.copyFrom(parentMatrix);
}

this._scaleMatrix.blend();

var m0 = 1;

var ri = 0,
    rj = 0;
    
if(this.ri) {
    ri = this.ri();
    rj = this.rj();
}

var backToCenter = Matrix3D();
backToCenter.translate( { x: ri*this.w(),  y: rj*this.h(), z:0});
var toCorner = Matrix3D();
toCorner.translate( { x: -1*ri*this.w(),  y: -1*rj*this.h(), z:0});
var rotM = this._rotMatrix.createCopy();

local.matMul(this._transMatrix);

// -- used to be this:
//  this._beforeRot = this._renderMatrix.createCopy();
var beforeRot = parentMatrix.createCopy();
beforeRot.matMul( this._transMatrix );
this._beforeRot = beforeRot;

local.matMul(this._scaleMatrix);
local.matMul( this._rotMatrix);
local.matMul(toCorner);

this._localTransform = local;

parentMatrix.matMul( local );

if(this._renderMatrix) {
    this._renderMatrix.copyFrom( parentMatrix );
}

if(this.items && !noRecurse) {
    var rm = this._renderMatrix;
    this.items.forEach(function(i) {
        if(i.isFulfilled && !i.isFulfilled()) return;
        if(i.applyTransforms) {
            i.applyTransforms( rm );
        }
    });
}


/*
if(parentMatrix) {
    this._renderMatrix = parentMatrix.createCopy(); 
} else {
    this._renderMatrix = Matrix3D();
}

if(!this._lastParentMatrix) {
    this._lastParentMatrix = this._renderMatrix.createCopy();
} else {
    this._lastParentMatrix.copyFrom(this._renderMatrix);
}

this._scaleMatrix.blend();

var m0 = 1;

var ri = 0,
    rj = 0;
    
if(this.ri) {
    ri = this.ri();
    rj = this.rj();
}

var backToCenter = Matrix3D();
backToCenter.translate( { x: ri*this.w(),  y: rj*this.h(), z:0});
var toCorner = Matrix3D();
toCorner.translate( { x: -1*ri*this.w(),  y: -1*rj*this.h(), z:0});
var rotM = this._rotMatrix.createCopy();

this._renderMatrix.matMul(this._transMatrix);
this._beforeRot = this._renderMatrix.createCopy();

this._renderMatrix.matMul(this._scaleMatrix);

// this._renderMatrix.matMul(backToCenter);
this._renderMatrix.matMul( this._rotMatrix);

// **** THE GRAVITY POINT HERE
this._renderMatrix.matMul(toCorner);


if(this.items && !noRecurse) {
    var rm = this._renderMatrix;
    this.items.forEach(function(i) {
        if(i.applyTransforms) {
            i.applyTransforms( rm );
        }
    });
}
*/
// this._renderMatrix.log();

return this._renderMatrix;

```

### <a name="displayItem_areHandlesVisible"></a>displayItem::areHandlesVisible(t)


```javascript
return this._handlesVisible;
```

### <a name="displayItem_askToRemove"></a>displayItem::askToRemove(id, val)


```javascript

if(!this._askToRemove) this._askToRemove = {};

if(typeof(val)=="undefined") return this._askToRemove[id];

this._askToRemove[id] = val;
```

### <a name="displayItem_callRender"></a>displayItem::callRender(t)


```javascript

this.render();
```

### <a name="displayItem_changeRenderClass"></a>displayItem::changeRenderClass(newClass)


```javascript


// refreshObject

var oldClass = this.renderClass();
this.renderClass( newClass );
var me = this;
this.forDisplays( function(d) {
    d.refreshObject( me, oldClass );
})


```

### <a name="displayItem_clearActiveItems"></a>displayItem::clearActiveItems(t)


```javascript

_activeItems.length = 0;
```

### <a name="displayItem_delegateEvent"></a>displayItem::delegateEvent(dispId, eventType, toObject)


```javascript


if(typeof(toObject)!="undefined") {
    
    if(!this._eventDelegates) this._eventDelegates = {};
    if(!this._eventDelegates[dispId]) this._eventDelegates[dispId] = {};

    this._eventDelegates[dispId][eventType] = toObject;
 
    return this;   
}

return this.findDelegatedEventhandler( dispId, eventType);
/*
if(this._eventDelegates) {
    if(this._eventDelegates[dispId]) {
        var obj = this._eventDelegates[dispId][eventType];
        if(obj) {
            if(obj._dragListeners) {
                if(obj._dragListeners[dispId]) {
                    var fns = obj._dragListeners[dispId][eventType];
                    return fns;
                }
            }
            
        }
    }
}
*/

```

### <a name="displayItem_domMVC"></a>displayItem::domMVC(obj, parentElem)


```javascript

if(!parentElem) {
    parentElem = obj;
    obj = this;
}

this.then( function() {

    if(!obj.items) return;
    
    obj._model.items.on("move", function(o, cmd) {
    
        var old = parentElem.child(cmd.from),
            after = parentElem.child(cmd.to);
    
        // a,b,c,d
        // c,a,b,d
        if(cmd.to != cmd.from) {
            // old.remove();
            if(cmd.to < cmd.from) {
                after.insertBefore(old);
            } else {
                after.insertAfter(old);
            }
        }
        return;
    
    });    
    obj._model.items.on("remove", function(o,i) {
    
        var ch = parentElem.child(i);
        if(ch) {
            ch.remove(); 
        }
    }); 
    
    parentElem.reIndex(); 
    
});


```

### <a name="displayItem_draggableFor"></a>displayItem::draggableFor(box, display)


```javascript

var me = this;

this.listenDragEventsFor(box, function() {
    
    if(!_keyboard.shiftDown) me.clearActiveItems();
    me.addActiveItem( me );

}, function(dragInfo) {

    if(me._movementLock) {
        if(me._movementLock.x) {
            dragInfo.delta.x = 0;
        }  
        if(me._movementLock.y) {
            dragInfo.delta.y = 0;
        } 
    }
    me._transMatrix.translate({
            x:dragInfo.start.x + dragInfo.delta.x, 
            y:dragInfo.start.y + dragInfo.delta.y, 
            z:dragInfo.start.z + dragInfo.delta.z});
    me.callRender();    
}, function() {
    
}, display, "move")

```

### <a name="displayItem_findAndRegisterCameras"></a>displayItem::findAndRegisterCameras(t)


```javascript
var me = this;

this.forChildren( function(i) {
    if(i.isCamera && i.isCamera()) {
        me.addCamera( i );   
    }
});

```

### <a name="displayItem_findCameras"></a>displayItem::findCameras(t)


```javascript

var list = [];

this.forChildren( function(i) {
    if(i.isCamera && i.isCamera()) list.push(i); 
});

return list;
```

### <a name="displayItem_findDelegatedEventhandler"></a>displayItem::findDelegatedEventhandler(dispId, eventType)


```javascript

var obj = this,
    d;
while(d = obj.isDelegatingEvents(dispId, eventType)) {
    obj = d;
}
// if(!obj.isDelegatingEvents(dispId, eventType)) return;

if(obj._dragListeners) {
    if(obj._dragListeners[dispId]) {
        var fns = obj._dragListeners[dispId][eventType];
        return fns;
    }
}

/*
if(this._eventDelegates) {
    if(this._eventDelegates[dispId]) {
        var obj = this._eventDelegates[dispId][eventType];
        if(obj) {
            if(obj._dragListeners) {
                if(obj._dragListeners[dispId]) {
                    var fns = obj._dragListeners[dispId][eventType];
                    return fns;
                }
            }
            
        }
    }
}
*/
```

### <a name="displayItem_forActiveItems"></a>displayItem::forActiveItems(fn)


```javascript

_activeItems.forEach( function(item) {
    fn(item); 
});
```

### <a name="displayItem_forDisplays"></a>displayItem::forDisplays(fn)


```javascript
if(!this._displayList) return;

var list = this._displayList;
for( var n in list ){
    if(list.hasOwnProperty(n)) {
        var v = list[n];
        fn(v);
    }
}
```

### <a name="displayItem_getActiveCamera"></a>displayItem::getActiveCamera(t)


```javascript

if(!_activeCamera) {
    _activeCamera = _cameraList[0];
}

return _activeCamera;
```

### <a name="displayItem_getCamera"></a>displayItem::getCamera(index)


```javascript

return _cameraList[index];
```

### <a name="displayItem_getDOMOffset"></a>displayItem::getDOMOffset(elem)


```javascript


while( elem && ( elem instanceof SVGElement) ) {
    elem = elem.parentNode;
}
if(!elem) return {
    x: 0, y: 0
}

var doc = elem && elem.ownerDocument,
    docElem = doc.documentElement,
    box;

// return getOffset(elem, doc, doc.documentElement);
// function getOffset(elem, doc, docElem, box) {

try {
    box = elem.getBoundingClientRect();
} catch(e) {}


var body = doc.body,
    win = window,
    clientTop = docElem.clientTop || body.clientTop || 0,
    clientLeft = docElem.clientLeft || body.clientLeft || 0,
    scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,
    scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
    top = box.top + scrollTop - clientTop,
    left = box.left + scrollLeft - clientLeft;

return {
    x : left,
    y : top
};

```

### <a name="displayItem_getLocalTransform"></a>displayItem::getLocalTransform(t)


```javascript
return this._localTransform;
```

### <a name="displayItem_getRenderData"></a>displayItem::getRenderData(id)


```javascript

if(!this._renderData) this._renderData = {};

if(!id && _renderScope) id = _renderScope;

if(id) {
   var key = "sub__"+id;
   if(!this._renderData[key]) this._renderData[key] = {}; 
   return this._renderData[key];
}

return this._renderData;
```

### <a name="displayItem_getRenderFn"></a>displayItem::getRenderFn(t)


```javascript

return this._renderFn;
```

### <a name="displayItem_getRenderMatrix"></a>displayItem::getRenderMatrix(t)


```javascript
return this._renderMatrix;
```

### <a name="displayItem_getRootNode"></a>displayItem::getRootNode(t)


```javascript

return this._rootNode;
```

### <a name="displayItem_getRotationMatrix"></a>displayItem::getRotationMatrix(t)


```javascript
return this._rotMatrix;
```

### <a name="displayItem_getScaleMatrix"></a>displayItem::getScaleMatrix(t)


```javascript
return this._scaleMatrix;
```

### <a name="displayItem_getSvgParser"></a>displayItem::getSvgParser(t)


```javascript

if(!this._svgParser) {
    var parser = this._svgParser = svgPathParser(),
        me = this;
    
    if(this.svgPath) {
        this.on("svgPath", function(o,v) {
            parser.parse(v);
            parser.makePathAbsolute();
            parser.fitPathInto( me.w(), me.h() );
        });
        this.on("w", function(o,v) {
            parser.fitPathInto( me.w(), me.h() );
        });        
        this.on("h", function(o,v) {
            parser.fitPathInto( me.w(), me.h() );
        });        
        var v;
        if(v = this.svgPath()) {
            parser.parse(v);
            parser.makePathAbsolute();
            parser.fitPathInto( me.w(), me.h() );        
        }
    }
    
    
/*
    var parser = svgPathParser();
    parser.parse(svgPath);
    parser.makePathAbsolute();
    parser.fitPathInto( w, h );
*/
}
return this._svgParser;
```

### <a name="displayItem_getTransformMatrix"></a>displayItem::getTransformMatrix(t)


```javascript
return this._transMatrix;
```

### <a name="displayItem_getViewMatrix"></a>displayItem::getViewMatrix(camera)


```javascript

if(!this._viewMatrix) {
    this._viewMatrix = {};
}

return this._viewMatrix[camera.localId()];
```

### <a name="displayItem_getX"></a>displayItem::getX(t)


```javascript
return this.getTransformMatrix().m30();
```

### <a name="displayItem_getY"></a>displayItem::getY(t)


```javascript
return this.getTransformMatrix().m31();
```

### <a name="displayItem_groupResizeHandler"></a>displayItem::groupResizeHandler(box, display, options)


```javascript

var sx,sy,
    me = this;

options = options || {};
var startM,
    startW,
    m,
    rendMCopy,
    skipThese;
    
if(!options.i) options.i=0;
if(!options.j) options.j=0;
    
this.listenDragEventsFor(box, function(dragInfo) {

    var gr = me._groupDelegate;
    if(gr) {
        // OK, the scale coordinate is found correctly using the screen coords
        var cam = me._groupDisplay.getCamera();
        me.projectToCamera( cam );
        var viewM = me.getViewMatrix( cam );
        // viewM.inverse();
        var rotPoint = viewM.projectVector({
            x : options.i *me.w(),
            y : options.j *me.h(),
            z : 0,
            w: 1
        });
        
        var bb = gr.activeItemsBB(me._groupDisplay.getCamera());
        var cx = rotPoint.x,
            cy = rotPoint.y;
            
        skipThese = {};
        gr.forActiveItems( function(ai) {
            
            gr.forActiveItems( function(i) {
                if(i==ai) return;
                var p = i;
                while( p = p.displayParent() ) {
                    if(p==ai) {
                        skipThese[i.localId()] = true;
                    }
                }
            }) 
        })              
        gr.forActiveItems( function(ai) {
            ai._oldRc = {  i : ai.ri(), j : ai.rj() };
            ai.moveRotationCenterToSCoords( cx, cy, me._groupDisplay );
        })        
        
        gr.forActiveItems( function(i) {
            i._grScaleM = i.getScaleMatrix().createCopy();
        });
    } else {
        return;
    }   
    if(options.i || options.j) {
        me.moveRotationCenterTo( options.i || 0, options.j || 0, display );
    } else {
        me.moveRotationCenterTo( 0, 0, display );
    }    
    startM = me._scaleMatrix.createCopy();
    startW = Math.sqrt( me.w()*me.w() + me.h()*me.h() );   

}, function(dragInfo) {
    
    if(!me._groupDelegate) return;
    
    try {
        var scalei = 1,
            scalej = 1;
        if(me.ri()<1) {
            scalei =  (1/(1-me.ri()));
        }  
        if(me.rj()<1) {
            scalej =  (1/(1-me.rj()));
        }      
        
        if(options.j) scalej = scalej * -1;
        if(options.i) scalei = scalei * -1;
    
        var ww = dragInfo.deltaIn.x*scalei + me.w(),
            hh = dragInfo.deltaIn.y*scalej + me.h();    
        var dragW = Math.sqrt( ww*ww + hh*hh );
        var scaleFactor = dragW / startW; 
        
        
        var gr = me._groupDelegate;
        if(gr) {
            gr.forActiveItems( function(i) {
                if(skipThese[i.localId()]) return;
                if(i._grScaleM) {
                    var mat = Matrix3D();
                    mat.scale( scaleFactor );
                    mat.matMul( i._grScaleM );
                    i._scaleMatrix.copyFrom( mat );       
                    i.callRender();                    
                }
            });
        }

        var mat = Matrix3D();
        mat.scale( scaleFactor );
        mat.matMul( startM );
        me._scaleMatrix.copyFrom( mat );       
        me.callRender();        

    } catch(e) {
        
    }


}, function() {
    var gr = me._groupDelegate;
    if(gr) {

        gr.forActiveItems( function(ai) {
            ai.moveRotationCenterTo( ai._oldRc.i, ai._oldRc.j , me._groupDisplay );
        })        

    }    
}, display,"groupresize"+options.j+options.i, {
    noActiveReset : true
});
/*
var sx,sy,
    me = this;

options = options || {};
var startM,
    startW,
    m,
    rendMCopy;
    
if(!options.i) options.i=0;
if(!options.j) options.j=0;

this.listenDragEventsFor(box, function() {
    if(options.i || options.j) {
        me.moveRotationCenterTo( options.i || 0, options.j || 0, display );
    } else {
        me.moveRotationCenterTo( 0, 0, display );
    }
    startM = me._scaleMatrix.createCopy();
    startW = Math.sqrt( me.w()*me.w() + me.h()*me.h() );    
}, function(dragInfo) {

    var scalei = 1,
        scalej = 1;
    if(me.ri()<1) {
        scalei =  (1/(1-me.ri()));
    }  
    if(me.rj()<1) {
        scalej =  (1/(1-me.rj()));
    }      
    
    if(options.j) scalej = scalej * -1;
    if(options.i) scalei = scalei * -1;

    var ww = dragInfo.deltaIn.x*scalei + me.w(),
        hh = dragInfo.deltaIn.y*scalej + me.h();    
    var dragW = Math.sqrt( ww*ww + hh*hh );
    var scaleFactor = dragW / startW;    

    var mat = Matrix3D();
    mat.scale( scaleFactor );
    mat.matMul( startM );
    me._scaleMatrix.copyFrom( mat );
    me.callRender();  

}, function() {
    
}, display, "resize"+options.j+options.i)

*/

```

### <a name="displayItem_groupRotationHandler"></a>displayItem::groupRotationHandler(box, display)


```javascript

var sx,sy,
    me = this;

var startM,
    startRot,
    startW,
    m,
    rendMCopy,
    cp_x,
    cp_y,
    startCenter;

var vect = jsVectors(),
    smList = [],
    skipThese = {};
    
this.listenDragEventsFor(box, function(dragInfo) {

    var gr = me._groupDelegate;
    if(gr) {

        var cam = me._groupDisplay.getCamera();
        me.projectToCamera( cam );
        var viewM = me.getViewMatrix( cam );
        // viewM.inverse();
        var rotPoint = viewM.projectVector({
            x : 0.5*me.w(),
            y : 0.5*me.h(),
            z : 0,
            w: 1
        });
        
        var cx = rotPoint.x,    
            cy = rotPoint.y;

        skipThese = {};
        gr.forActiveItems( function(ai) {
            
            gr.forActiveItems( function(i) {
                if(i==ai) return;
                var p = i;
                while( p = p.displayParent() ) {
                    if(p==ai) {
                        skipThese[i.localId()] = true;
                    }
                }
            }) 
        })  
        
        gr.forActiveItems( function(ai) {
            ai._oldRc = {  i : ai.ri(), j : ai.rj() };
            ai.moveRotationCenterToSCoords( cx, cy, me._groupDisplay );
        })        
        
        gr.forActiveItems( function(i) {
            i._grRotM = i.getRotationMatrix().createCopy();
        });
    } else {
        return;
    }   
    startM = me.getRotationMatrix().createCopy();
    me.moveRotationCenterTo( 0.5, 0.5, display );
    smList.length = 0;    
    // startM = me.getRotationMatrix().createCopy();
    sx = dragInfo.dv.relx;
    sy = dragInfo.dv.rely;
    
    cp_x = me.w()*me.ri();
    cp_y = me.h()*me.rj();
    
    startCenter = me.getViewMatrix(display.getCamera()).projectVector({
        x : cp_x,
        y : cp_y,
        z : 0,
        w : 1
    });

}, function(dragInfo) {
    
    if(!me._groupDelegate) return;
    
    try {
        var angle = vect.angleBetween({
            x : (dragInfo.dv.relx ) - startCenter.x,
            y : (dragInfo.dv.rely ) - startCenter.y       
        }, {
            x : (dragInfo.dv.relx + dragInfo.dv.dx) - startCenter.x,
            y : (dragInfo.dv.rely + dragInfo.dv.dy) - startCenter.y       
        });
        
        
        var gr = me._groupDelegate;
        if(gr) {
            gr.forActiveItems( function(i) {
                if(skipThese[i.localId()]) return;
                if(i._grRotM) {
                    var sCopy = i._grRotM.createCopy(),
                        rotM = Matrix3D();
                     rotM.rotate({
                        x : 0,
                        y : 0,
                        z : 1
                    }, angle);   
                    sCopy.matMul( rotM );
                    if(sCopy.isValidMatrix()) {
                        i._rotMatrix.copyFrom( sCopy );
                        i.callRender();          
                    }                    
                }
            });
        }

        var sCopy = startM.createCopy(),
            rotM = Matrix3D();
        rotM.rotate({
            x : 0,
            y : 0,
            z : 1
        }, angle);
        
        sCopy.matMul( rotM );
        if(sCopy.isValidMatrix()) {
            me._rotMatrix.copyFrom( sCopy );
            me.callRender();          
        }        
        

    } catch(e) {
        
    }


}, function() {
    var gr = me._groupDelegate;
    if(gr) {

        gr.forActiveItems( function(ai) {
            ai.moveRotationCenterTo( ai._oldRc.i, ai._oldRc.j , me._groupDisplay );
        })        

    }    
}, display,"rotategroup", {
    noActiveReset : true
});

```

### <a name="displayItem_handleRotationCenter"></a>displayItem::handleRotationCenter(box, display)


```javascript
var origLocalM;
var startI, startJ,
    me = this;

this.listenDragEventsFor( box, function() {
    origLocalM = me.applyLocalTransform();
    startI = me.ri();
    startJ = me.rj();
}, function(dragInfo) {
    
    var deltaI = dragInfo.deltaIn.x / me.w(),
        deltaJ = dragInfo.deltaIn.y / me.h();
        
    var newRi = startI + deltaI,
        newRj = startJ + deltaJ;
        
    // two matrixes...
    var origLocalM2 = me.applyLocalTransform({
            i : newRi,
            j : newRj
        });
    
    // where is the left corner, the position 0,0 is 
    
    var proj1 = origLocalM.projectVector({
        x : 0,
        y : 0,
        z : 0,
        w : 1
    });     
    
    var proj2 = origLocalM2.projectVector({
        x : 0,
        y : 0,
        z : 0,
        w : 1
    });
    
    console.log("The change of X in the projections is ", proj2.x - proj1.x);
    
    var diff_x = proj2.x - proj1.x; // origLocalM2.m30() - origLocalM.m30(),
        diff_y = proj2.y - proj1.y; // origLocalM2.m31() - origLocalM.m31(),
        diff_z = proj2.z - proj1.z; // origLocalM2.m32() - origLocalM.m32()
    
    console.log("diff_x is ", diff_x);
    console.log("diff_y is ", diff_y);
    // OK, the Z is not at the moment "available"
    
    me.ri( startI + deltaI );
    me.rj( startJ + deltaJ );
    
    // So, we have to move the transformation so that the origin stays at original position
    //me._transMatrix.m30( origLocalM.m30() - diff_x );
    //me._transMatrix.m31( origLocalM.m31() + diff_y );
    
    var rr = origLocalM.projectVector({
        x : diff_x,
        y : diff_y,
        z : diff_z,
        w : 0
    });


    me._transMatrix.m30( me._transMatrix.m30() - diff_x );
    me._transMatrix.m31( me._transMatrix.m31() - diff_y );
    me._transMatrix.m32( me._transMatrix.m32() - diff_z );
    
    me.callRender();    
}, function() {
    
}, display);

return;


var sx,sy,
    me = this,
    scr_sx,
    scr_sy,
    r_sx,
    r_sy,
    rendM,
    rScreenPos,
    i0,i1,j0,j1,
    o_kk_x, o_kk_y,
    scaleF,
    final_dx,
    final_dy,
    origLocalM,
    inverseLocalM;
this._beforeRot

var startI, startJ;
box.draggable( function(o,dv) {
    // Transforming coordinates...
    rendM = me.getRenderMatrix().createCopy();
    scr_sx = rendM.m30();
    scr_sy = rendM.m31();
    
    
    origLocalM = me.applyLocalTransform();
    inverseLocalM = origLocalM.createCopy().inverse();
    
    startM = me.getRenderMatrix().createCopy().inverse();
    startI = me.ri();
    startJ = me.rj();
    
    rScreenPos = rendM.projectVector({
        x : startI * me.w(),
        y : startJ * me.h(),
        z : 0,
        w : 1
    });
    
    console.log("rScreenPos ", rScreenPos);
    console.log("i vector ", rendM.m00(), rendM.m01());
    console.log("j vector ", rendM.m10(), rendM.m11());
    
    i0 = rendM.m00(), i1 = rendM.m01(),
    j0 = rendM.m10(), j1 = rendM.m11();
        
    var len = Math.sqrt( i0*i0 + i1*i1 );
    scaleF = len;
    i0 = i0 / len;
    i1 = i1 / len;
    j0 = j0 / len;
    j1 = j1 / len;
    
    sx = me._transMatrix.m30();
    sy = me._transMatrix.m31();
    
    // a new position for the center of the rotation vector
    var newR_x = rScreenPos.x,
        newR_y = rScreenPos.y;
    
    // cornerista tähän kohtaan vektori
    var c2r_x = scr_sx - newR_x,
        c2r_y = scr_sy - newR_y;
        
    // projisoi 
    var p2x = c2r_x * i0 - c2r_y * j0,
        p2y = -1*c2r_x * i1 + c2r_y * j1;
    
    o_kk_x = newR_x + p2x,
    o_kk_y = newR_y + p2y;    
    
}, function(o,dv) {
    
    try {
        
        var newDv = me.screenToItemCoords( dv, startM );

        var deltaI = newDv.dx / me.w(),
            deltaJ = newDv.dy / me.h();
            
        console.log("New ri ", startI, startI + deltaI);
        console.log("New rj ", startJ, startJ + deltaJ);
        
        var newRi = startI + deltaI,
            newRj = startJ + deltaJ;
            
        // two matrixes...
        var origLocalM2 = me.applyLocalTransform({
                i : newRi,
                j : newRj
            });
        
        // where is the left corner, the position 0,0 is 
        
        var proj1 = origLocalM.projectVector({
            x : 0,
            y : 0,
            z : 0,
            w : 1
        });     
        
        var proj2 = origLocalM2.projectVector({
            x : 0,
            y : 0,
            z : 0,
            w : 1
        });
        
        console.log("The change of X in the projections is ", proj2.x - proj1.x);
        
        var diff_x = proj2.x - proj1.x; // origLocalM2.m30() - origLocalM.m30(),
            diff_y = proj2.y - proj1.y; // origLocalM2.m31() - origLocalM.m31(),
            diff_z = proj2.z - proj1.z; // origLocalM2.m32() - origLocalM.m32()
        
        console.log("diff_x is ", diff_x);
        console.log("diff_y is ", diff_y);
        // OK, the Z is not at the moment "available"
        
        me.ri( startI + deltaI );
        me.rj( startJ + deltaJ );
        
        // So, we have to move the transformation so that the origin stays at original position
        //me._transMatrix.m30( origLocalM.m30() - diff_x );
        //me._transMatrix.m31( origLocalM.m31() + diff_y );
        
        var rr = origLocalM.projectVector({
            x : diff_x,
            y : diff_y,
            z : diff_z,
            w : 0
        });
        
        console.log("inverse produces change ", rr.x, rr.y);
        
        final_dx = diff_x;
        final_dy = diff_y;

        me._transMatrix.m30( me._transMatrix.m30() - diff_x );
        me._transMatrix.m31( me._transMatrix.m31() - diff_y );
        me._transMatrix.m32( me._transMatrix.m32() - diff_z );
        
        me.callRender();
        

    } catch(e) {
        if(_debugView) _debugView.text(e.message);
    }

}, function(o,dv) {
 
});
```

### <a name="displayItem_hideHandles"></a>displayItem::hideHandles(t)


```javascript

var rt = this.renderClass();

this._handlesVisible = false;
if(!_handleRenderFn) return;

if(_handleRenderFn[rt]) {
    this._handlesVisible = false;
    _handleRenderFn[rt]._hideHandlesFn( this, this._handleData);
    return;
}

if(this._hideHandlesFn) {
    this._handlesVisible = false;
    this._hideHandlesFn( this, this._handleData);
}


```

### displayItem::constructor( model )
Display item takes a model as constructor
```javascript

this._transMatrix = Matrix3D();
this._scaleMatrix = Matrix3D();
this._rotMatrix = Matrix3D();
this._renderMatrix = Matrix3D();
this._handleData = {};

if(model._model) model = model._model;

// debugger;

if(!this._movementLock)
    this._movementLock = {};   
    
if(!_activeItems)
   _activeItems = [];
  
var me = this,
    o = this;

// the display item model
this._model = model;

// The iterators for model
this.items = {
    push : function(objData) {
        if(objData._callRender) {
            // a displayItem object
             var objModel = objData._model;
             var oldP = objModel.parent();
             if(oldP) {
                 objModel.remove(); // detach from the old parent object
             }
             model.items.push( objModel );
             return;
        }
        model.items.push( objData );
    },     
    forEach : function(fn) {
        model.items.forEach( function(item) {
            var di = displayItem( item );
            if(di) {
                fn(di);
            }
        });
    }, 
    length : function() {
        return model.items.length();  
    },
    at : function(i) {
        var mo = model.items.at(i);
        if(mo) return displayItem( mo );
    }, 
    item : function(i) {
        var mo = model.items.at(i);
        if(mo) return displayItem( mo );
    }
}

// add this object to the cache
if(!_objectCache) _objectCache = {};
_objectCache[model.getID()] = this;

this._getTransfromFromModel( this, model );

if(!_initDone) {

     var ieversion = function()
    {
      var rv = -1; // Return value assumes failure.
      if (navigator.appName == 'Microsoft Internet Explorer')
      {
        var ua = navigator.userAgent;
        var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
        if (re.exec(ua) != null)
          rv = parseFloat( RegExp.$1 );
      }
      return rv;
    }  
    
    _keyboard = {
        shiftDown : false
    }
    
    // TODO: cleaner way to detect the shift down condition...
    /*
    $(document).on('keyup keydown', function(e){
        _keyboard.shiftDown = e.shiftKey;
        });    
    */
    
    _renderables = {
        list : [],
        renderIndex : 1
    };
    _cameraList = [];
    _displayList = [];
    _cameraFunctions = {};
    _renderFunctions = {};
    _activeChangeListeners = [];
    
    var me = this;
    
    var lastOnMs, minDeltaMs = 1;
    
    var iVal = 1/60;
    if(ieversion()>0) iVal = 1/10;
    
    minDeltaMs = 1;
    // This is the rendering loop...
    later().every( iVal, function() {   
        // TODO: enable the rendering loop here
        me._onFrame();
    });
    _initDone = true;
}

// TODO: add the rendering
// this.render();
```
        
### <a name="displayItem_isDelegatingEvents"></a>displayItem::isDelegatingEvents(dispId, eventType)


```javascript

if(this._eventDelegates) {
    if(this._eventDelegates[dispId]) {
        var obj = this._eventDelegates[dispId][eventType];
        if(obj) {
            return obj;
        }
    }
}
```

### <a name="displayItem_listenDragEventsFor"></a>displayItem::listenDragEventsFor(box, startFn, dragFn, endFn, display, eventType, options)


```javascript

if(!display) return;
if(!eventType) return;

var sx,sy,sz,
    rsx,rsy,rsz,
    me = this,
    rendInv;
this._beforeRot

var firstInters;

var dragInfo = {
    start : {},
    delta : {},
    startIn : {},
    currIn : {},
    deltaIn : {},
    deltaCenter : {},
    displayPos : {
        x : 0,
        y : 0
    }
}

var docWidth = $(document).width()/2,
    docHeight = $(document).height()/2,
    perspective = 1000,
    dispId = display.id(),
    options = options || {};

if(display) {

    var off = this.getDOMOffset( display.getSurface().getDom() );
    dragInfo.displayPos.x = off.x;
    dragInfo.displayPos.y = off.y;
    
    var surface = display.getSurface();
    docWidth = surface.getWidth()/2;
    docHeight = surface.getHeight()/2;
} else {
    docWidth = document.body.clientWidth/2;
    docHeight = document.body.clientHeight/2;
}


if(!this._dragListeners) this._dragListeners = {};
if(!this._dragListeners[dispId]) this._dragListeners[dispId] = {};
if(!this._dragListeners[dispId][eventType]) this._dragListeners[dispId][eventType] = {};

this._dragListeners[dispId][eventType] = {};

// Register new set of listeners of the drag events for this object...
this._dragListeners[dispId][eventType] = {
    start : function(o,dv) {

            perspective = 1000;    
            //console.log("Document size");
            //console.log(docWidth, docHeight, perspective);
        
            dv.relx = dv.sx - dragInfo.displayPos.x;
            dv.rely = dv.sy - dragInfo.displayPos.y;   
            
            
            // Transforming coordinates...
            sx = me._transMatrix.m30();
            sy = me._transMatrix.m31();
            sz = me._transMatrix.m32();
            
            var rendM = me.getViewMatrix(display.getCamera());
            
            rsx = rendM.m30();
            rsy = rendM.m31();
            rsz = rendM.m32();    
            
            rendInv = me.getViewMatrix(display.getCamera()).createCopy().inverse();
            
            if(!options.noActiveReset) {
                _activeItems.forEach( function(item) {
                    item.hideHandles();
                });
                if(!_keyboard.shiftDown) me.clearActiveItems();
                me.addActiveItem( me ) ; // _activeItems.push( me );
            }
            
            _activeItems.forEach( function(item) {
                item.showHandles();
            });
        
            firstInters = me.getViewMatrix(display.getCamera()).intersectPlane( {
                x : docWidth,
                y : docHeight,
                z : perspective
            },{
                x :  dv.relx + dv.dx,
                y :  dv.rely + dv.dy,
                z : 0
            });    
            
            if(!firstInters) return;
        
            dragInfo.dv = dv;
            dragInfo.o = o;
            dragInfo.startIntersection = firstInters;
            dragInfo.startIn.x = firstInters.x;
            dragInfo.startIn.y = firstInters.y;
            dragInfo.startIn.z = firstInters.z;
            
            startFn( dragInfo );
            
        },
    drag : function(o,dv) {
    
        if(!firstInters) {
            return;
        }
        dv.relx = dv.sx - dragInfo.displayPos.x;
        dv.rely = dv.sy - dragInfo.displayPos.y;   
        dragInfo.dv = dv;
        dragInfo.o = o;
        /*
        me.screenToItemCoords({
            x : dv.relx,
            y : dv.rely,
            dx : dv.dx,
            dy : dv.dy
        });
        */
        
        var m = me._beforeRot.createCopy();
        
        var cam = display.getCamera();
        var cMat = cam.getRenderMatrix().createCopy().inverse();
        cMat.matMul( m );
        m = cMat;
        
        m.inverse();
    
        var interS = me.getViewMatrix(display.getCamera()).intersectPlane( {
            x : docWidth,
            y : docHeight,
            z : perspective
        },{
            x :  dv.relx + dv.dx,
            y :  dv.rely + dv.dy,
            z : 0
        });
        
        if(!interS) return;
        
        var delta = {
            x : interS.x - firstInters.x,
            y : interS.y - firstInters.y,
            z : interS.z - firstInters.z
        };
        
        // console.log("The plane intersection at point ", interS);
        /*
        var res = m.projectVector({ x : dv.dx, 
                          y : dv.dy, 
                          z:  0, 
                          w:  0});
        me._transMatrix.translate({x:sx + res.x, y:sy + res.y, z: me._transMatrix.m32()});
        */
        
        var res = m.projectVector({   x : delta.x, 
                                      y : delta.y, 
                                      z:  delta.z, 
                                      w:  0});
                                      
        var rendRes = rendInv.projectVector({   x : delta.x, 
                                      y : delta.y, 
                                      z:  delta.z, 
                                      w:  0});       
                                      
        var currCenter = {   x : me.w()*me.ri(), 
                             y : me.h()*me.rj(), 
                             z:  0, 
                             w:  0};                                    
              
        dragInfo.start.x = sx;
        dragInfo.start.y = sy;
        dragInfo.start.z = sz;
        
        dragInfo.delta.x = res.x;
        dragInfo.delta.y = res.y;
        dragInfo.delta.z = res.z;    
        
        dragInfo.currIn.x = interS.x;
        dragInfo.currIn.y = interS.y;
        dragInfo.currIn.z = interS.z;
        
        dragInfo.deltaIn.x = rendRes.x;
        dragInfo.deltaIn.y = rendRes.y;
        dragInfo.deltaIn.z = rendRes.z; 
    
        
        dragFn(dragInfo);                              
     
        
    }, 
    end :  function(o,dv) {
        endFn();
    }
}


// And finally call the registered functions...
box.draggable( function(o,dv) {
    var delegate;
    if(delegate = me.delegateEvent(dispId, eventType)) {
        delegate.start(o,dv);
        return;
    }
    me._dragListeners[dispId][eventType].start(o,dv);
}, function(o,dv) {
    var delegate;
    if(delegate = me.delegateEvent(dispId, eventType)) {
        delegate.drag(o,dv);
        return;
    }    
    me._dragListeners[dispId][eventType].drag(o,dv);
}, function(o,dv) {
    var delegate;
    if(delegate = me.delegateEvent(dispId, eventType)) {
        delegate.end(o,dv);
        return;
    }    
    me._dragListeners[dispId][eventType].end(o,dv); 
});


```

### <a name="displayItem_localId"></a>displayItem::localId(t)


```javascript
if(!this.__id) {
    this.__id = this.guid();
}
return this.__id;
```

### <a name="displayItem_lockMovement"></a>displayItem::lockMovement(options)


```javascript

options = options || {};

if(!this._movementLock)
    this._movementLock = {};

if(typeof( options.x) !="undefined" ) {
    this._movementLock.x = options.x;
}
if(typeof( options.y !="undefined" ) ) {
    this._movementLock.y = options.y;
}
```

### <a name="displayItem_matchDomPosition"></a>displayItem::matchDomPosition(parentElem, myNode, obj)


```javascript
var from = myNode._index,
    to = obj.indexOf();

var old = parentElem.child(from),
    after = parentElem.child(to);

if(!after) return;

if(from != to) {
    if(to < from) {
        after.insertBefore(old);
    } else {
        after.insertAfter(old);
    }
}
```

### <a name="displayItem_moveRotationCenterTo"></a>displayItem::moveRotationCenterTo(i, j, display)


```javascript
var me = this;
var origLocalM = me.applyLocalTransform().createCopy();
var startI = me.ri();
var startJ = me.rj();

var newRi = i,
    newRj = j;
    
var origLocalM2 = me.applyLocalTransform({
        i : newRi,
        j : newRj
    });

var cam = display.getCamera(),
    camR = cam.getRenderMatrix();
    
//origLocalM = camR.createCopy().matMul( origLocalM );
//origLocalM2 = camR.createCopy().matMul( origLocalM2 );

var proj1 = origLocalM.projectVector({
    x : 0,
    y : 0,
    z : 0,
    w : 1
});     

var proj2 = origLocalM2.projectVector({
    x : 0,
    y : 0,
    z : 0,
    w : 1
});


var diff_x = proj2.x - proj1.x, 
    diff_y = proj2.y - proj1.y, 
    diff_z = proj2.z - proj1.z; 

me.ri( i );
me.rj( j );

var rr = origLocalM.projectVector({
    x : diff_x,
    y : diff_y,
    z : diff_z,
    w : 0
});


me._transMatrix.m30( me._transMatrix.m30() - diff_x );
me._transMatrix.m31( me._transMatrix.m31() - diff_y );
me._transMatrix.m32( me._transMatrix.m32() - diff_z );

// this.saveTransformUpdates();
this.x( me._transMatrix.m30() );
this.y( me._transMatrix.m31() );

me.callRender();    

```

### <a name="displayItem_moveRotationCenterToSCoords"></a>displayItem::moveRotationCenterToSCoords(x, y, display)


```javascript

var cam = display.getCamera();

this.projectToCamera( cam );
var view = this.getViewMatrix( cam );   

view = view.inverse();
var pv = view.projectVector({
            x : x, 
            y : y,
            z : 0,
            w : 1
        });
        
var i = pv.x / this.w(),
    j = pv.y / this.h();
    
// console.log("The projected coords position ", i,j);
    
this.moveRotationCenterTo( i, j, display );
```

### <a name="displayItem_onActiveChange"></a>displayItem::onActiveChange(fn)


```javascript
_activeChangeListeners.push(fn);
```

### <a name="displayItem_projectDimensionPoints"></a>displayItem::projectDimensionPoints(camera)


```javascript

this.projectToCamera( camera );

var view = this.getViewMatrix( camera );

var list = [];

list.push( view.projectVector({
            x : 0, 
            y : 0,
            z : 0,
            w : 1
        }) );
        
list.push( view.projectVector({
            x : this.w(), 
            y : 0,
            z : 0,
            w : 1
        }) );        
        
list.push( view.projectVector({
            x : 0, 
            y : this.h(),
            z : 0,
            w : 1
        }) );         
        
list.push( view.projectVector({
            x : this.w(), 
            y : this.h(),
            z : 0,
            w : 1
        }) );         

return list;
```

### <a name="displayItem_projectToCamera"></a>displayItem::projectToCamera(camera)


```javascript


var camM = camera.getRenderMatrix().createCopy().inverse(); // the final matrix of the camera
var thisM = this.getRenderMatrix();

// The resulting matrix?
camM.matMul( thisM );

if(!this._viewMatrix) {
    this._viewMatrix = {};
}

this._viewMatrix[camera.localId()] = camM;
```

### <a name="displayItem_registerCameraFn"></a>displayItem::registerCameraFn(name, fn)


```javascript

_cameraFunctions[name] = fn;
```

### <a name="displayItem_registerDisplay"></a>displayItem::registerDisplay(display)


```javascript

if(!_displayList) _displayList = [];

if(_displayList.indexOf( display) < 0 ) 
    _displayList.push( display );
```

### <a name="displayItem_registerRenderFn"></a>displayItem::registerRenderFn(name, fn)


```javascript

if(!_renderFunctions) _renderFunctions = {};

_renderFunctions[name] = fn;


```

### <a name="displayItem_removeActiveItem"></a>displayItem::removeActiveItem(obj)


```javascript
var i;
if( ( i = _activeItems.indexOf( obj )) >= 0) {
    _activeItems.splice(i, 1);
    obj.hideHandles();
}
```

### <a name="displayItem_removeFromDisplay"></a>displayItem::removeFromDisplay(displayId)


```javascript

if(!this._displayList) return;

this._displayList[displayId] = null;
```

### <a name="displayItem_render"></a>displayItem::render(t)


```javascript

this.addToRenderList( this );
```

### <a name="displayItem_renderDisplayList"></a>displayItem::renderDisplayList(obj)


```javascript

if(obj) {
    _displayList.forEach( function(d) {
        d.render( obj );
    });
}
```

### <a name="displayItem_renderHandles"></a>displayItem::renderHandles(t)


```javascript

```

### <a name="displayItem_resizeableFor"></a>displayItem::resizeableFor(box, display, options)


```javascript
var sx,sy,
    me = this;

options = options || {};
var startM,
    startW,
    m,
    rendMCopy;
    
if(!options.i) options.i=0;
if(!options.j) options.j=0;

this.listenDragEventsFor(box, function() {
    if(options.i || options.j) {
        me.moveRotationCenterTo( options.i || 0, options.j || 0, display );
    } else {
        me.moveRotationCenterTo( 0, 0, display );
    }
    startM = me._scaleMatrix.createCopy();
    startW = Math.sqrt( me.w()*me.w() + me.h()*me.h() );    
}, function(dragInfo) {

    var scalei = 1,
        scalej = 1;
    if(me.ri()<1) {
        scalei =  (1/(1-me.ri()));
    }  
    if(me.rj()<1) {
        scalej =  (1/(1-me.rj()));
    }      
    
    if(options.j) scalej = scalej * -1;
    if(options.i) scalei = scalei * -1;

    var ww = dragInfo.deltaIn.x*scalei + me.w(),
        hh = dragInfo.deltaIn.y*scalej + me.h();    
    var dragW = Math.sqrt( ww*ww + hh*hh );
    var scaleFactor = dragW / startW;    

    var mat = Matrix3D();
    mat.scale( scaleFactor );
    mat.matMul( startM );
    me._scaleMatrix.copyFrom( mat );
    me.callRender();  

}, function() {
    
}, display, "resize"+options.j+options.i)

```

### <a name="displayItem_resizeableHeightFor"></a>displayItem::resizeableHeightFor(box, display)


```javascript


var sx,sy,
    me = this;

var startM,
    startW,
    m,
    rendMCopy;

this.listenDragEventsFor(box, function() {
    me.moveRotationCenterTo( 0, 0, display );
    startW = me.h();
}, function(dragInfo) {
 
    var scale = 1;
    if(me.rj()<1) {
        scale =  (1/(1-me.rj()));
    }    
    var ww = dragInfo.deltaIn.y*scale + startW;    
    me.h(ww);
    me.callRender();  

}, function() {
    
},display,"resizeheight")

```

### <a name="displayItem_resizeableWidthFor"></a>displayItem::resizeableWidthFor(box, display, options)


```javascript

var sx,sy,
    me = this;

var startM,
    startW,
    m,
    rendMCopy;
options = options || {};
if(!options.inverse) options.inverse = 0;

this.listenDragEventsFor(box, function() {
    if(options && options.inverse ) {
        me.moveRotationCenterTo( 1, 0, display );
    } else {
        me.moveRotationCenterTo( 0, 0, display );
    }
    startW = me.w();
}, function(dragInfo) {
    
    var scale = 1;
    if(me.ri()<1) {
        scale =  (1/(1-me.ri()));
    }    
    if(options && options.inverse ) scale = scale*-1;

    var ww = dragInfo.deltaIn.x*scale + startW; 
    me.w(ww);
    me.callRender();  


}, function() {
    
},display,"resizewidth"+(options.inverse))

```

### <a name="displayItem_rotatableFor"></a>displayItem::rotatableFor(box, display)


```javascript

var sx,sy,
    me = this;

var startM,
    startRot,
    startW,
    m,
    rendMCopy,
    cp_x,
    cp_y,
    startCenter;

var vect = jsVectors();
this.listenDragEventsFor(box, function(dragInfo) {
    me.moveRotationCenterTo( 0.5, 0.5, display );
    startM = me.getRotationMatrix().createCopy();
    sx = dragInfo.dv.relx;
    sy = dragInfo.dv.rely;
    
    cp_x = me.w()*me.ri();
    cp_y = me.h()*me.rj();
    
    startCenter = me.getViewMatrix(display.getCamera()).projectVector({
        x : cp_x,
        y : cp_y,
        z : 0,
        w : 1
    });
    

}, function(dragInfo) {
    
    try {
        var angle = vect.angleBetween({
            x : (dragInfo.dv.relx ) - startCenter.x,
            y : (dragInfo.dv.rely ) - startCenter.y       
        }, {
            x : (dragInfo.dv.relx + dragInfo.dv.dx) - startCenter.x,
            y : (dragInfo.dv.rely + dragInfo.dv.dy) - startCenter.y       
        });
        // console.log("Angle is ", angle);
        
        var sCopy = startM.createCopy(),
            rotM = Matrix3D();
        rotM.rotate({
            x : 0,
            y : 0,
            z : 1
        }, angle);
        
        sCopy.matMul( rotM );
        if(sCopy.isValidMatrix()) {
            me._rotMatrix.copyFrom( sCopy );
            me.callRender();          
        }
    } catch(e) {
        
    }



}, function() {
    
}, display,"rotate");

```

### <a name="displayItem_rotate"></a>displayItem::rotate(v, rad)


```javascript

this._rotMatrix.rotate(v, rad );
```

### <a name="displayItem_rotate2D"></a>displayItem::rotate2D(angleDeg)


```javascript

var rad = Math.PI * angleDeg / 180;

this._rotMatrix.rotate({ x: 0, y:0, z:1 }, rad );
```

### <a name="displayItem_saveTransformUpdates"></a>displayItem::saveTransformUpdates(t)


```javascript
var o = this;

if(o.isFulfilled && !o.isFulfilled()) return;

if(this.x) {

    var tm = o.getTransformMatrix(),
        x = o.x(),
        y = o.y();
    if(tm.m30() != x || tm.m31() != y ) {
      console.log("Saving transformation matrix ");
      o.x( tm.m30() );
      o.y( tm.m31() );
    }

}

if(this.scaleFactor) {

    var sm = o.getScaleMatrix(),
        sf = sm.m00();
    if(o.scaleFactor()!=sf) {
      o.scaleFactor( sf );
    }
}


var rm = o.getRotationMatrix();
var angle = rm.getRotation2D();

var bChangeAngle = false;

if(o.rad) {
    if(o.rad() != angle) bChangeAngle = true;
} else {
    var oldA = o.get("rad");
    if(oldA && (oldA == angle)) {
        bChangeAngle = false;
    } else {
        bChangeAngle = true;
    }
}

if(bChangeAngle && !isNaN(angle)) o.set("rad", angle);

/*
if(this.rmatrix) {
    var bRDirty = false,
        r;
    if(o.rmatrix) {
       r = o.rmatrix;
       if(r.m00() != rm.m00()) bRDirty = true;
       if(r.m01() != rm.m01()) bRDirty = true;
       if(r.m10() != rm.m10()) bRDirty = true;
       if(r.m11() != rm.m11()) bRDirty = true;
    } else {
        rRDirty = true;
    }
    
    if(bRDirty) {
        console.log("Transform update, had dirty matrix");
        console.log(rm.m00(), "vs", r.m00());
        if(o.rmatrix) {
            
            var angle = rm.getRotation2D();
            o.set("rad", angle);
            
            r.m00( rm.m00() );
            r.m01( rm.m01() );
            r.m10( rm.m10() );
            r.m11( rm.m11() );          
            
        }    

    }
}*/

if(o.items) {
    o.items.forEach( function(i) {
        if(i.saveTransformUpdates) i.saveTransformUpdates();
    });
}


```

### <a name="displayItem_scale"></a>displayItem::scale(t)


```javascript
this._scaleMatrix.scale(t);
```

### <a name="displayItem_screenToItemCoords"></a>displayItem::screenToItemCoords(v, usingMatrix)


```javascript

// v.x, v.y

if(usingMatrix) {
    var invRendM = usingMatrix;
} else {
    var invRendM = this.getRenderMatrix().createCopy().inverse();
}
var res = invRendM.projectVector({
    x : v.x,
    y : v.y,
    z : 0,
    w : 1
});

// console.log("PROJECT", res.x, res.y);
if(typeof(v.dx)!="undefined") {
    var resDx = invRendM.projectVector({
        x : v.dx,
        y : v.dy,
        z : 0,
        w : 0
    });
    // console.log("PROJECT DX", resDx.x, resDx.y);
    res.dx = resDx.x;
    res.dy = resDx.y;
}
return res;


```

### <a name="displayItem_serialize"></a>displayItem::serialize(t)


```javascript


this.forChildren( function(o) {
  
    if(o.x && o.y) {
        var tm = o.getTransformMatrix();
        o.x( tm.m30() );
        o.y( tm.m31() );
    }
    
    if(o.scaleFactor) {
        var sm = o.getScaleMatrix();
        o.scaleFactor( sm.m00() );
    }    
       
});

return this._model.toData();
```

### <a name="displayItem_setClassHandleRenderers"></a>displayItem::setClassHandleRenderers(name, startFn, endFn)


```javascript

if(!_handleRenderFn) _handleRenderFn = {};

if(this.isArray(name)) {
    var me = this;
    name.forEach(function(n) {
        me.setClassHandleRenderers(n,startFn,endFn); 
    });
    return;
}

_handleRenderFn[name] = {
    _showHandlesFn : startFn,
    _hideHandlesFn : endFn
}


```

### <a name="displayItem_setDebugView"></a>displayItem::setDebugView(t)


```javascript
_debugView = t;
```

### <a name="displayItem_setGroupDelegate"></a>displayItem::setGroupDelegate(obj)


```javascript


this._groupDelegate = obj;
```

### <a name="displayItem_setHandleRenderFns"></a>displayItem::setHandleRenderFns(showHandlesFn, hideHandlesFn)


```javascript


this._showHandlesFn = showHandlesFn;
this._hideHandlesFn = hideHandlesFn;



```

### <a name="displayItem_setPosition"></a>displayItem::setPosition(x, y, z)


```javascript

var tm = this.getTransformMatrix();

if(this.isObject(x)) {
    this.setPosition(x.x,x.y,x.z);
    return this;
}

if(typeof(x)!="undefined") tm.m30(x);
if(typeof(y)!="undefined") tm.m31(y);
if(typeof(z)!="undefined") tm.m32(z);

return this;
```

### <a name="displayItem_setRenderData"></a>displayItem::setRenderData(data)


```javascript

this._renderData = data;
```

### <a name="displayItem_setRenderFn"></a>displayItem::setRenderFn(fn)


```javascript

this._renderFn = fn;
```

### <a name="displayItem_setRenderScope"></a>displayItem::setRenderScope(scope)


```javascript

_renderScope = scope;
```

### <a name="displayItem_setRootNode"></a>displayItem::setRootNode(obj)


```javascript

this._rootNode = obj;

```

### <a name="displayItem_showHandles"></a>displayItem::showHandles(t)


```javascript

var rt = this.renderClass();
this._handlesVisible = true;
if(!_handleRenderFn) {
    return;
}

if(_handleRenderFn[rt]) {
    this._handlesVisible = true;
    _handleRenderFn[rt]._showHandlesFn( this, this._handleData, this.getActiveCamera());
    return;
}

if(this._showHandlesFn) {
    this._handlesVisible = true;
    this._showHandlesFn( this, this._handleData, this.getActiveCamera());
}
```

### <a name="displayItem_startRootTransform"></a>displayItem::startRootTransform(t)


```javascript

var data = this.getRenderData(),
    index = _renderables.renderIndex || 1;

if(!data.lastTransIndex || (data.lastTransIndex < index) ) {
    data.lastTransIndex = index;
    this.applyTransforms();
} 

```

### <a name="displayItem_translate"></a>displayItem::translate(x, y, z)


```javascript

this._transMatrix.translate( { x: x, y:y, z:z });
```

### <a name="displayItem_ungroupItem"></a>displayItem::ungroupItem(t)


```javascript

var p = this._model.parent();
var oneUp;

if(p) oneUp = p.parent(); // now p = the display parent

if(oneUp && oneUp.parent()) {

    if(!oneUp.parent()) return;
    
    var twoParentsUp = oneUp.parent().parent(); // the second display parent...
    if(!twoParentsUp) return;
    
    // this is the displayItem object to be used.
    newP = displayItem( twoParentsUp );

    var newPInv = newP.getRenderMatrix().createCopy().inverse();
    var myRendTrans = this.getRenderMatrix().createTransformCopy();
    
    var transV = this.getRenderMatrix().projectVector({
        x : this.w() * this.ri(),
        y : this.h() * this.rj(),
        z : 0,
        w : 1
    });

    var invV = newPInv.projectVector( transV );

    var newR = p._rotMatrix.createCopy().matMul( this._rotMatrix );
    var newS = p._scaleMatrix.createCopy().matMul( this._scaleMatrix );
    
    this._transMatrix.m30( invV.x );
    this._transMatrix.m31( invV.y );
    this._transMatrix.m32( invV.z );   
    /*
    this._transMatrix.m30( newPInv.m30() );
    this._transMatrix.m31( newPInv.m31() );
    this._transMatrix.m32( newPInv.m32() );
    */
    
    this._rotMatrix.copyFrom( newR );
    this._scaleMatrix.copyFrom( newS );
    
    // remove from model and add to new parent object
    this._model.remove();
    newP.items.push( this );
    
    this.callRender();
    
}


```



   
    
## trait _dataTrait

The class has following internal singleton variables:
        
* _eventOn
        
* _commands
        
        
### <a name="_dataTrait_guid"></a>_dataTrait::guid(t)


```javascript

return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
        
//return Math.random();
// return Math.random().toString(36);
        
/*    
return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
*/
/*        
function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
               .toString(16)
               .substring(1);
  }

return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
       s4() + '-' + s4() + s4() + s4();*/
```

### <a name="_dataTrait_isArray"></a>_dataTrait::isArray(t)


```javascript

if(typeof(t)=="undefined") return this.__isA;

return Object.prototype.toString.call( t ) === '[object Array]';
```

### <a name="_dataTrait_isFunction"></a>_dataTrait::isFunction(fn)


```javascript
return Object.prototype.toString.call(fn) == '[object Function]';
```

### <a name="_dataTrait_isObject"></a>_dataTrait::isObject(t)


```javascript

if(typeof(t)=="undefined") return this.__isO;

return t === Object(t);
```


    
    
    
## trait listTrait

The class has following internal singleton variables:
        
* _eventOn
        
* _commands
        
        
### <a name="listTrait_displayParent"></a>listTrait::displayParent(t)


```javascript

var p = this._model.parent();
if(p) {
    var pp = p.parent();
    if(pp) {
        return displayItem(pp);
    }
}
```

### <a name="listTrait_firstChild"></a>listTrait::firstChild(t)


```javascript

if(this.items) {
    return this.items.item(0);
}
```

### <a name="listTrait_forChildren"></a>listTrait::forChildren(fn)


```javascript
fn(this);
if(this.items) {
    var me = this;
    this.items.forEach(function(subItem) {
        subItem.forChildren(fn);
    });
}
```

### <a name="listTrait_next"></a>listTrait::next(item)


```javascript

if(item) {
   return this; 
}

var i = this._model.indexOf(),
    p = this._model.parent();
    
if(p) return p.item( i+1 ); 
```

### <a name="listTrait_prev"></a>listTrait::prev(item)


```javascript
if(item) {
   console.error("Setting prev and next not implemented");
   /*
   var oldP = item.parent();
   var myInd = this.indexOf();
   var myP = this.parent();
   
   if(oldP) {
       if(myP != oldP) {
           item.remove();
           myP.push( item );
       }
   } else {
       myP.push( item );
   }

   item.moveToIndex( myInd  );
   */
   return this;    
}

var i = this._model.indexOf(),
    p = this._model.parent();
    
if(p && (i>0)) return p.item( i-1 ); 
```


    
    
    
## trait objectHelpers

The class has following internal singleton variables:
        
* _eventOn
        
* _commands
        
        
### <a name="objectHelpers_createBox"></a>objectHelpers::createBox(t)


```javascript

```

### <a name="objectHelpers_createEmptyBook"></a>objectHelpers::createEmptyBook(t)


```javascript
return _data({
  "data": {
    "type": "displayItem",
    "renderClass": "book",
    "w": 1000,
    "h": 1000,
    "ri": 0,
    "rj": 0,
    "items": {
      "data": [
        {
          "data": {
            "type": "displayItem",
            "renderClass": "page",
            "w": 1000,
            "h": 1000,
            "ri": 0,
            "rj": 0,
            "items": {
              "data": [],
              "__id": this.guid()
            },
            "rmatrix": {
              "data": {
                "m00": 1,
                "m01": 0,
                "m02": 0,
                "m10": 0,
                "m11": 1,
                "m12": 0,
                "m20": 0,
                "m21": 0,
                "m22": 1
              },
              "__id": this.guid()
            }
          },
          "__id": this.guid()
        }
      ],
      "__id": this.guid()
    },
    "rmatrix": {
      "data": {
        "m00": 1,
        "m01": 0,
        "m02": 0,
        "m10": 0,
        "m11": 1,
        "m12": 0,
        "m20": 0,
        "m21": 0,
        "m22": 1
      },
      "__id": this.guid()
    }
  },
  "__id": this.guid()
});
```

### <a name="objectHelpers_createObject"></a>objectHelpers::createObject(className, options)


```javascript

options = options || {};
/*
,
                    "rmatrix": {
                      "data": {
                        "m00": 1,
                        "m01": 0,
                        "m02": 0,
                        "m10": 0,
                        "m11": 1,
                        "m12": 0,
                        "m20": 0,
                        "m21": 0,
                        "m22": 1
                      },
                      "__id": "i7jeyl18loe9i21osxgvsm140w"
                    }
*/
var plainData = {
                type : "displayItem",
                renderClass : className,
                bgcolor : "red",
                x : 0,
                y : 0,
                w : 300,
                h : 300,
                ri : 0,
                rj : 0,
                alpha : 1,
                scaleFactor : 1,
                rmatrix : {
                    m00 : 1, m01 : 0, m02 : 0,  
                    m10 : 0, m11 : 1, m12 : 0,  
                    m20 : 0, m21 : 0, m22 : 1
                },
                items : []
            };
            
if(options) {
    for(var n in options) {
        if(n=="noParent") continue;
        plainData[n] = options[n];
    }
}

if(options.noParent) {
    var obj = _data(plainData);
    return obj;
} 

var i = this.items.length();
this.items.push(plainData);


var newItem = displayItem( this.items.at(i) );

return newItem;


// --- the old insert is below
/*
var obj = _data(plainData);

var me = this;
if(this.items && !options.noParent ) {
    obj.then(
        function() {
            console.log("The new item about to be pushed to the array of items");
            me.items.push( obj );
        });
    
}
return obj;
*/
```


    
    
    
## trait properties

The class has following internal singleton variables:
        
* _eventOn
        
* _commands
        
        
### <a name="properties_align"></a>properties::align(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("align", t);
    return this;
}
return this._model.get("align");
```

### <a name="properties_alpha"></a>properties::alpha(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("alpha", t);
    return this;
}
return this._model.get("alpha");
```

### <a name="properties_autoFit"></a>properties::autoFit(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("autoFit", t);
    return this;
}
return this._model.get("autoFit");
```

### <a name="properties_bgcolor"></a>properties::bgcolor(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("bgcolor", t);
    return this;
}
return this._model.get("bgcolor");
```

### <a name="properties_fitToPage"></a>properties::fitToPage(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("fitToPage", t);
    return this;
}
return this._model.get("fitToPage");
```

### <a name="properties_fontFamily"></a>properties::fontFamily(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("fontFamily", t);
    return this;
}
return this._model.get("fontFamily");
```

### <a name="properties_fontSize"></a>properties::fontSize(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("fontSize", t);
    return this;
}
return this._model.get("fontSize");
```

### <a name="properties_h"></a>properties::h(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("h", t);
    return this;
}
return this._model.get("h");
```

### <a name="properties_hasOwn"></a>properties::hasOwn(propName)


```javascript
return this._model.hasOwn(propName);
```

### <a name="properties_model"></a>properties::model(t)


```javascript
return this._model;
```

### <a name="properties_parent"></a>properties::parent(t)


```javascript
var p = this._model.parent();
if(p) {
    return _objectCache[p.getID()];
}

```

### <a name="properties_rad"></a>properties::rad(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("rad", t)
    return this;
}
return this._model.get("rad");
```

### <a name="properties_renderClass"></a>properties::renderClass(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("renderClass", t);
    return this;
}
return this._model.get("renderClass");
```

### <a name="properties_ri"></a>properties::ri(t)


```javascript
if(typeof(t) != "undefined") {
    this._ri = t; 
    return this;
}
return this._ri || 0;

```

### <a name="properties_rj"></a>properties::rj(t)


```javascript
if(typeof(t) != "undefined") {
    this._rj = t; 
    return this;
}
return this._rj || 0;
```

### <a name="properties_scaleFactor"></a>properties::scaleFactor(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("scaleFactor", t);
    return this;
}
return this._model.get("scaleFactor");
```

### <a name="properties_shadowBlur"></a>properties::shadowBlur(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("shadowBlur", t);
    return this;
}
return this._model.get("shadowBlur");
```

### <a name="properties_shadowColor"></a>properties::shadowColor(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("shadowColor", t);
    return this;
}
return this._model.get("shadowColor");
```

### <a name="properties_svgPath"></a>properties::svgPath(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("svgPath", t);
    return this;
}
return this._model.get("svgPath");
```

### <a name="properties_text"></a>properties::text(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("text", t);
    return this;
}
return this._model.get("text");
```

### <a name="properties_theList"></a>properties::theList(t)


```javascript

var me = this;
var applyShadows = function(obj, display, data, ctx) {
    if(!obj.hasOwn("shadowColor")) {
        obj.set("shadowColor", function(v) {
            return "#ffee22"; 
        });
        obj.set("shadowBlur", function(v) {
            return 20; 
        });
    } else {
        ctx.shadowColor = obj.shadowColor();
        if( obj.hasOwn("shadowBlur") ) ctx.shadowBlur = obj.shadowBlur();          
    }    
}


surface.registerRenderer( "image", function(obj, display, data) {
      
      if(!data._imageObj  && !data._loading) {
          var imageObj = new Image();
          data._loading = true;
          imageObj.onload = function() {
              data._imageObj = imageObj;
              data._width = data._imageObj.width;
              data._height = data._imageObj.height;
              // context.drawImage(imageObj, 69, 50);
          };
          imageObj.src = obj.url()+"?t="+(new Date()).getTime();
      }
        
    }, 
    function(obj, display, data) {
        
        if(data._imageObj && data._width) {
            var ctx = display.getSurface().getContext();
            ctx.save();

            var mat = obj.getViewMatrix(display.getCamera());
            mat.setDomContext( ctx );
            
            ctx.globalAlpha = obj.alpha();
            
            ctx.drawImage( data._imageObj, 0, 0, data._imageObj.width, data._imageObj.height, 
                            0,0,obj.w(), obj.w()*(data._height/data._width));

            ctx.restore();
        }
    }, function(obj, display, data) {

    }); 
    
surface.registerRenderer( "box", function(obj, display, data) {
    }, 
    function(obj, display, data) {
        
        var ctx = display.getSurface().getContext();
        ctx.save();
        ctx.beginPath();
        if(obj.bgcolor) {
            ctx.fillStyle=obj.bgcolor();
        }
        if(obj.alpha) {
            ctx.globalAlpha =obj.alpha();
        }        
        var mat = obj.getViewMatrix(display.getCamera());
        mat.setDomContext( ctx );
        ctx.rect(0,0,obj.w(),obj.h());
        applyShadows(obj, display, data, ctx);
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }, function(obj, display, data) {

    }); 

// renderer for some display class is presented like this...
surface.registerRenderer( "circle", 
    function(obj, display, data) {

    }, 
    function(obj, display, data) {
        
        var ctx = display.getSurface().getContext();
        ctx.save();
        ctx.beginPath();
        if(obj.bgcolor) {
            ctx.fillStyle=obj.bgcolor();
        }
        if(obj.alpha) {
            ctx.globalAlpha =obj.alpha();
        }        
        var mat = obj.getViewMatrix(display.getCamera());
        mat.setDomContext( ctx );
        
        var r = Math.min( obj.w()/2, obj.h()/2 );
        ctx.arc(r, r, r, 0, 2 * Math.PI, false);
        
        applyShadows(obj, display, data, ctx);
        
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }, function(obj, display, data) {

    });
    
surface.registerRenderer( "svgpath", function(obj, display, data) {
    
    
    }, 
    function(obj, display, data) {

        if(!obj.hasOwn("svgPath")) return;
        if(!obj.svgPath()) return;

        
        var ctx = display.getSurface().getContext();
        ctx.save();
        
        ctx.beginPath();

        var svgPath = obj.svgPath(),
        w = obj.w(),
        h = obj.h();
      
        var parser = svgPathParser();
        parser.parse(svgPath);
        parser.makePathAbsolute();
        parser.fitPathInto( w, h );
        
        if(obj.hasOwn( "bgcolor") ) {
            ctx.fillStyle  =obj.bgcolor();
        }
        if(obj.hasOwn( "alpha") ) {
            ctx.globalAlpha =obj.alpha();
        }        
        var mat = obj.getViewMatrix(display.getCamera());
        mat.setDomContext( ctx );
        
        parser.drawPath( ctx, w, h); 
        
        applyShadows(obj, display, data, ctx);
        
        ctx.fill();
        ctx.closePath();

        ctx.restore();
    }, function(obj, display, data) {

    });    


// renderer for some display class is presented like this...
surface.registerRenderer( "text", 
    function(obj, display, data) {

    }, 
    function(obj, display, data) {
        
        if(!obj.hasOwn("text")) return;
        if(!me.isFunction(obj.text)) return;
        
        var txtAlign = "left";
        if(obj.hasOwn("txtAlign")) txtAlign = obj.txtAlign();
        
        var page = {  w : obj.w(), h : obj.h(), 
                      align : txtAlign,
                      fontSize : 13, 
                      fitToPage : true,
                      fontFamily : "Arial" };      
          
        if(obj.hasOwn("autoFit")) {
            page.fitToPage = parseInt( obj.autoFit() );          
        }

        if(obj.hasOwn("fontSize")) {
            page.fontSize = parseInt( obj.fontSize() );          
        }        
        
        var ctx = display.getSurface().getContext();
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 0.01;
        if(obj.bgcolor) {
            ctx.fillStyle=obj.bgcolor();
        }
        if(obj.alpha) {
            ctx.globalAlpha =obj.alpha();
        }        
        var mat = obj.getViewMatrix(display.getCamera());
        mat.setDomContext( ctx );
        
        applyShadows(obj, display, data, ctx);
        
        var canvTools = canvasUtils();
        canvTools.renderText(obj.text(), page, ctx);

        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }, function(obj, display, data) {

    });
        
    
    
```

### <a name="properties_txtAlign"></a>properties::txtAlign(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("txtAlign", t);
    return this;
}
return this._model.get("txtAlign");
```

### <a name="properties_w"></a>properties::w(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("w", t);
    return this;
}
return this._model.get("w");
```

### <a name="properties_x"></a>properties::x(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("x", t);
    return this;
}
return this._model.get("x");
```

### <a name="properties_y"></a>properties::y(t)


```javascript
if(typeof(t) != "undefined") {
    this._model.set("y", t);
    return this;
}
return this._model.get("y");
```


    
    
    
## trait events

The class has following internal singleton variables:
        
        
### <a name="_on"></a>::on(en, ef)
`en` Event name
 

Binds event name to event function
```javascript
if(!this._ev) this._ev = {};
if(!this._ev[en]) this._ev[en] = [];

this._ev[en].push(ef);

if(this._model) {
    this._model.on(en,ef);
}

return this;
```

### <a name="_trigger"></a>::trigger(en, data, fn)

triggers event with data and optional function
```javascript

if(!this._ev) return;
if(!this._ev[en]) return;
var me = this;
this._ev[en].forEach( function(cb) { cb(me, data, fn) } );    
return this;
```


    
    


   
      
    
      
    
      
    
      
    
      
    



      
    




